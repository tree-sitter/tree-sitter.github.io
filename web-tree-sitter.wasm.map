{
  "version": 3,
  "sources": [
    "lib/alloc.c",
    "lib/get_changed_ranges.c",
    "lib/array.h",
    "lib/length.h",
    "lib/subtree.h",
    "lib/point.h",
    "lib/language.h",
    "lib/subtree.c",
    "lib/language.c",
    "lib/lexer.c",
    "lib/node.c",
    "lib/tree.c",
    "lib/parser.c",
    "lib/stack.c",
    "lib/atomic.h",
    "lib/reusable_node.h",
    "lib/clock.h",
    "lib/reduce_action.h",
    "lib/query.c",
    "lib/unicode.h",
    "lib/tree_cursor.c",
    "lib/tree_cursor.h",
    "lib/tree-sitter.c"
  ],
  "names": [],
  "mappings": "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B,GACX,OACP,oCAElB,GA3PiB,E,EAAA,GAPA,GAOH,MAmQH,6CA5TjB,kBAoUJ,C,KAQkB,WA5Ud,iBAkXJ,MAnCgB,uC,EACa,Q,EAAA,gBAjTT,WNsPD,CAAV,EAAoC,OMrPP,GAKrB,KJgJR,EIhJQ,EADD,KJkJL,KAAsC,KAAR,KAApC,GADI,GIhJQ,EJiJZ,KI7HmB,eNyJmC,Y,CMzJnC,ENyJmC,uBMzJnC,ENyJmC,OMtJrD,WAEe,YNsMf,I,CAAA,IAIe,OCpRT,KDoRS,cCpRT,QDgRI,aChRJ,GDgRN,EDpQsB,SO6VT,OAKT,E,CAAA,+BAhTiB,CAOH,WNyJmC,IMzJnC,QACE,ENwJiC,YMzJnC,ENyJmC,uB,CMtJrD,EACE,UACa,MADb,KACa,IAEW,IAER,I,CAAA,WNyLlB,MAAU,OAC+B,GAD/B,YAEZ,GAEiB,sBC3QT,eFYgB,MOkEJ,ENkMlB,MAAU,aAAV,EChRM,KDoRS,OCpRT,KDoRS,cCpRT,MDgRN,EMyFa,EP7VS,KO6VT,GP7VS,EOkWlB,yBAhTiB,KAOH,MA6SF,OAlRhB,YN4HuD,CM5HvD,EN4HuD,qBM3HzB,aAG5B,W,CAAA,MNwHqD,SMrHvB,ONsHqB,IMwJjD,KAhR0C,KFkBnC,OAAN,OAAP,CE8PM,MNzJmD,UMrHvB,ONsHqB,IMwJjD,IACkB,2CA3UR,SNsPD,CAAV,KM6FT,C,KLxWgB,SAAmB,KKgX7B,cA1XF,iBAkaJ,MArCgB,uC,EACa,Q,EAAA,gBA/VT,WNsPD,CAAV,EAAoC,OMrPP,GAKrB,KJgJR,EIhJQ,EADD,KJkJL,KAAsC,KAAR,KAApC,GADI,GIhJQ,EJiJZ,KI7HmB,eNyJmC,Y,CMzJnC,ENyJmC,uBMzJnC,ENyJmC,OMtJrD,WAEe,YNsMf,I,CAAA,IAIe,OCpRT,KDoRS,cCpRT,QDgRI,aChRJ,GDgRN,EChRM,OAkBI,SAAS,EAAU,KKqYzB,K,CAAA,ELzXK,KK8XL,K,EL9XK,EAhBoB,KK8YzB,YL1YyB,KK0YzB,kBA9ViB,CAOH,WNyJmC,IMzJnC,QACE,ENwJiC,YMzJnC,ENyJmC,uB,CMtJrD,EACE,UACa,MADb,KACa,IAEW,IAER,I,CA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,KAApC,Mc2Qc,Md3Qd,McqQsB,EdrQtB,IciRY,CVjdF,yBU+cJ,OVhdQ,sBACgD,CAA9D,oCU6lBwC,CV7lBxC,EU6lBF,+BAAmC,CAI3B,eAHmB,MAIS,CAGhB,GAAS,GAAK,Gdta3B,KcqaW,KdpaV,KAAsC,KAAR,KAApC,EcsaW,OdtaX,KcwamC,gBAA8B,OhBxZR,QgBwZQ,EhBxZR,oB,CgB0ZrD,MAb2C,CAIzC,SASF,KV1mBM,qBU6mBC,UV7mBX,EAuagD,ONnKpC,QAAV,EMmK8C,EAAlB,QNnK5B,MACyB,EMkKG,GLnbtB,KDoRS,OCpRT,YDoRS,YM+Ja,IAAkB,EQ8sGa,c,CAAA,EAUxC,SAVwC,GR9sGb,ELra3B,EKqa2B,ONnKpC,QMmKoC,EQ+sGL,KAAT,Edl3GhC,MACyB,EMkKG,GQ+sGI,Cdl3GhC,Eck3GoD,WbpnHjC,GaonHiC,EAAX,KAAT,Ed92GjB,KM+Ja,GQ+sGI,CbpnHb,EDsQJ,CCtQI,EDsQJ,OCpRT,KDoRS,OCpRT,MKmbwC,EQgtG5C,KbrnHQ,GAAS,EaqnHjB,CbrnH2B,KAdvB,EamoHJ,GbnoHI,KAcgC,GKqaQ,EQmtGH,SAAT,CAAkB,EAClD,Ob7mHQ,GAAS,EAAU,Ka6mH3B,E,EAAA,Gb7mHoC,IagnHd,K,CAAA,sBATmC,EASnC,IACb,OAAmB,IAEgB,GAD5C,Kb1nHQ,Ea0nHR,Eb1nHQ,Ca0nHR,Eb1nHiB,Ia8nH4B,E,CAAA,Sb9nHlB,ca0nH3B,Gb1nHoC,Ma0nHG,cAChB,OAAqB,OAGC,4BANvB,iBAMuB,GACzB,OAAT,CAAS,EAAS,eAC7B,KbxnHQ,EawnHR,EbxnHQ,CawnHR,EbxnH2B,KawnH3B,E,EAAA,GbxnHoC,Ca2nHY,E,GAAA,UAExC,UAAN,GR3tGJ,M,CAAA,ENjO0D,gBI5FnD,GJ4FmD,Y,EAAA,II5FnD,Q,EE8TiC,KF7T/B,SADT,GACG,ME4TH,EF5TG,gBE4WA,WFvXL,GEuXK,IACoC,KFtX5B,OAAN,OEqXF,GFrXL,GJsGuD,+BAGE,+Bc+7G5C,cACA,GACT,M,IEnrGoB,K,EAAA,EAChB,I,EAAA,EACO,G,EAAA,EACG,I,EAAA,EACM,I,EAAA,EACe,IAIX,EF0qGxB,EE1qGwB,OAAhC,CAAE,yCAC2B,UACO,EAIhB,GAAS,KAAK,Gd5TzB,EcuToB,EdtTlB,KAAsC,KAAR,KAApC,GADI,GcuToB,EAkBD,WhB5S+B,YgB4S/B,EhB5S+B,uBgB4S/B,0BhB/SoC,mCIzGnD,WAKI,SAAN,IY2Zc,OAAf,CAAe,EAAS,WZ3ZvB,OAAP,CY8Z6B,gBAC3B,EAA6B,K,EAAA,IACX,SALC,OAAf,CAAwB,GASzB,E,EAAA,IAAD,EAC8C,KAAK,KhB9TA,uCgBiU5B,OAA/B,CAAkD,KAA5C,OhBjUqD,GgBgUjD,GAEgB,EAGhB,IAHgB,+BhBlUiC,GgBkUjC,EhBlUiC,uBgBqUjD,uBhBxUsD,2BAGL,EAHK,gBIzGnD,WAKI,SAAN,SY8akB,CAAjB,U,EAAA,EACkB,I,EAChB,UAFF,CAGE,UhBvQL,IAAoC,KAoBV,GACd,KgBsPsC,G,EAAA,EAC7B,I,EAChB,MACa,KAAkB,GhBjVc,c,EAAA,EgBwU7B,I,EAChB,O,EAAA,ahBzU6C,MgBsV/C,OArBZ,CAAkD,KAA5C,IA2BE,EhB5VmD,qCgB4VnD,EdpWI,KAAY,GAON,KADS,KckWI,KAAK,KdlWf,SACT,EADS,WAE0B,I,EcqWpC,IAAD,E,CAAC,EACH,SACY,S,CAAA,EAAwC,KAAtB,KAAY,CAApB,OAD+C,CAApB,KAAjD,M,EAEqB,KAAP,MAOZ,MACF,KAES,SAAS,GAAa,EACD,KAArB,KAAY,CADU,E,EAAA,EAGc,IACzC,OANiE,CAApB,KAAjD,IAVA,IA7ER,CAAE,MF+rGsC,M,CAAA,GR1vGlC,I,CAAA,EAAoC,SNjOsB,CMiOtB,ENjOsB,uB,EAAA,II5FnD,aE8TiC,KF7T/B,SADT,GACG,SUujH6B,EADE,EACF,OA0BS,qBA7BX,QAMxB,UACqB,C,CADrB,EACF,oCAKoB,OAJM,WAIN,SACyB,OAAd,OAEjB,WAEuC,CAFvC,EAAT,OAE0B,KACnB,KAAM,E,EAAA,K,CAAA,E,EACN,KAAiB,E,CAAA,EACH,KADG,KACZ,CADoC,EAGjD,MAf2B,YAAqC,CAA9B,QAAf,GAAvB,IA5nF0B,eADZ,CACiB,GAC9B,YAcS,WAVN,CAUM,EAVlB,MAC4B,CACM,mBACV,SAEnB,GACQ,IACN,SAPK,CAAZ,gBAUkB,SAEf,GAEQ,SACC,CACK,eACJ,SAEN,cAKO,EAqnFJ,EAI2B,aAHL,EAEN,SACyB,KAAR,qBAKrB,aAEuC,CAFvC,EAAT,OAE0B,KACnB,KAAM,E,EAAA,K,CAAA,EACQ,OAAT,CAD6B,EAG1C,MAKa,YADd,CACiC,OAA5B,GAEC,KADG,WACH,SACM,KAAO,GAAtB,IAIoD,K,CAAA,EAAtD,aAxD4B,WAyDN,iBAAR,KACM,UACkB,uBAK8B,KANhD,aAMiC,KAA9B,KAAY,CAAwB,CANvC,EAYR,OAAO,E,CAAP,EACE,cAAN,WAAM,EAAN,cAG+C,CAAH,YAGvB,KAAgB,E,CAAA,KAAW,MdjiHH,CciiHc,EAPvD,EAOuD,QAGtD,IAAa,UAAuB,CAAV,cAH4B,EAG5B,IAG3B,WAAc,MAGd,SAAN,cAEF,K,CACM,iBAAc,SADuB,CAApB,KAAvB,WAFQ,EAUA,qBAAN,EAAM,EACW,QAAH,GACT,MAAD,MAQE,KAAN,YAAM,KAAN,QAkBE,eADF,MAhB6B,gBAEA,WAGvB,E,EAAA,mDADa,GACqC,gBAWxD,eAsBwB,WACpB,CAAkB,EACS,KAl3BzB,MAGL,WAAM,CAAuB,EACf,OAAR,CAAc,EAClB,QAA0B,GAAS,KA22Bd,GAnZtC,SAuZgB,EArZyC,O,EAD7B,KAER,gBADsB,kBAEnB,GAGV,WAAgB,CAAhB,EAEL,EADwB,SACxB,E,CAAA,EADwB,ChBnuGC,OgBuuGpB,KA1gGJ,EAAc,KAAd,CAAc,EAAd,IAAkC,EAClC,YADc,EA4gGnB,mBhBhvGyC,GAvClB,OAAR,UACX,MACe,YACnB,GACmB,WAHf,EAKW,cAyCP,KAAK,OAIC,OAAW,CAHzB,yBAMY,wBACR,IACF,kBAMA,eAOO,aAvBoB,QAPL,SAAiB,CAvClB,OAAR,CAuCS,EAvCT,OACX,MACe,YACnB,GACmB,WAHf,EAKW,cAyCP,QAAK,EADgB,IgB4uG/B,G,EhB3uGe,iBAGQ,GACP,OAAW,CAHzB,8BAQE,oBAaO,a,EgBstGE,QAAF,GACJ,YAZI,EAab,SAmYgB,KAaF,KAAO,gBAAP,EE7uGkB,E,EAAA,OAAY,CAAZ,E,EAA9B,WAAmC,CAI3B,E,CAJR,EAIQ,iBAHmB,MAIS,CAGhB,GAAS,GAAK,Gdta3B,EckaC,EAGI,KAAM,GdpaV,KAAsC,KAAR,KAApC,EcsaW,OdtaX,KcwamC,KhBxZsB,IgBwZQ,OhBxZR,QgBwZQ,EhBxZR,oBgB0ZrD,MAb2C,CAIzC,QAO6B,KVxmBzB,cU6mBC,OADD,OV7mBI,UACd,qBQ40HY,aAEU,IACd,WACsB,gBAGG,OAEE,CAAY,YAEZ,IAHzB,OAK2B,CAAvB,OAAsC,GAExC,4CAWF,SAAqB,CAArB,EACF,+CAGS,YAAP,EAOa,eAOM,qBAaY,EAHzB,SAA0B,EAAU,QAAS,EAAc,QAAd,QACpB,CACnC,SACmC,KAGT,IAAc,QAAd,UAMH,CANG,EAM1B,WADuB,OAGG,cADE,eACF,WACR,WAAkB,CADV,EACU,OAIhB,YACU,OAExB,WAMc,CANd,EAME,MACqB,QACtB,UAvfG,cAIP,SAAgB,CAAhB,EAAgB,cAp/FjB,aAAwB,6BAEC,SAAK,OADe,CAA9B,KAAvB,IAYa,OAAT,CAAS,EAKf,OhBnRqB,KAAR,EAAQ,EAAR,CAAQ,EAGF,EAHN,IAC4B,OAFV,CAIZ,uBA7Bb,MACe,YACnB,GACmB,WAHf,EAKW,cgBwSjB,U,EAAA,kCAs5F6B,QACI,cAG3B,wBAME,GACF,KAAY,KADV,EAOwB,WACY,aACT,GACX,eACE,WAz8F1B,GACO,MA48FD,UA97FA,SAC6B,UA+5FR,UA96FpB,KAigGD,ShBpuGyB,OgBuuGpB,KA1gGJ,EAAc,KAAd,CAAc,EACd,c,EA2gGL,mBhBhvGyC,GAvClB,OAAR,UACX,MACe,YACnB,GACmB,WAHf,EAKW,cAyCP,KAAK,OAIC,OAAW,CAHzB,yBAMY,wBACR,IACF,kBAMA,eAOO,aAvBoB,QAPL,SAAiB,CAvClB,OAAR,CAuCS,EAvCT,OACX,MACe,YACnB,GACmB,WAHf,EAKW,cAyCP,cgB2uGV,ChB3uGe,E,EAAA,CAAL,EAAK,cAGQ,GACP,OAAW,CAHzB,8BAQE,qBAaO,agBstGE,KA4eG,aAW6B,OAAd,OADP,OADD,GAGO,QAAZ,GAC4B,mBAnCD,IAAd,KAAvB,UA1GM,eAQO,KA51Gd,EAAc,KAAd,GACP,SAA4B,IAAK,GACJ,chB9T7B,SAG4B,IAAK,CADjC,EAFA,EAEA,KAAF,UAAE,OAEU,yBgBwkH+D,E,GAAL,GAAR,OAAf,GAAvC,OAwNA,KACsB,iBACT,S,CADS,EAChB,YAUd,CAAqC,KAA3B,EAC4B,eAOX,KAAsB,KAAV,GACZ,KAAwB,KAAV,OAriHlB,KA8zFP,OA9zFP,GAAc,EACd,kBAi0FQ,OAl0FR,K,CAk0FQ,EAj0FR,sBAo0Fc,QADA,uCAKX,aACmB,eAER,KADS,aACS,KAAf,GAFK,EAEsB,KAAgB,KAAV,OAEhD,OADA,GAEH,GAxCG,YAGQ,KACA,OR5yFiC,ONnKpC,QMmKoC,ENnK9C,IACyB,EAC3B,GAEiB,MM+Ja,OAAkB,ONnKpC,QMmKoC,ENnK9C,IACyB,EAC3B,GAEiB,MM+Ja,GQ+yFV,aAyCT,GAMA,IADA,QA9CS,IAyCT,CAbgB,EAkBhB,qCATA,QAXL,gCA8BE,WA0sBI,sBACS,KAA2B,KAAhB,CAAX,EAzgHhB,E,CAAA,EACP,SAA4B,IAAK,GACJ,chB3TD,OAAK,IADjC,EAC4B,EAD5B,QAAF,KAAE,OAEU,agB00HI,GAEwC,gBAExC,WACS,KAA2B,KAAhB,CAAX,EAMkD,KA7hHlE,EAAc,KAAd,CAAc,EACrB,SAA4B,IAAK,GACJ,chB9T7B,SAG4B,IAAK,CADjC,EAFA,EAEA,KAAF,UAAE,OAEU,mBgBu1HK,GAUH,GANoC,yBA/ClD,CAAoD,OAAf,GAA3B,IA6DyB,eACR,SAAM,GACR,QAAP,EAIF,ShBh1HY,SAAK,CACV,OAAR,GADa,EAIP,EAHN,IAC4B,CAEtB,yBA7Bb,MACe,YACnB,GACmB,WAHf,EAKW,cgBo2HH,W,GAAA,+BhBn3Hd,KgBo3Hc,UhBj3Hc,OAAK,CADjC,EAFA,EAEA,MAAF,CAAE,OAEU,mBgBk3HK,YAlFoC,YhBjyHvB,IAAK,CADjC,EgBkyHmD,EhBlyHnD,MAAF,CAAE,OAEU,gBgBgyHmB,KAAvB,IAvfoB,YAAS,KAAc,KAAR,CAAf,QAM1B,EAN0B,EAM1B,+BACsB,EACG,OAEV,YAJf,EAKkD,KAAvC,KAAY,GAAmB,CADE,OAJC,CAAtB,KAAvB,IAWU,KAAe,KAAT,GAOL,MAAP,E,EAMgB,G,EAAA,KGh9GU,KACV,GAAb,OjB6QU,CAAV,EAEc,UAAmC,KcisGlD,GAGF,yBdpxG0D,OcoxG1D,yGA8iBI,OACM,MAAR,WAac,WAXC,yBAxcG,aE7wGjB,iBFixGH,OAEe,M,CAAA,EAAP,IAEoB,IADX,kBAGG,IAQhB,GALU,QAAN,CAAM,EAAN,IAEoB,IADX,kBAGG,IAChB,KE/tGsB,OAAY,CAA1C,EF+tGQ,EE/tGR,MAAmC,CAtYpB,EAsYf,EAtYe,aAEJ,EAFI,UADU,EACoB,KhBuNc,QgBvN5C,EhBuN4C,KgBvN5C,MhByN0C,OAFE,UgBvN5C,MhByN0C,KgBvN9C,MACuB,CAGhB,GAAS,GAAK,GdgMzB,KcjMG,KAAM,GdkMR,KAAsC,KAAR,KAApC,EchMS,OdgMT,KcgMI,OAD8C,CAtYrC,W,EAwYM,KFguGA,cACb,IAEe,KAFf,IAEe,C,KAzUM,KADX,iBACyB,KAAR,KAqBL,WAC9B,E,CAD8B,EhBrmGC,+BgBumGJ,MACT,IAAY,KACA,WAIZ,IAA0B,OAAZ,GAJF,EAI4B,IACxC,IAAW,GAD6B,GAGxB,YAE3B,CAZP,WAoBA,WhBjoG2C,CAvClB,OAAR,CgBwqGjB,EhBxqGiB,OACX,MACe,YACnB,GACmB,WAHf,EAKW,cAyCP,egBqmGV,IAoBA,WhBznGe,SAIC,OAAW,CAHzB,6BAQE,yCAaO,cgB+mGb,C,OA0Da,aAAP,QACwB,GACxB,KAMoB,YACG,EACzB,ShB9tGwB,SAAK,CACV,OAAR,GADa,EAIP,EAHN,IAC4B,CAEtB,yBA7Bb,MACe,YACnB,GACmB,WAHf,EAKW,cgBkvGf,W,GAAA,wDAFsB,YACG,EACzB,ShB9tGwB,SAAK,CACV,OAAR,GADa,EAIP,EAHN,IAC4B,CAEtB,yBA7Bb,MACe,YACnB,GACmB,WAHf,EAKW,cgBkvGf,W,GAAA,wDAFsB,YACG,EACzB,ShB9tGwB,SAAK,CACV,OAAR,GADa,EAIP,EAHN,IAC4B,CAEtB,yBA7Bb,MACe,YACnB,GACmB,WAHf,EAKW,cgBkvGf,W,GAAA,yDASJ,EAhBgB,eAgBhB,C,EArQA,SAEe,OACA,OACE,GACuB,O,CAAA,EAAtC,UACsB,eACT,YAAP,MAIK,KA5vFJ,EAAc,KAAd,CAAc,EACd,cA6vF0C,KAA3C,CAA8B,EAAa,KAAb,GAIpB,WAAoD,gCRnwFlB,GNnKpC,Qcs6FsD,EAEhC,Kdx6FhC,MACyB,EMkKG,GQqwFL,CAAoB,KAAX,Kdp6FjB,KM+Ja,GQqwFL,CAAoB,Idp6F5B,OCpRT,YDoRS,Qcq6Ff,Ob3qGU,GAAS,EAAU,Ka0qGc,E,EAAA,kBAGd,oBAC5B,GACD,SAKQ,GACU,OAAF,GAAe,EACd,KAAgB,EAA0B,KAAhB,KAAc,CAD1B,GAGb,sBACd,aAI2C,KAAhC,GACf,QAAiB,CAAN,GAKE,OACA,OACW,OAAT,aAzC0B,CAAP,OAAf,CAAvB,MA4CA,C,EEziGF,eAzJgC,2BACU,GhB4QvB,U,CgB7Qa,EhB6Qa,KgB5QM,OACjB,GAAoB,SAArB,iCAA7B,GAGM,KAAM,OACc,KduKrB,EcvKqB,EdwKnB,KAAsC,KAAR,KAApC,GADI,GcvKqB,EdwKzB,IcrKqC,cACmB,CAzB5C,KhBuN4C,UgBvN5C,MhByN0C,CgBvN9C,cACuB,CAGhB,GAAS,GAAK,GdgMzB,KACC,OAAsC,KAAR,KAApC,EchMS,OdgMT,KcnMO,GAqBL,cAMQ,OAFiB,OAEjB,SACc,uBAHG,0BAgJtB,oBAAP,GACM,cACF,EADE,IlBgByB,CACV,OAAR,GkBjBP,ElBoBa,EAHN,IAC4B,CAEtB,yBA7Bb,MACe,YACnB,GACmB,WAHf,EAKW,ckBKb,W,GAAA,OACA,GAEwC,ShB0G3B,QAAV,EAAoC,KAoBV,GACd,KgB/HkC,GAL9C,kBAAP,MAKqD,IACjD,EADiD,IlBYtB,CACV,OAAR,GkBbwC,ElBgBlC,EAHN,IAC4B,CAEtB,yBA7Bb,MACe,YACnB,GACmB,WAHf,EAKW,ckBSb,W,GAAA,IAJA,QADE,EAKF,sB,EAAA,kBAKN,W,EA5IA,YACoB,OAAI,KAAS,KAAiC,OAArB,GAArB,IAIF,kBAEc,SALV,KAKU,QALV,SACd,iB,EAAA,oBAOD,EhBiKkD,oCgBjKlD,GhBmKgD,qC,CgBjKrD,EAI0B,OAHlB,KAAN,EAAM,EAAN,QACU,KAAH,kBAEiB,IhB8OZ,mBAAU,EAAa,KAAlC,GAEO,QgB7OS,UACnB,MAIa,EhBuMH,cAAV,IDpQgB,wBCoQN,KDpQY,EAAN,KAAM,CEZhB,KFYU,KCwQD,KCpRT,SFYU,eEZV,KDoRS,ODxQC,KCwQD,KDxQO,ECoQZ,EgBvMG,OACA,ef1EP,EFaM,GEbN,KFaM,KiB4DC,GAGoB,OAAK,KAApB,KjBhEF,OiBgEE,UACC,WhB0LT,QgB3LQ,EhB2LlB,IgB1LmB,KhB2L8C,OgB3L9C,IhB2LgC,OgB3LhC,KhB2LJ,CACjB,GAEiB,oBD/PO,GiBkEP,Kf9ET,KFaM,CiBiEG,Ef9ET,QFaM,KiBiEG,IAIrB,G,EAuNA,eAEsC,aAEZ,CAAxB,4BAC0B,6B,EAAA,qCA1RI,CACU,GhB4QvB,U,CgBaS,EhBbiB,KgB5QM,OACjB,GAAoB,WAArB,UAA7B,GAGM,OAWI,OAFiB,EARD,KduKrB,EcvKqB,EADd,KdyKL,KAAsC,KAAR,KAApC,GADI,Gc/JsB,UAEjB,QA4QmB,OAAR,KAEK,kBACQ,OAAR,OAErB,GACL,qBACI,OAAQ,CAAR,EAAuB,OAAK,CAAI,GAAxB,GAEL,sBAAP,GACM,cACF,SlBxHoB,SAAK,CACV,OAAR,GADa,EAIP,EAHN,IAC4B,CAEtB,yBA7Bb,MACe,YACnB,GACmB,WAHf,EAKW,ckB4IX,W,GAAA,eACA,GAGwC,ShB9B7B,QAAV,EAAoC,KAoBV,GACd,KgBSX,GANC,oBAAP,OAMM,IACF,SlB7HoB,SAAK,CACV,OAAR,GADa,EAIP,EAHN,IAC4B,CAEtB,yBA7Bb,MACe,YACnB,GACmB,WAHf,EAKW,ckBiJX,W,GAAA,YANE,EAMF,sB,EAAA,oBAnBa,SAAK,CAAxB,IAyBiB,YAEnB,W,EFoyHA,6BASS,GACyB,0BAaiB,SAA/C,EAA+C,EAA/C,IAFuC,OACC,WA9sHrB,UAgtHG,eAGX,KAntHN,EAAc,KAAd,CAAc,EAutHN,WAAuB,EAttH/B,eAstH4C,KAAb,OAAxC,MAAiB,WAAuB,EAAa,KAAb,OAAxC,OAAwC,GA9qHV,OAAK,GACJ,oBhB3TD,IAAK,CADjC,EgB4T6B,EhB5T/B,YAAE,OAEU,egB6+HJ,GAGY,WAAoD,uBbtoI/C,EasoI+C,ORjuHpB,GNnKpC,Qco4HwD,Edp4HxD,Mcu4HwB,Kdv4HxB,MACe,EMkKG,GQouHH,G,CAAA,EbzoIN,GayoI0B,EAAX,Kdn4HnB,KM+Ja,GQouHH,CbzoIN,EDsQJ,CCtQI,EDsQJ,OCpRT,KDoRS,OCpRT,MaopI4D,EAIhE,Kb1oIQ,GAAS,Ea0oIjB,Cb1oI2B,K,Ea0oI3B,GbxpII,KAcgC,GasoI4B,EAO9B,WAAT,CAAkB,EAC3C,ObloIQ,GAAS,EAAU,OakoI3B,E,EAAA,GbloIoC,EaooIW,GAG7C,UAC2B,gBA/Bc,OAgC3C,GAKgB,WAQsB,QANpB,KAA+B,EACxC,OAAc,GAHuB,KAA9B,EAA8B,aAU/C,IA/CoB,KAAvB,GAsDI,KAEO,UACD,KAKN,KALM,cAMG,SAAG,CAAH,EAAiD,eAArB,QAC7B,OACoB,OAAT,GAGZ,KAnxHN,EAAc,KAAd,CAAc,EACd,cAoxHyB,E,EAAA,GAAZ,GACiB,OAAZ,GACG,UAAP,CAAF,GACc,2BADd,EACc,GA5wHpB,OAA6B,EAAc,KAAc,OAAT,CAgxHF,MASrD,gBAAwD,OA7vHvD,GA6vHD,EA5vHN,SAA4B,IAAK,OACJ,IhB9T7B,SAG4B,IAAK,CADjC,EAFA,EAEA,MAAF,CAAE,OAEU,kBgB6jIL,EAAqC,EAChB,KADgB,MArH5C,EAyHA,U,CLvuHA,KAEgB,KAAiB,KAAH,EAK9B,C,EASgB,K,CAAA,E,EAAA,EAShB,IARkB,MAQlB,C,IAYyB,K,CAAA,E,EAAA,EAEhB,O,EAAA,EAST,IAT8C,OT1UkB,mBA8I/B,CS4LX,MACH,QAQnB,G,CAmBA,KAEmB,KAAM,IAAhB,CAAP,C,ENlfF,SACE,GACa,OAAb,KACkB,oBAAD,OH0IwC,CG1IvC,EH0IuC,uBGzInD,kBACQ,IACV,SL4GsB,SAAK,CACV,OAAR,GADa,EAIP,EAHN,IAC4B,CAEtB,yBA7Bb,MACe,YACnB,GACmB,WAHf,EAKW,cKxFb,W,GAAA,yBAJS,KAAb,MAamC,SAAY,CAA/C,UAAF,KAAE,kBAEkB,iBAAD,OADc,aAAS,IAEf,IAAD,MACrB,QAAiC,KAFlB,UAAD,OADc,iBAAS,IAEf,IAAD,MACrB,QAAiC,SAJqB,OAAzD,kBAEkB,aAAD,OADc,aAAS,IAEf,IAAD,MACrB,QAAiC,MAPtC,C,EA0OA,GAGO,SACyB,OADF,OAGL,OADF,OAMQ,GAHC,WAEc,IAIoC,KDpJzE,ECoJyE,EDnJvE,KAAsC,KAAR,KAApC,gBCsJuB,IAC1B,I,CAAA,yBACkB,uBAGQ,OAAS,WHI5B,QGJ4B,GAGH,iBJpVZ,EIoVY,MASX,EATW,OHHzB,E,CGGyB,EHHzB,WGOyC,oCAGxC,IACgB,qBHpFL,8BGmFX,IACgB,cHhG6C,CGgG7C,SHhG+B,IGgG/B,aHvFK,OGwFR,iBACnB,QHlGmE,OADvD,GACyC,OAQzC,CDpQY,KEZhB,KDoRS,OCpRT,YDoRS,YDxQO,IAAN,KAAM,CI+VL,KF3WX,OFaM,CEbN,OFYU,KEZV,IFaM,KI8VK,GAIC,QAAM,OH5I2C,YART,EAQS,EGqKxC,EHrKwC,oB,CAAA,SART,WG2J/B,CH3J+B,EG2J/B,KACN,EHvJkC,U,IAgGd,MGuDpB,iBHtFkB,OG2F7B,SAA+B,G,CAAA,IH9JY,Y,CA2I1B,KA3I0B,MA2I1B,C,CAAA,MA7I4B,CGoKjD,MAGmB,OAA4C,QAAb,CAA/B,QH9DY,MGkDhB,WHvJkC,OA6FvD,CG0DqB,cHpJ8C,IG6I9C,CAEM,mBAUjB,SAA+B,WHhKc,CGoKjD,EAS2B,OAGR,OHvEY,UG4DZ,cH5DY,MAlG8B,EAkG9B,OAAlC,iBG4DsB,KAQQ,WAGR,KHjLiC,IGiLjC,MHjLiC,OA0Ga,MGmE5C,SHvFjB,IAoB6D,KApB7D,GGwFuB,EH1FI,OAE3B,MAFP,GG0F8B,WH3KoB,UG8K5B,EHjLiC,UGkLjC,CAAK,cAE9B,OADe,aAGmB,IACL,aACa,aCjSnC,OAKI,SAAN,OD4RuE,CAAxE,KHvLmD,0BG2LrB,IACL,aH3LwB,kBADE,CG0L9C,SACyB,IACL,iBH3LwB,KAMc,EANd,IG4LjD,OACsB,KACI,OAAc,KAAd,IACY,sBH9LW,EA2HlD,I,CAAA,aGsEoE,eHpMb,SA8I/B,CA9I+B,EGsMxD,MAEoB,GAD2B,SAA1B,KHpM8B,wBGwMnD,OA7E2C,CAAnB,OAAK,KAAZ,GAAvB,IAgFgE,SAA0B,OAApB,EAA5C,GAGd,WAA+B,CAA/B,EAM4C,EAHjC,KAGiC,SAAxB,CAFJ,CAC2B,IAFhC,kBAQA,UADC,WH3LV,C,CG2LU,EH3LV,SACA,KAAY,KG6LI,YHvLhB,KAAY,KGwLS,GHzG5B,WG2G4D,uBAFhC,WH/LH,IG8LF,UHpGb,GAAV,WGwG6D,kBAG1C,GACH,kBHtMT,CGsMS,EHtMT,QAhCgD,IGwO3B,WH9GlB,GAhD0B,UA1EmB,KGwO3B,GADd,MH7JsB,aAgD1B,CAhD0B,EAApC,EGgKsC,OHhKF,KGgKE,UACd,UAEA,YAIjC,C,EAUA,iCCpWa,eAGT,GAEa,SAAN,UD2WiB,GC3WjB,OD2WiB,IAF4B,OALC,SHjPpC,IAAkB,CGkPI,EAA3B,OAAS,CAAkB,CAA3B,EACS,oBACyB,CAA3B,GADA,OAGoD,QAEjE,gB,EAAA,0BAAkB,OAAlB,wBAWL,OAXuB,4BAVoB,CAUpB,kBAFkB,EAEpC,Y,EAAA,Q,EAAA,oE,EAAA,Q,EAAA,wCAiBgB,UACxB,iBAEF,S,Ea1WA,OACe,GAUK,0CACM,GADb,YlBsBU,sBkBnBrB,6CAXA,C,CAgDF,GAEY,UAAR,SASJ,C,EAEA,eAxLgC,yBACU,GhB4QvB,UAAV,EAAoC,KgB5QM,GAIzC,KAAM,OACc,KduKrB,EcvKqB,EdwKnB,KAAsC,KAAR,KAApC,GADI,GcvKqB,EdwKzB,IcrKqC,cACmB,CAzB5C,KhBuN4C,UgBvN5C,MhByN0C,CgBvN9C,cACuB,CAGhB,GAAS,GAAK,GdgMzB,KACC,OAAsC,KAAR,KAApC,EchMS,OdgMT,KcnMO,GAqBL,cAMQ,OAFiB,OAEjB,SACc,uBAHG,4BA+KJ,KAAwB,KAAxB,KAET,mBAET,kB,CAAA,EAUH,gBATE,YhB2EW,UAAV,EAAoC,KAoBV,GACd,KgB5FuC,MAJpD,E,IAIoD,M,IAAA,Q,EAAA,WALnD,kBAAP,GAUI,E,CAAA,SACF,EADE,IlB5B2B,CACV,OAAR,GkB2BT,ElBxBe,EAHN,IAC4B,CAEtB,yBA7Bb,MACe,YACnB,GACmB,WAHf,EAKW,ckBiDf,W,GAAA,iDAKJ,W,OAjNgC,OAsOM,WAtON,OACU,GhB4QvB,QAAV,MAAoC,OgB5QM,GAIzC,KAAM,KACc,KduKrB,EcvKqB,EdwKnB,KAAsC,KAAR,KAApC,GADI,GcvKqB,EdwKzB,IcrKqC,cACmB,CAzB5C,KhBuN4C,UgBvN5C,MhByN0C,CgBvN9C,cACuB,CAGhB,GAAS,GAAK,GdgMzB,KACC,OAAsC,KAAR,KAApC,EchMS,OdgMT,KcnMO,GAqBL,mBAoBkB,6BAbI,kEAcF,EhByKmC,YgBvLjC,EhByL+B,IAFE,YAEF,OAFE,gBAEF,KgBjKrD,KACE,UACU,KAAH,eAEiB,EAJ1B,EhBkPwB,Q,CAAA,EAAa,KAAlC,OgB1OH,OhB2MU,agB3MV,EfrEM,GDiTI,MAFc,EAEd,EA7BK,OCpRT,KeoEa,KACnB,KhB+Me,cCpRT,MD+SkB,EC/SlB,OFYgB,OiBgEJ,EjBhEI,IiB8DT,CAEK,GjBhEI,EiBgEJ,QACC,KhB0LT,QgB3LQ,EhB2LlB,IgB1LmB,KhB2L8C,GAAd,IgB3LhC,KhB2LJ,GAAkD,IgB3L9C,IhB2LgC,CACrD,GAEiB,oBgB/LG,Ef5EZ,KFYgB,OC+PP,EC3QT,WDgRN,MAAU,ODpQY,WEZhB,KDoRS,OCpRT,KDoRS,KDxQO,KCwQP,OCpRT,MDgRN,EAIe,IgBdgB,EhBchB,EgBdgB,KAAY,E,CAAA,EfhPjC,KAAS,E,CAAU,UAAS,KegPP,EhB2B5B,MAAoC,KAoBV,GACd,QgB9CX,UACE,CADF,EAEA,EADE,IlBtEqB,CACV,OAAR,GkBqEH,ElBlES,EAHN,IAC4B,CAEtB,yBA7Bb,MACe,YACnB,GACmB,WAHf,EAKW,ckB2FT,W,GAAA,4DACO,GAiBjB,EAfgC,KACtB,EADsB,IlB1EC,CACV,OAAR,GkByEiB,ElBtEX,EAHN,IAC4B,CAEtB,yBA7Bb,MACe,YACnB,GACmB,WAHf,EAKW,ckB+FT,W,GAAA,4DA1PsB,uBACU,GhB4QvB,QAAV,UgBfQ,ChBeR,EgBfQ,IACU,GACrB,GACsB,QAnOiB,KAArB,KAwOL,SAEnB,C,CAkDA,OAHS,iBAIP,SA9IU,MAAR,YAuJJ,G,EAhPA,YAGoB,OAAI,KAAiB,UAAY,KAA7B,MACE,C,CADF,EACE,gBAGJ,kBAEc,eALV,EACd,O,EAAA,qCAMD,EhByGkD,oCgBzGlD,GhB2GgD,cAyC3C,OAC+B,OA1CY,MAyC3C,YAEZ,GA3CuD,aA6CtC,oBA7CsC,EgBvGxC,uBA9Bb,KAAuB,KAAvB,KjBtFgB,OAAK,OiBsFE,IA6BV,OA7Bb,KAAuB,GA6BV,OA7BU,QA6BV,GAGN,MAAS,KAAT,KAC8B,EAA9B,EAA8B,WAA3B,KAAH,OACwB,WACH,KAKK,OAAK,KAApB,aACK,WhB8Ib,QgB/IQ,EhB+IlB,QACyB,IAC3B,GAEiB,uBgBnJG,EhBmJH,IgB3Lf,KAAuB,OAAvB,KjBtFgB,OAAK,EiBsFE,IA2CR,OA3Cf,KAAuB,GA2CR,OA3CQ,QA2CR,IAIrB,G,KAmQgC,SAAY,CAA1C,EAA8B,EAA9B,MAAmC,CAtYpB,E,CAsYf,EAtYe,wBAEJ,EAFI,UADU,EACoB,KhBuNc,QgBvN5C,EhBuN4C,KgBvN5C,MhByN0C,OAFE,UgBvN5C,MhByN0C,KgBvN9C,MACuB,CAGhB,GAAS,GAAK,GdgMzB,KcjMG,KAAM,GdkMR,KAAsC,KAAR,KAApC,EchMS,OdgMT,KcgMI,OAD8C,CAtYrC,UAwYM,YAFyB,CAOhD,C,OA6DgC,uBACgB,GhBlPW,UgBiP3B,EhBjP2B,uBgBiP3B,EhBjP2B,IgBmPjC,UACH,CADG,EACC,cACS,CAGhB,GAAS,GAAK,Gd3QzB,Kc0QG,KAAM,GdzQR,KAAsC,KAAR,KAApC,Mc2Qc,Md3Qd,YciRY,CVjdF,eU+cJ,OVhdQ,cACd,iBUodJ,C,EAkKA,GAIgC,WAAhC,CAAE,mCAC2B,EASI,KhBlb0B,KgB8anD,aAAwB,KhB9a2B,KgBvN9C,EhBuN8C,OAFE,EAEF,EAFE,KgBvN5C,MhByN0C,OAFE,UgBvN5C,MhByN0C,KgBvN9C,MACuB,CAGhB,GAAS,GAAK,GdgMzB,KcjMG,KAAM,GdkMR,KAAsC,KAAR,KAApC,EchMS,OdgMT,Kcgc4B,GhB9a2B,6BgBkbnD,EAII,OAAM,Gd9bN,KAAY,GAMG,acybP,GAAS,GAAK,Kdzbb,Oc4bjB,6BACY,S,CAAA,EAAwC,KAAtB,KAAY,CAApB,GAD2B,EAC3B,IAD+C,CAApB,GAAjD,MAEgB,cApBpB,CAAE,MAUM,EAeR,C,Ob/HgB,U,CAAA,EO3fL,EP4fT,KO5fS,MP8fT,OI1hBqD,OAAuB,OAX3D,OAWoB,SAXpB,QAEA,OADF,aAEW,QAAF,SAC8C,CAAtE,EADwB,EACxB,WAC6B,OAM7B,G,EAGF,YACM,MJ8FQ,mBI3FZ,mBJiGqB,KAAjB,EAAiB,EACuB,OAA1C,gDACU,IAAiC,GAAzC,UAAQ,KAAiC,GAAzC,QAAQ,KAAiC,GAAzC,QAAQ,KAAiC,GAAzC,YAD+C,OAAjD,4BACU,EAAiC,GAAzC,YAD+C,OAAjD,ULoCA,WK/BmB,KAAjB,EAAiB,EL+BnB,WSnIY,KAAd,UACA,WACF,Q,KQWE,mTACA,UADA,YACA,C,IASA,kFACA,G,IASA,WG9Ca,aH8Cb,4EACA,G,EPkwBF,eACY,OAAN,E,CAAM,EAAN,IAoCA,GAnCO,KAAP,ORzlBuD,WA6FvD,CQ4fA,IRzlBuD,CA6FvD,EQ4fA,CR5fA,GA7FuD,QA6FvD,E,CAGyC,MQyfzC,ERzfyC,wBAhGc,C,CAgGd,EAhGc,Q,CAAA,EAgGd,SQ2fZ,GR3fY,aQ2fZ,UR3lB0B,CQ2lB1B,cAC/B,qBAgCE,GAhCF,sBAgCE,IR5nBuD,CQ4nBvD,ERjoB0D,aQimB5D,IJ/pBE,OAAO,eAGT,OA3JgC,KAArB,KAAa,CA4JR,KACH,SAAN,QJyDqD,sBIzDrD,IJ8DkD,CI9DlD,EJyDqD,iBI9D1D,OAAO,eAGT,OA3JgC,KAArB,KAAa,CA4JR,KACH,SAAN,QI0pBP,+BAvqBqB,KAAnB,EAAmB,EAEA,OADrB,QAOQ,M,CAAA,EAAN,IA+rBA,OA7rB6C,eAA/C,kBsBxKI,GtByKiD,MsBzKjD,GtB0KI,WAAY,MsB1KhB,GtB0KF,IAF2D,GAA7D,KA4pB+B,KR9f7B,gBA7FuD,C,CA6FvD,EA7FuD,U,IAgGd,MQggBb,KR3fS,OAAlC,OArGoD,CQgmB3B,YAC9B,K,CAAA,sCRjmByD,CQimBzD,ERtmB4D,aQsmB5D,IJpqBE,OAAO,eAGT,OA3JgC,KAArB,KAAa,CA4JR,KACH,SAAN,QJyDqD,sBIzDrD,IJ8DkD,CI9DlD,EJyDqD,iBI9D1D,OAAO,eAGT,OA3JgC,KAArB,KAAa,CA4JR,KACH,SAAN,QI+pBP,kCA5qBqB,KAAnB,EAAmB,EAEA,OADrB,QAOQ,MAAN,GAE6C,eAA/C,kBsBxKI,GtByKiD,MsBzKjD,GtB0KI,WAAY,MsB1KhB,GtB0KF,IAF2D,GAA7D,KRsKyE,oBArGhB,C,CAqGgB,EAAlC,KAAlC,UQggBkC,oBRhgBkC,OQggBlC,IACvC,qBAsBE,GAtBF,sBAsBE,IR5nBuD,CQ4nBvD,ERjoB0D,aQ2mB5D,IJzqBE,OAAO,eAGT,OA3JgC,KAArB,KAAa,CA4JR,KACH,SAAN,kBJ8DkD,CAqG/B,EAAa,KAAlC,GAAoE,QA1Gb,cA0Ga,IArGhB,CAqGgB,EA1Gb,iBI9D1D,OAAO,eAGT,OA3JgC,KAArB,KAAa,CA4JR,KACH,SAAN,0BJ8DkD,CAqG/B,EAAa,KAAlC,GAAoE,QQigBzE,gDAjrBqB,KAAnB,EAAmB,EAEA,OADrB,QAOQ,M,CAAA,EAAN,IA+rBA,OA7rB6C,eAA/C,kBsBxKI,GtByKiD,MsBzKjD,GtB0KI,WAAY,MsB1KhB,GtB0KF,IAF2D,GAA7D,KRsKyE,cArGhB,CAqG/B,EAAa,KAAlC,GAAoE,QQugBnC,OACtC,qBAkBE,GAlBF,sBAkBE,IR/nBuD,CQ+nBvD,ERpoB0D,aQknB5D,IJhrBE,OAAO,eAGT,OA3JgC,KAArB,KAAa,CA4JR,KACH,SAAN,kBJ8DkD,CAqG/B,EAAa,KAAlC,GAAoE,QA1Gb,cA0Ga,IArGhB,CAqGgB,EA1Gb,iBI9D1D,OAAO,eAGT,OA3JgC,KAArB,KAAa,CA4JR,KACH,SAAN,0BJ8DkD,CAqG/B,EAAa,KAAlC,GAAoE,QQwgBzE,gDAxrBqB,KAAnB,EAAmB,EAEA,OADrB,YAOQ,MAAN,GAE6C,eAA/C,kBsBxKI,GtByKiD,MsBzKjD,GtB0KI,WAAY,MsB1KhB,GtB0KF,IAF2D,GAA7D,KA6qBsC,UR5mBmB,CQ4mBnB,ER5mBmB,KA6FvD,MA7FuD,QA6FvD,EAGyC,KQmhBb,GAEf,oB,EAAA,KAAuC,CL/QxD,SLnY0B,SAAK,CACV,OAAR,GADa,EAIP,EAHN,IAC4B,CAEtB,yBA7Bb,MACe,YACnB,GACmB,WAHf,EAKW,cKuZjB,W,GAAA,W,EAAA,MACA,SLpY0B,SAAK,CACV,OAAR,GADa,EAIP,EAHN,IAC4B,CAEtB,yBA7Bb,MACe,YACnB,GACmB,WAHf,EAKW,cKwZjB,W,GAAA,W,EAAA,M,EAEwB,KAAxB,E,CAAwB,GAuB1B,QAtBgC,mBAApB,WACmB,cAApB,OHhXqD,qDGmXhC,MHnXgC,IGmXhC,EHnXgC,MGmXhC,MAEU,GHrXsB,KGmXhC,EAEU,MAFV,MAEU,GHrXsB,mBGoX1B,G,CAAA,GHpX0B,OGoX1B,GH9SO,MAtEmB,EAsEnB,IAApC,MAAoC,OG+SH,UH/SjC,IAAoC,OGgTF,GAC5B,MHvXiD,EGuXjD,IACT,GAaN,KATI,KAEwB,MAD2B,KAA5B,CACC,mBADD,mBAErB,SLvZsB,SAAK,CACV,OAAR,GADa,EAIP,EAHN,IAC4B,CAEtB,yBA7Bb,MACe,YACnB,GACmB,WAHf,EAKW,cK2ab,W,GAAA,gBACA,SLxZsB,SAAK,CACV,OAAR,GADa,EAIP,EAHN,IAC4B,CAEtB,yBA7Bb,MACe,YACnB,GACmB,WAHf,EAKW,cK4ab,W,GAAA,gBAJF,KAdsB,QAAxB,QK4QiB,uBACjB,QAEI,kBAOA,GAPA,sBAOA,IR/nBuD,CQ+nBvD,ERpoB0D,aQ6nB1D,IJ3rBA,OAAO,eAGT,OA3JgC,KAArB,KAAa,CA4JR,KACH,SAAN,QJyDqD,sBIzDrD,IJ8DkD,CI9DlD,EJyDqD,iBI9D1D,OAAO,eAGT,OA3JgC,KAArB,KAAa,CA4JR,KACH,SAAN,QIsrBL,sCAIA,2CR5nBuD,CQ4nBvD,ERjoB0D,aQioB1D,IJ/rBA,OAAO,eAGT,OA3JgC,KAArB,KAAa,CA4JR,KACH,SAAN,QJyDqD,sBIzDrD,IJ8DkD,CI9DlD,EJyDqD,iBI9D1D,OAAO,eAGT,OA3JgC,KAArB,KAAa,CA4JR,KACH,SAAN,QI0rBL,wCAGA,+CR/nBuD,CQ+nBvD,ERpoB0D,aQooB1D,IJlsBA,OAAO,eAGT,OA3JgC,KAArB,KAAa,CA4JR,KACH,SAAN,QJyDqD,sBIzDrD,IJ8DkD,CI9DlD,EJyDqD,iBI9D1D,OAAO,eAGT,OA3JgC,KAArB,KAAa,CA4JR,KACH,SAAN,QI6rBL,sCAVa,EAUb,EA1sBmB,GAAnB,EAAmB,EAEA,YAEP,CAHd,MAOQ,QAAN,QAE4B,GAAiB,eAA/C,kBsBxKI,GtByKiD,MsBzKjD,GtB0KI,WAAY,MsB1KhB,GtB0KF,IAF2D,GAA7D,MAmsBJ,W,KArjB0B,QAAI,OR7E+B,WA6FvD,CQhBwB,IR7E+B,CA6FvD,EQhBwB,CRgBxB,GA7FuD,QA6FvD,E,CAGyC,MQnB6B,GAA9C,IA6B9B,EAzB4C,MC+JnC,aAAkC,KAAM,OA2B/B,MAAmB,OAAR,CAAX,EACiB,QA/Cd,ODpInB,ECoImB,EDpInB,YACQ,SAAW,QCiasB,ODhaC,ECqJD,KAAM,KDpJD,KAFxC,ECsKwB,UAGf,K,CAAA,EAAqB,QAAiC,KADjC,IASpB,MAAmB,OAAR,GAAX,EACiB,YAhCc,KDzN5B,YAwBR,aACkB,QAAf,KAAU,IAAqB,eAOpB,GCqbhB,KAA4B,EACA,OAAhB,CAAsB,SAED,QAAhB,CAA2B,UN6R9C,cAAI,YAEC,S,CAAoB,aACpB,KADoB,YAFrB,cAEC,S,CAAoB,aACpB,KADoB,IA37BxB,OATE,WAAO,CAAP,EASK,KAAU,EARV,iBAQA,KAAU,GACvB,SKkRQ,IAQZ,MAjB4E,CAAN,KAApE,SAiBF,G,KM6oBE,W,CAAA,mDAjEa,KAAM,WACnB,MACQ,eACkB,SACA,YACL,KACA,YACE,YACA,YACF,YACA,gBACZ,YAAc,CAAL,KACA,WAXwB,CAAnB,KAAvB,IAaa,KAAuB,OAAZ,KAmDxB,sCAjEa,KAAM,OACnB,YACQ,eACkB,SACA,YACL,KACA,YACE,YACA,YACF,YACA,gBACZ,YAAc,CAAL,KACA,WAXwB,CAAnB,KAAvB,IAaa,KAAuB,OAAZ,UAmDxB,MAlDwB,KAmDpB,GAtBM,OAAN,EAAM,EAAN,MACS,oBACb,MACa,SAHH,EAKE,ShBhvBmB,OAPL,SAAiB,CAvClB,OAAR,CAuCS,EAvCT,OACX,MACe,YACnB,GACmB,WAHf,EAKW,cAyCP,eAAK,SAIC,OAAW,CAHzB,6BAQE,KAaO,cgB8uBb,C,EA04EA,YACa,eAAgB,CAAhB,EAAgB,MA96F3B,GAq9FO,OAvCoB,iBAl6FjB,SAAwB,gBACT,kBACU,SAAK,OADe,CAA9B,KAAvB,IAYa,SAAT,CAAS,EAAT,MAs5FmB,GAKI,GAt5F7B,OhBnRqB,KAAR,EAAQ,EAAR,CAAQ,EAGF,EAHN,IAC4B,OAFV,CAIZ,uBA7Bb,MACe,YACnB,GACmB,WAHf,EAKW,cgBwSjB,U,EAAA,4BAi5FyB,aAKI,QACI,QAG3B,qBAME,GACU,EAAZ,KAAY,GADV,EAOwB,aACY,KAAf,SACM,GACX,eACE,KAEX,OA18FR,MA48FD,UA97FA,SAC6B,YA+5FR,CAAF,YA96FlB,KAq9FT,U,IKp4GqB,cAEnB,G,OA2KmB,IX+sDrB,SHxjDU,KGyjDS,QHzjDT,qFAyHgB,QAAF,OACtB,sCAC2B,cAnUP,GAXP,OAWgB,GAA+B,EACb,OAAlB,GAD+B,EAGzB,OAGD,OAFH,uBAMQ,GAS3B,KAAM,GACuB,KAAR,EAAQ,EAAR,CAAQ,EACqB,OAAR,GAArB,CAFf,OAvFN,OAEM,cAmGmB,KAIF,SAzGvB,GAuGe,kBArGT,QGq0DlB,6BV7tDqB,gBAEJ,eAFI,cU+tDH,yCAAZ,CACQ,E,ECv/ChB,IACgB,YAEd,yCX5OqB,U,EAAA,EAEJ,UANQ,OAAR,CAAQ,EACb,OAAN,EAAM,EAAN,KACe,QACnB,MACmB,SAHT,EAGS,IAEJ,WANQ,OAAR,CAAQ,EACb,OAAN,EAAM,EAAN,KACe,QACnB,MACmB,SAHT,EAGS,IAEJ,WANQ,OAAR,CAAQ,EACb,OAAN,EAAM,EAAN,KACe,QACnB,MACmB,SAHT,EAGS,IAEJ,WWmPE,OAhSK,OAAN,EAAM,EAAN,MACd,oBADc,MAEd,SAFoB,EAEpB,EACI,oBA0BW,OA1BX,MA0BW,SACA,YAmQH,OAChB,IDy+Cc,IAEQ,QADA,IADV,aAEU,qBAGC,QAGP,QAFD,QACS,QAIN,QADa,SACb,UAIoB,QAHhB,SACL,8BA7sCU,GAGV,QAAK,oBACS,QAA3B,OAAN,CAAsC,iBACrB,iBA4sCf,OWxuDmB,QACE,GAEF,GADA,OAErB,C,CAEA,YACoB,OAAO,YAAP,GAClB,cX6xDqB,MW5xDvB,Q,CA1BA,KACoC,CAAlC,IACF,C,GAgCA,kBACkB,oBAMZ,MACF,sBACmB,EA3HwB,SApEjC,CAoEM,GACyB,SArE/B,CAqEI,GACiD,SAtErD,CAsEc,GACmC,SAvEjD,CAuEY,GAHqB,SApEjC,CAoEM,GACyB,SArE/B,CAqEI,GACiD,SAtErD,CAsEc,GACmC,SAvEjD,CAuEY,OAuHiB,OAAvC,UADE,IACF,SACmB,EA3HwB,SApEjC,CAoEM,GACyB,SArE/B,CAqEI,GACiD,SAtErD,CAsEc,GACmC,SAvEjD,CAuEY,IA0HtB,SACA,KACF,SACE,IAKK,mCXo9DT,SWp9DS,E,EXq9De,GACI,MADJ,U,EAEL,Q,EAAA,M,QAxInB,UAEa,EAsIM,EAtIN,MAAS,WHrrDN,wBAnTF,OAEM,iBA+DlB,EA/DkB,EA+DlB,iBAC6B,EAET,KAAS,KAA+B,EACb,OAAlB,GAD+B,EAGzB,OAGD,OAFH,WAMQ,SASrB,OAtBoC,CAA/B,KAAvB,IAoCqC,aACH,MAEA,UACC,UAzGvB,GAuGe,kBArGT,YG++DoB,QADtC,sBAGsB,IACZ,Q,GAAA,EI5/DV,SASiB,wBJo/DG,IAA+B,kBIn/DzB,OACE,EAAb,cACI,eJi/DC,IIn/DN,EAEK,GAFL,KAEK,CJi/DC,IACpB,aACoB,mBA5LZ,gBAAmB,EACnB,MAAyB,EACV,MCp7ChB,GAAkC,KAAM,ODo7Cd,CAAK,ECr5CtB,MAAmB,OAAR,GAAX,EACiB,UDq5CiB,KA4L9C,GACF,W,CAAA,+CAj6DE,GAi6DF,4BAv6DqB,YAu6DrB,CAx6DA,OAOQ,MAAN,IAE6C,eAA/C,kBsBxKI,GtByKiD,MsBzKjD,GtB0KI,WAAY,MsB1KhB,GtB0KF,IAF2D,GAA7D,KAg6DU,MAAN,MAhuDI,aAA6C,QAQT,UACT,OAAF,SA0tDvB,QAEN,ILpiDQ,U,CAAA,EO3fL,EP4fT,KO5fS,MP8fT,OKmiD+B,WAEf,KAA2B,KACzB,KAA6B,KAF3C,IAKA,WGvkEwB,QAD5B,IAgEA,QbgIqB,M,CAAA,EA1Bf,WACe,QACnB,MACmB,SAHf,EAGe,IAEJ,Ya3GjB,W,EAAA,6BApByB,6BAAD,OXiPP,CAAV,EAAoC,KWhPC,eAC1C,EAD0C,IbkJb,CACV,QAAR,GanJ+B,EbmJ/B,EAGM,EAHN,IAC4B,CAEtB,uBA5BE,UAIJ,gBa7Hf,mB,GAAA,8CA2BE,OAxEwB,QAD5B,KHykEI,a,CAAA,e,EAAA,U,EAAA,U,EAAA,gBAh7DA,GAg7DA,I,EAAA,U,EAAA,U,EAAA,QAt7DmB,YAs7DnB,CAv7DF,OAOQ,MAAN,IAE6C,eAA/C,oBA+6DE,sBL7mCJ,4B2B1+BM,EtBulEF,MsBvlEE,GtBulEF,GsBvlEE,GtByKiD,MsBzKjD,GtB0KI,WAAY,MsB1KhB,GtB0KF,IAF2D,GAA7D,KA86DE,KACA,IAC0D,MAA1D,eACmB,UACjB,O,CAAA,iDA57DiB,KAAnB,EAAmB,EAEA,OADrB,YAOQ,KAAN,GAE6C,eAA/C,kBsBxKI,GtByKiD,KsBzKjD,GtB0KI,WAAY,KsB1KhB,GtB0KF,IAF2D,GAA7D,SAg7DmE,CAAP,QAAnC,CAAvB,MAXE,IG/jEsB,QAD5B,IHilEI,S,CAAA,+CAx7DA,GAw7DA,4BA97DmB,YA87DnB,CA/7DF,OAOQ,MAAN,IAE6C,eAA/C,mBsBxKI,GtByKiD,MsBzKjD,GtB0KI,WAAY,MsB1KhB,GtB0KF,IAF2D,GAA7D,KAg6DI,gBA8B2C,UChqD9B,O,CDgqD8B,EChqD9B,QD8pDjB,OAMwC,GCt4CnC,yBAAkC,ODu4CrC,EACE,S,CAAA,YCvpDC,KAAkC,GAIM,OAJA,OAf5B,ODsqDb,iDA98DiB,KAAnB,EAAmB,EAEA,OADrB,YAOQ,MAAN,GAE6C,eAA/C,kBsBxKI,GtByKiD,MsBzKjD,GtB0KI,WAAY,MsB1KhB,GtB0KF,IAF2D,GAA7D,K,IAk3CJ,UAl3CI,EC6SK,KD7SL,EAm3CqC,ICtkChC,IAQkC,cARA,KAIM,OAJA,WD2kCvC,MACG,cAGP,EA53CF,IA68DS,CAjlBP,EGlhDe,QAAZ,uCACS,WAAZ,OAA2C,GHmuB/C,0BG7tB+C,YXuPjC,CAAV,EWvP2C,EX2Me,QA6C3C,MD5PO,GC2PtB,KA5C0D,IAyD3C,KATA,KD/PO,GC+MoC,MW3Mf,EHquB7B,OACd,K,CAAA,sCR/eU,CQ+eV,ER3hB0D,aQ2hB1D,IJzlBA,OAAO,eAGT,OA3JgC,KAArB,KAAa,CA4JR,KACH,SAAN,QIolBL,6BAjmBmB,KAAnB,EAAmB,EAEA,OADrB,QAOQ,MAAN,GAE6C,eAA/C,kBsBxKI,GtByKiD,MsBzKjD,GtB0KI,WAAY,MsB1KhB,GtB0KF,IAF2D,GAA7D,KAslBgB,iBAKA,aACd,K,CAAA,kCRhiB0D,iBQgiB1D,IJ9lBA,OAAO,eAGT,OA3JgC,KAArB,KAAa,CA4JR,KACH,SAAN,QIylBL,6BAtmBmB,KAAnB,EAAmB,EAEA,OADrB,YAOQ,MAAN,GAE6C,eAA/C,kBsBxKI,GtByKiD,MsBzKjD,GtB0KI,WAAY,MsB1KhB,GtB0KF,IAF2D,GAA7D,KA2lBgB,QL8OX,QAAI,YAEC,S,CAAoB,SACpB,KADoB,IA37BxB,OATE,MAk8BC,EAEqB,EAFrB,WAEqB,EAApB,S,CAAoB,EAApB,CAAoB,EACpB,OADoB,EAFrB,EAl8BD,OAAO,CAAP,EASK,KAAU,EARV,iBAQA,KAAU,GACvB,SKktBI,IACF,K,CAAA,kCRxiB0D,iBQwiB1D,IJtmBA,OAAO,eAGT,OA3JgC,KAArB,KAAa,CA4JR,KACH,SAAN,QIimBL,6BA9mBmB,KAAnB,EAAmB,EAEA,OADrB,YAOQ,MAAN,GAE6C,eAA/C,kBsBxKI,GtByKiD,MsBzKjD,GtB0KI,WAAY,MsB1KhB,GtB0KF,IAF2D,GAA7D,KRgE6D,qBQ0iBzD,GR1iByD,EQ0iBzD,IAIO,KAJP,IR1iByD,UQ0iBzD,ER1iByD,CAJD,SA8I/B,CQkalB,EAFP,EAEO,WR3iB8C,CQ6iB9C,GAFA,EAEA,kBR7iB8C,CQ6iB9C,ORxagD,CQ0ahD,GAFA,EAEA,OAjDL,cXzsByB,GAAjC,YAEsB,EAFtB,MACmB,EACN,KAAS,CAFtB,EAAiC,EAEX,IAF0B,CAAf,GAAjC,MAGe,KWyvBF,KX1vBS,EW0vBT,KRljBkD,EQujB3D,K,CAAA,kCR3jB0D,iBQ2jB1D,IJznBA,OAAO,eAGT,OA3JgC,KAArB,KAAa,CA4JR,KACH,SAAN,QIonBL,qCAjoBmB,KAAnB,EAAmB,EAEA,OADrB,YAOQ,MAAN,GAE6C,eAA/C,kBsBxKI,GtByKiD,MsBzKjD,GtB0KI,WAAY,MsB1KhB,GtB0KF,IAF2D,GAA7D,KA8kBe,gBJpqBiC,EIoqBjC,QRteH,CQseG,ERlfb,KAA4B,aAClB,KAAY,WI7LS,OAEb,QADC,IADY,EAInC,OI6tBgC,MNjuBb,KAAT,EEIV,EFJU,CEIV,EFFgC,KADP,KAA4B,OAAlC,OACO,EACD,O,CADO,EACP,IACvB,OAD6B,aAGG,GAAN,KACxB,EADwB,EACxB,cACM,OAAU,SAAJ,OAD4B,CAAjB,KAAvB,SADwB,EACxB,QAHqC,CAAhB,KAAvB,MASa,KAA0B,KAAR,KAAxB,aAAP,WENyC,aADjB,GACW,EACC,KAAf,IACc,OAAf,QAC4B,MIwtB3C,uCAAD,I,CAAA,EACF,E,CAAA,sCR3hBU,CQ2hBV,ERvkB0D,aQukB1D,IJroBA,OAAO,eAGT,OA3JgC,KAArB,KAAa,CA4JR,KACH,SAAN,4BALE,eAGT,OA3JgC,KAArB,KAAa,CA4JR,KACH,SAAN,QIgoBL,qCA7oBmB,KAAnB,EAAmB,EAEA,OADrB,QAOQ,MAAN,GAE6C,eAA/C,kBsBxKI,GtByKiD,MsBzKjD,GtB0KI,WAAY,MsB1KhB,GtB0KF,IAF2D,GAA7D,KA4oBA,I,CAAA,sCRpiBY,CQoiBZ,ERhlB4D,aQglB5D,IJ9oBE,OAAO,eAGT,OA3JgC,KAArB,KAAa,CA4JR,KACH,SAAN,QIyoBP,6BAtpBqB,KAAnB,EAAmB,EAEA,OADrB,QAOQ,MAAN,GAE6C,eAA/C,kBsBxKI,GtByKiD,MsBzKjD,GtB0KI,WAAY,MsB1KhB,GtB0KF,IAF2D,GAA7D,aRwGY,GUlOL,EP4fT,KO5fS,MP8fT,MKggCI,GGn/CqB,2BAAD,OXiPP,GAA0B,sBW/OzC,EX+OyC,IF9FZ,CACV,QAAR,GE6F8B,EF7F9B,EAGM,EAHN,IAC4B,CAEtB,uBA5BE,UAIJ,gBa7Hf,mB,GAAA,8CAFuB,yBAAD,OXiPP,MWlOjB,OAfyB,2BAAD,OXiPP,GAA0B,wBF9FZ,CACV,QAAR,GE6F8B,EF7F9B,EAGM,EAHN,IAC4B,CAEtB,uBA5BE,UAIJ,gBa7Hf,0EHsuBI,IACA,OAC8B,MC9U7B,MAAkC,GAAM,KD+U3C,GA/BoB,OG5sBC,yBAAD,OXiPP,GAA0B,wBF9FZ,CACV,QAAR,GE6F8B,EF7F9B,EAGM,EAHN,IAC4B,CAEtB,uBA5BE,UAIJ,gBa7Hf,uEH0sBkC,QGnvBjB,WHouBF,aA+yBH,KAj2BC,iBAAc,QAAW,GAAY,YL6S7C,QAAI,YAEC,S,CAAoB,SACpB,KADoB,cAFrB,cAEC,S,CAAoB,SACpB,KADoB,IA37BxB,OATE,WAAO,CAAP,EAAO,IASF,KAAU,EARV,qBAQA,KAAU,GACvB,SK2oBkD,UAGpB,QJrnBkB,EIqnBlB,QRne8B,CQme9B,ERne8B,0BI5J3B,OAEb,QADC,IADY,EAInC,OFJmB,KAAT,EEIV,EFJU,CEIV,EFFgC,KADP,KAA4B,OAAlC,OACO,EACD,O,CADO,EACP,IACvB,OAD6B,aAGG,GAAN,KACxB,EADwB,EACxB,cACM,OAAU,SAAJ,OAD4B,CAAjB,KAAvB,SADwB,EACxB,QAHqC,CAAhB,KAAvB,MASa,KAA0B,KAAR,KAAxB,aAAP,WENyC,aADjB,GACW,EACC,KAAf,IACc,OAAf,QAC4B,MIsnB5C,gCL/JQ,U,CAAA,EO3fL,EP4fT,KO5fS,MP8fT,MK8JkB,uBANkC,2EA+2BnC,+DJj+CiC,EIi+CjC,cAGX,CAHW,EAzjC2C,eJhalD,WAAY,cIiaC,CADqC,EAE1D,W,CAAA,6EA5VqB,OADrB,OAOQ,MAAN,MAsVF,6DApV+C,eAA/C,mBsBxKI,GtByKiD,MsBzKjD,GtB0KI,WAAY,MsB1KhB,GtB0KF,IAF2D,GAA7D,KAmVqB,OAK+B,MCvC/C,MAIkC,OAJA,KAAM,gBJlFF,OAA1B,CAA0B,EAA1B,QAzUK,OADA,IA4EC,8BAIzB,EAJyB,EAIzB,UAC6B,EAET,KAAS,KAA+B,EACb,OAAlB,GAD+B,EAGzB,EAHyB,IAGzB,GAGD,OAFH,eAMQ,OAS3B,K,CAAA,EAAM,SACuB,OAAR,GAAoB,E,CAAA,IACS,OAAR,GAArB,CAFf,E,CAAA,OAtBoC,CAA/B,KAAvB,IAoCqC,aACH,MAEA,YACC,IAFR,aA1CF,EA0CE,IAvGf,OAEM,qFG+fhB,qBA5DsC,cA4DtC,EA5DsC,IAGN,OAC9B,I,CAAA,yDAvXmB,KAAnB,EAAmB,EAEA,OADrB,YAOQ,MAAN,GAE6C,eAA/C,kBsBxKI,GtByKiD,MsBzKjD,GtB0KI,WAAY,MsB1KhB,GtB0KF,IAF2D,GAA7D,KAmXE,QA3GM,MA2GN,I,CAAA,QA5HA,GLhXa,EAAP,SAAO,GAAP,CACK,MK+XP,QAAN,OA4BQ,MAJA,QNrQsB,KAAe,KAAqB,GAA7B,CMwQ9B,UAoFK,MAAN,EHhIJ,mBAxVS,OAAsC,OAAT,CAmMtC,EAQuC,K,EAChB,cAAiC,KAA3B,CADU,MAKZ,YACA,IAFA,a,IAOE,Q,IAAA,MAyIJ,M,EAAmC,KAA7B,CAA6B,E,IAC3B,M,IAAA,OAGwB,KAHxB,IAStB,OAAU,GAIM,YG8GvB,OAhJE,MADgB,QAAN,QLxVL,EAy7BJ,EKhdH,ELgdG,WAEqB,EAApB,S,CAAoB,EAApB,CAAoB,EACpB,OADoB,EAFrB,EAz7BH,GAAO,CAAP,EAAiB,WATR,CASQ,EARV,M,GASb,WAA6D,G,EK0fxB,GAAM,GAA0B,MAGvC,MAA2B,SAA4B,OAA7D,KACW,YAEd,GAA4C,QCyE3C,MACM,KACpB,MAAW,GAET,QAAW,GACc,KAC7B,WTxXM,CAAV,ESwXI,ETxXM,KAAV,mBAAU,ID3PY,CEZhB,GDoRS,KATA,KD/PO,EUonBgB,EAG5B,MAAmB,KAAR,CAAiC,ETnaC,WA6FvD,MA7FuD,QA6FvD,EAGyC,KSmUa,GAG5B,KAV9B,QD7EgD,KACmC,GACzE,K,CAAA,gCJpZC,eAGT,OA3JgC,KAArB,KAAa,CA4JR,KACH,SAAN,QI+YC,6BA5Za,KAAnB,EAAmB,EAEA,OADrB,YAOQ,MAAN,GAE6C,eAA/C,kBsBxKI,GtByKiD,MsBzKjD,GtB0KI,WAAY,MsB1KhB,GtB0KF,IAF2D,GAA7D,K,EH+N2C,KAA1B,CAA0B,EAA1B,QAzUK,OADA,IA4EC,OA8PZ,YA9PY,iCAKI,EAET,KAAS,OACkB,OAAlB,KAEM,OAGD,OAFH,eAMQ,OAS3B,K,CAAA,MAAM,KACuB,OAAR,GAAoB,E,CAAA,IACS,OAAR,GAArB,CAFf,E,CAAA,OAtBoC,CAA/B,KAAvB,IAoCqC,aACH,MAEA,YACC,IAFR,aA1CF,EA0CE,IAvGf,OAEM,mBG4fY,OAG5B,M,IAAA,8DA/aqB,KAAnB,EAAmB,EAEA,OADrB,YAOQ,MAAN,GAE6C,eAA/C,kBsBxKI,GtByKiD,MsBzKjD,GtB0KI,WAAY,MsB1KhB,GtB0KF,IAF2D,GAA7D,KA2aA,YA1PO,CAAM,MAAN,QHqEL,mBAxVS,OAAsC,OAAT,Q,EA4Mf,cAAiC,KAA3B,OAIF,YACA,IAFA,a,IAOE,Q,IAAA,MAyIJ,M,EAAmC,KAA7B,CAA6B,E,IAC3B,M,IAAA,OAGwB,KAMpC,EATY,IAStB,OAAU,GAIM,YGmKzB,M,CAAA,MAEA,C,CAFA,EH/Ma,OGmNiC,+BHnNjC,YAzUK,OADA,IA4EC,8BAIzB,EAJyB,EAIzB,UAC6B,EAET,KAAS,KAA+B,EACb,OAAlB,GAD+B,EAGzB,EAHyB,IAGzB,GAGD,OAFH,eAMQ,OAS3B,K,CAAA,EAAM,SACuB,OAAR,GAAoB,E,CAAA,IACS,OAAR,GAArB,CAFf,E,CAAA,OAtBoC,CAA/B,KAAvB,IAoCqC,aACH,MAEA,YACC,IAFR,aA1CF,EA0CE,IAvGf,OAEM,kBA2TlB,KGsNM,EACF,S,CAAA,e,EAAA,wB,EAAA,S,EAAA,OA1bA,GA0bA,I,EAAA,wB,EAAA,S,EAAA,OAhcmB,OADrB,OAOQ,MAAN,QAE6C,eAA/C,kBsBxKI,GtByKiD,MsBzKjD,GtB0KI,WAAY,MsB1KhB,GtB0KF,IAF2D,GAA7D,KA8aI,QA6BF,G,CAAA,GAZ+B,OAHU,OAFN,4BAKE,OACjC,kBAC6B,OAUjC,OAPA,QAG+B,kCACnC,IAvDmF,EA0D/E,ETvlBiB,OSyiBiB,UAQpC,EAqDmC,OTtmBhB,qBAAN,OAAM,EAAN,MAAF,cACG,EEbN,GFYG,EEZH,MFaM,KEbN,IFaM,IEbN,OFaM,EEbN,MFaM,MADK,gBAAN,OAAM,EAAN,MAAF,MEZH,OFaM,EEbN,MFaM,CADH,EEZH,OFYG,EEZH,YFaM,SSwmBgC,oBAGF,SAAjC,WACX,GPznBQ,OFaM,EEbN,MFaM,CS4mBd,EPznBQ,OOynBR,EPznBQ,YFaM,iBEbN,GFaM,EEbN,MFaM,KEbN,IFaM,IEbN,OFaM,EEbN,MFaM,IADD,OACC,EADD,yBS0lBiC,OLlf3B,QAAK,EAAL,EAAK,MACjB,mBAA6B,GAApC,MAEO,SAHY,EA8DO,oCAEb,gBACH,gBAHgB,kEAAlB,wI,EAAA,Y,EAAA,S,EAAA,kBAuDW,aADD,IKwYpB,YLxYoB,IKwYpB,QAS6D,e,EHlQhB,KAA1B,CAA0B,EAA1B,QA1UK,QACA,GA2EC,OA8PZ,OA9PY,mBAIzB,EAJyB,EAIzB,UAC6B,EAET,KAAS,KAA+B,EACb,OAAlB,GAD+B,EAGzB,OAGD,OAFH,eAMQ,OAS3B,K,CAAA,EAAM,SACuB,OAAR,GAAoB,E,CAAA,IACS,OAAR,GAArB,CAFf,E,CAAA,OAtBoC,CAA/B,KAAvB,IAoCqC,aACH,MAEA,YACC,IAFR,aA1CF,EA0CE,IAvGf,OAEM,mBG8jBd,QA3SW,MAAN,M,CA2SL,EA0BM,QArBO,GAqBP,YApB2B,KAAM,GAAY,EAEuB,ON5kB3D,SAAT,EAAS,EAAT,CAAS,EAEa,KADP,KAA4B,OAAlC,OACO,EACD,KACvB,SAD6B,aAGG,GAAN,KACxB,EADwB,EACxB,cACM,OAAU,SAAJ,OAD4B,CAAjB,KAAvB,SADwB,EACxB,IAHqC,CAAhB,KAAvB,MASa,KAA0B,KAAR,KAAxB,gBM+jBoF,OJpiB7D,GAtBtB,OAAY,QAQb,WAWgD,iCAGzB,EAHyB,MAGjD,KAAwB,GAHyB,EAGzB,OACA,mBI2iBrB,kD,EAAA,K,MLvfb,0BKufa,OLvfb,MC1Ca,OAKI,SAAN,gBDuCW,UAGX,CAAa,WAKlB,E,EAAA,Y,EAAA,W,EAAA,Y,EAAA,Y,EAAA,M,EAAA,U,EACgB,M,EAAA,M,EAAA,M,EAAA,M,EAAA,M,EAAA,e,EAAA,mCAAlB,YA5CmB,OAAK,EAAL,EAAK,MACjB,iBAA6B,GAApC,MAEO,SAHY,EAGZ,IA2DmB,GAEb,E,EAAA,S,EAAA,OACH,E,EAAA,O,EAAA,MAHgB,qBAGhB,OAHgB,qGAAlB,Y,EAAA,kB,EAAA,wF,EAAA,W,EAAA,Q,EAAA,gB,EAAA,EAsBS,I,EAAA,OAErB,QKkca,UAaL,IAbK,gBAaL,SLnpBO,WKspBU,OLrpBZ,CKqpBY,ELppBH,YAAF,qBKwpBoC,yBAPhD,KAOgD,QR/ZnC,GQwZb,KAOgD,EAnGpD,EAuGF,K,CAAA,sCRhd8D,CQgd9D,ERhd8D,aQgd9D,IJ9gBW,sBAGT,GAEa,SAAN,QIygBT,+RRpac,CQoad,ET/pB0B,MCwQP,KATA,KD/PO,ES+pB1B,wBAthBuB,KAAnB,EAAmB,EAEA,OADrB,YAOQ,MAAN,GAE6C,eAA/C,mBsBxKI,GtByKiD,MsBzKjD,GtB0KI,WAAY,MsB1KhB,GtB0KF,IAF2D,GAA7D,KAsXM,KA0hCQ,gBACF,QJv+CoC,EIu+CpC,a,CAAA,EE3gDL,EP4fT,KO5fS,MP8fT,S,CAAA,EO9fS,EP4fT,KO5fS,MP8fT,OK6KiB,OAAK,sBACS,OAAK,sBAElB,QADH,gBAEc,gBAg2BO,QRz1C0B,oCI5J3B,GJ4J2B,WI5J3B,OAEb,QADC,IADY,EAInC,UIw/CoC,UN5/CjB,KAAT,EM4/C0B,EN5/C1B,CM4/C0B,EN1/CJ,KADP,KAA4B,OAAlC,OACO,EACD,KACvB,E,CAF8B,EAE9B,WAD6B,aAGG,GAAN,KACxB,EADwB,EACxB,cACM,OAAU,OAAJ,OAD4B,CAAjB,KAAvB,SADwB,EACxB,QAHqC,CAAhB,KAAvB,MASa,KAA0B,KAAR,KAAxB,OAAP,WENyC,aADjB,GACW,EACC,KAAf,IACc,OAAf,QAC4B,IFV/B,SAAT,EAAS,EAAT,CAAS,EAEa,KADP,KAA4B,OAAlC,OACO,EACD,O,CADO,EACP,IACvB,OAD6B,aAGG,GAAN,KACxB,EADwB,EACxB,cACM,OAAU,SAAJ,OAD4B,CAAjB,KAAvB,SADwB,EACxB,QAHqC,CAAhB,KAAvB,MASa,KAA0B,KAAR,KAAxB,aAAP,WENyC,aADjB,GACW,EACC,KAAf,IACc,OAAf,QAC4B,OIg7CV,QACF,QAAR,MANR,WAMQ,EANR,KACI,QAQG,IAGlB,QAAkB,EAAlB,EEn+CJ,KFm+C+D,GAChE,QIl7CE,CJk7CF,EAAR,KAAuC,IIt8CrC,SJs8CwC,cI96CxB,KACA,KJ66CmE,EAArF,WAAqF,IAC1D,MAAkB,KAAG,OALjB,IAQC,MAAd,GACZ,sCAsEF,8CACyB,EA8BjB,OA9BiB,0BAEvB,aAEqB,CAAb,aAEa,CAFb,EAIF,I,CAAA,yCAx7CN,GAw7CM,0BA97Ca,OADrB,WAOQ,MAAN,IAE6C,eAA/C,sBsBxKI,GtByKiD,MsBzKjD,GtB0KI,WAAY,MsB1KhB,GtB0KF,IAF2D,GAA7D,KAy7CQ,E,CAAA,wCAn8Ca,KAAnB,EAAmB,EAEA,OADrB,QAOQ,MAAN,GAE6C,eAA/C,mBsBxKI,GtByKiD,MsBzKjD,GtB0KI,WAAY,MsB1KhB,GtB0KF,IAF2D,GAA7D,mBAy8CM,K,CAAA,gCJ38CG,eAGT,OIw8CM,MJnmD0B,KAArB,KAAa,CA4JR,KACH,SAAN,QIs8CD,kCAn9Ce,KAAnB,EAAmB,EAEA,OADrB,YAOQ,MAAN,GAE6C,eAA/C,kBsBxKI,GtByKiD,MsBzKjD,GtB0KI,WAAY,MsB1KhB,GtB0KF,IAF2D,GAA7D,KAu9CM,S,CAAA,e,EAAA,S,EAAA,OAz9CJ,GAy9CI,I,EAAA,S,EAAA,OA/9Ce,OADrB,OAOQ,MAAN,IAE6C,eAA/C,kBsBxKI,GtByKiD,MsBzKjD,GtB0KI,WAAY,MsB1KhB,GtB0KF,IAF2D,GAA7D,eRkIe,CAAV,EAAoC,KQ21CG,GACpC,eAAqE,CAArE,GAGF,wBACI,UAAwC,CAA7B,KAVf,2BAkDJ,qBAhEqC,gBAMX,SAnCwB,CAA7B,YA8DI,CA9DJ,EA+DW,MAAhC,MACA,0CAQe,UAAX,GAPyB,MCjsC1B,MAAkC,GAAM,cD4sCjC,YR75CA,CQ65CA,ER75CA,KAAkB,aAClB,KAAY,WI7LS,OAEb,QADC,IADY,EAInC,OIimDM,IACY,QACZ,qBAEkB,MCx9BxB,OAAkC,IAAO,ODy9BrC,aRx8C0D,GQw8C1D,ERx8C0D,UQ+8CzB,MACqC,GRh9CZ,UQ+8CzB,OR/8CyB,QQ+8CzB,GRr9CyB,KQs9CpB,QAAU,KAAnB,GAAyC,KAAhC,MAAU,YRt9CU,CQs9C7B,CAAS,EAAgC,YRt9CZ,QI1IpD,SAAY,QAQb,MAUyB,KACuB,MAEvD,2BAC8B,EAD9B,MACM,KAAwB,GAD9B,EAC8B,IImlDC,GJllDD,yBAzCG,CAyCH,EAzCG,oBI2nDF,GN3nDd,SAAT,EAAS,EAAT,CAAS,EAEa,KADP,KAA4B,OAAlC,OACO,EACD,KACvB,E,CAF8B,EAE9B,WAD6B,aAGG,GAAN,KACxB,EADwB,EACxB,cACM,OAAU,SAAJ,OAD4B,CAAjB,KAAvB,SADwB,EACxB,QAHqC,CAAhB,KAAvB,MASa,KAA0B,KAAR,KAAxB,aAAP,WENyC,aADjB,GACW,EACC,KAAf,MACc,aACa,KAD5B,QIknDW,E,CAAA,SAC3B,O,CAAA,YRh+CwD,uCI9D1D,OAAO,eAGT,OA3JgC,KAArB,KAAa,CA4JR,KACH,SAAN,4BALE,eAGT,OA3JgC,KAArB,KAAa,CA4JR,KACH,SAAN,QIyhDH,kCAtiDiB,KAAnB,EAAmB,EAEA,OADrB,YAOQ,MAAN,GAE6C,eAA/C,kBsBxKI,GtByKiD,MsBzKjD,GtB0KI,WAAY,MsB1KhB,GtB0KF,IAF2D,GAA7D,uBL+GE,GAAU,gBAAV,OACU,KAAU,GAzB4B,OHZjC,IAAkB,CGab,YAExB,wBACqE,WAAvB,QACpB,cAEJ,EAmSR,Q,CArSY,EOtNjB,EP4fT,KO5fS,MP8fT,MAvSqC,YAAc,CAA1B,E,EAAA,CAAvB,OAGmB,SAAV,GAxOmB,wCACpB,WAAO,GACI,YAC6B,KAAhD,KAAJ,OAAI,OAsOiC,oB,EAAA,S,EAAA,YAIjB,GAalB,iCKi7CsD,YAAU,WJhlDrD,eAGT,GAEa,SAAN,uBDkGM,CClGN,EDqGU,MADC,IACD,MACE,MAJjB,MAEgB,YAEC,GACrB,GACoB,OACD,wBACE,OKk+CH,KLl+CG,IKk+CH,sBASZ,QAC2B,MCjwC1B,MAAkC,GAAM,KDkwC3C,4BAEA,GAQF,O,CAAA,gBR7/C4D,CQ6/C5D,ER7/C4D,iBQ6/C5D,8BJ3jDE,OAAO,eAGT,OA3JgC,KAArB,KAAa,CA4JR,KACH,SAAN,QIsjDP,2BAnkDqB,KAAnB,EAAmB,EAEA,OADrB,QAOQ,MAAN,GAE6C,eAA/C,kBsBxKI,GtByKiD,MsBzKjD,GtB0KI,WAAY,MsB1KhB,GtB0KF,IAF2D,GAA7D,KA0jDqB,MCrgCL,iBAEY,WADjB,GAE0B,OAAM,IAAd,MPxpBZ,SAAT,EAAS,EAAT,CAAS,EAEa,KADP,KAA4B,OAAlC,OACO,EACD,O,CADO,EACP,IACvB,OAD6B,aAGG,GAAN,KACxB,EADwB,EACxB,cACM,OAAU,SAAJ,OAD4B,CAAjB,KAAvB,SADwB,EACxB,QAHqC,CAAhB,KAAvB,MASa,KAA0B,KAAR,KAAxB,aAAP,WENyC,aADjB,GACW,EACC,KAAf,IACc,OAAf,QAC4B,cIsFhD,MRkIe,GAA0B,QQ2zCjC,eAA+D,CAA/D,EAC0C,MRl4CU,4CQk4CvC,8BR5zCN,CQ4zCM,EAttBG,wBRzqB+B,CQ0qB/C,MAA+B,EAMrB,QAApB,gCRrjBO,GAxDoC,OQsmBjB,kBRzqB+B,MQq3ChC,CRr3CgC,WQ0qB/C,CAA+B,mBLznB3B,OAAU,CAAV,EAAU,OAzB4B,OHZjC,IAAkB,CGab,YAExB,wBACqE,WAAvB,IACpB,kBAEJ,EAmSR,Q,CArSY,EOtNjB,EP4fT,KO5fS,MP8fT,MAvSqC,YAAc,CAA1B,E,EAAA,CAAvB,MAGmB,SAAV,GAxOmB,wCACpB,WAAO,GACI,YAC6B,KAAhD,KAAJ,OAAI,OAsOiC,oB,EAAA,S,EAAA,YAIjB,GAalB,gCK6nBoB,QAApB,yBARiD,OAQjD,WAHoB,EAGpB,IR3pBe,CQ2pBf,ER3pBI,IACe,SQ+1CM,CR/1CN,GAEA,oBQ61CM,CR71CN,QQwpBnB,EAHoB,cAGA,QAApB,oBAAqD,OAArD,OR3pBe,CAsGR,YQsjBH,GAEM,cRxjBO,C,CQwjBP,EL1IO,KAAjB,EAAiB,EAAjB,4BACF,KACsB,WHhbH,CAAV,WGibC,GAHS,qBACf,MADF,MM/SkB,OACd,YCpbK,EP4fT,KO5fS,MP8fT,SM3EkB,sBAER,EAAoB,OAA8B,OAAzB,E,EAAA,gB,EACP,K,EAAA,UDsoChB,UAAwC,CAA7B,GA2HzB,UAgZa,GAKL,0CAGa,EADsB,MCnqDlC,UAAkC,KAAM,GDoqD5B,GADsB,EACtB,IAAgB,GAAgB,E,EAAA,K,EAAA,ECz5CV,KDu4CrC,MAkB+C,aArBxC,CClqDQ,ODiqDP,GAHV,eA1XF,E,CAAA,SClgCO,aAAkC,WAAO,CAAzC,EDqgCH,MAEA,GCtwCoB,KAAM,cAEf,CAAqB,E,CAFN,EAGf,KAAqB,EAAiC,KADjC,QAE3B,IAOO,MAAmB,OAAR,GAAX,EACiB,YAyIc,YAnJhC,CAmJgC,EDlVpB,GAy8CC,UChyCmB,ODgyCnB,KAz8CuC,ICkVpB,ED8nC7C,E,CAAA,oCACyB,mBCrxCT,IACM,KAAM,QAEtB,WAAO,CAAqB,E,CAA5B,EAA4B,IACrB,KAAqB,EAAiC,KADjC,QAE3B,IAOO,MAAmB,OAAR,GAAX,EACiB,YAyIc,YDlVpB,wBCyKoB,SDzKoB,CAhDhD,MACN,KAkgDT,kBA3/Cc,K,CAAA,EACL,UAOF,OAQA,OACG,KAAU,MAAqB,MARhB,QAAf,KAAU,IAAqB,CAk/CzC,SCrmCc,IAjZR,KDs/CN,ECrmCN,OAhZkC,OAA1B,IACF,iBAE8B,OAA5B,IACF,iBAEQ,KAAN,EAAM,EXlHF,KAAN,EAAM,EACR,cAGe,OAFA,GWkHC,M,GAAd,SAEuB,KANvB,IA4YN,CAtYI,IX1G6B,QAD/B,SAG4B,IAAK,CADjC,EAFA,EAEF,YAAE,OAEU,qBU+Ge,SCkbN,IAEkB,MAC5B,KAA4B,EACtB,KAAgB,OAAM,KAAhB,CAAsB,EACnB,KAA+B,KAAzB,CAA+B,EACnB,QAAhB,CAA2B,YN6R9C,cAAI,YAEC,S,CAAoB,SACpB,KADoB,YAFrB,cAEC,S,CAAoB,SACpB,KADoB,IA37BxB,OATE,WAAO,CAAP,EASK,KAAU,EARV,iBAQA,KAAU,GACvB,SMsoBE,EAGkC,QAAtC,IACgE,SAAnC,OAA3B,QAAiC,CAAa,GAA9C,gCADiD,CAAnB,OAAM,MAAf,CAAvB,GAGW,KAAM,M,GAAA,IAAM,GAC0B,QAAf,GAElC,SA1B2B,4CACI,U,EAAA,Q,EAAA,Q,EAAA,QAC9B,QAA8B,a,EAAA,S,EAAA,S,EAAA,UAtB6C,OAhZ5C,WAC5B,iBAE8B,WAC9B,iBAEQ,SXlHF,SACR,cAGe,OAFA,GWkHC,M,GAAd,SAEuB,KANvB,IA4YN,CAtYI,IX3GF,SAG4B,IAAK,CADjC,EAFA,EAEA,KAAF,UAAE,OAEU,iBUinDD,OADA,uBC5kCA,OACM,KAAgB,OAAM,KAAhB,GACG,KAA+B,KAAzB,GACY,QAAhB,aN6RnB,0BAEK,S,CAAoB,SACpB,KADoB,YAFrB,cAEC,S,CAAoB,SACpB,KADoB,IA37BxB,OATE,WAAO,CAAP,EASK,KAAU,EARV,iBAQA,KAAU,GACvB,SMsoBE,EAGkC,QAAtC,IACgE,SAAnC,OAA3B,QAAiC,CAAa,GAA9C,+BADiD,CAAnB,OAAM,MAAf,CAAvB,GAGW,KAAM,M,GAAA,IAAM,GAC0B,QAAf,IAElC,yBDojCmC,CAAN,KAA3B,OAlBiE,IAAT,QCpyCvC,KDoyCQ,GAA3B,OA4D2C,CA5D3C,EA4DA,MACE,EADkC,MCh2CjB,SDg2CwB,CAA3C,gBAQwC,IAGP,ICrkC1B,IAAkC,GDqkCR,MCrkC1B,KAAkC,MAAO,CDqkCf,EAAzB,eACwB,GAAS,QAAa,CAAtB,EACxB,K,CAAA,sCArpDe,KAAnB,EAAmB,EAEA,OADrB,YAOQ,MAAN,GAE6C,eAA/C,kBsBxKI,GtByKiD,MsBzKjD,GtB0KI,WAAY,MsB1KhB,GtB0KF,IAF2D,GAA7D,KAipDM,UAGC,OADA,UAP0C,MC50CjC,MACM,KAAM,QAEtB,SAAO,CAAP,EACO,OAAsD,aAC5D,QAsQI,GADU,WAEO,WD4qBiC,MC19B5C,WD+9BnB,GAOA,KANsD,MCh+BnC,KDs+Bc,EANqB,EAMrB,CANqB,EAMrB,mCAAjC,6BACM,WAIiC,MAAlB,UAFjB,4CJ9xC+B,mBFvEH,KADP,KAA4B,OAAlC,OACO,EACD,KACvB,E,CAF8B,EAE9B,WAD6B,aAGG,GAAN,KACxB,EADwB,EACxB,cACM,SAAU,OAAJ,OAD4B,CAAjB,KAAvB,SADwB,EACxB,QAHqC,CAAhB,KAAvB,MASa,KAA0B,KAAR,KAAxB,aAAP,WENyC,aADjB,GACW,EACC,KAsE1B,WACe,CArEuB,CAqEvB,KACP,QADO,mBAED,CAAb,QI8xC6B,oBRnrCtC,CQmrCsC,ERnrCtC,KAA4B,OI5LG,GJ6L1B,UI7L0B,YJ6LrB,GAAY,CI7LS,EJ6LT,UI7LS,IFAzB,WAEsB,KADP,KAA4B,OAAlC,OACO,EACD,KACvB,E,CAF8B,EAE9B,WAD6B,aAGG,GAAN,KACxB,EADwB,EACxB,cACM,OAAU,SAAJ,OAD4B,CAAjB,KAAvB,SADwB,EACxB,QAHqC,CAAhB,KAAvB,MASa,KAA0B,KAAR,KAAxB,aAAP,mBEPwB,GACW,EACC,KFvBR,GAAoB,OAAK,CMk4C7C,EHpjCmC,E,EAAA,KAA1B,CAA0B,EAjUM,OAAtC,WAiUM,WAzUK,OADA,IA4EC,8BAIzB,EAJyB,EAIzB,UAC6B,EAET,KAAS,KAA+B,EACb,OAAlB,GAD+B,EAGzB,EAHyB,IAGzB,GAGD,OAFH,eAMQ,OAS3B,K,CAAA,EAAM,SACuB,OAAR,GAAoB,E,CAAA,IACS,OAAR,GAArB,CAFf,E,CAAA,OAtBoC,CAA/B,KAAvB,IAoCqC,aACH,MAEA,YACC,IAFR,iBA1CF,EA0CE,IAvGf,OAEM,mBARwB,SAmMtC,EAQuC,kBACiB,KAA3B,CADU,MAKZ,YACA,IAFA,0B,IAOE,M,IAAA,MNhQZ,oBM0CqB,EL0M5B,2BD3PY,GCuN6C,YAiDpD,KATA,KD/PO,GCuN6C,MAoCzD,ESqaW,EDmxBoD,MCnxBnD,YAAD,wCACzB,EX1e0B,SAAK,CACV,OAAR,GADa,EACb,EAGM,EAHN,IAC4B,CAEtB,uBA5BE,UAIJ,cW8fjB,W,GAAA,wB,EAAA,S,EAAA,S,EAAA,OACkB,qBACM,GA3mBpB,EA0mBc,EAxmBlB,UACe,MT4JwD,OS5JxD,EAsmBf,KAtmBe,YAsmBf,OAtmBe,GAsmBf,OAtmBe,WAymBL,CAAoB,GAA1B,YC3oBK,EP4fT,KO5fS,MP8fT,MM+ImB,8CADb,GAAQ,yBL/jBH,eAKI,OAAN,qBD0CA,CAAa,OAnBN,CAwBZ,wBACgB,kBADhB,IACgB,wBMrCI,INqCtB,wBA5CmB,QAAK,EAAL,EAAK,MACjB,mBAA6B,GAApC,MAEO,SAHY,E,EAGZ,EA2DmB,I,EAAA,M,EAAA,MAEb,oBACH,oBAHgB,kFAAlB,iJ,EAAA,Y,EAAA,S,EAAA,kBA3DD,GMmjBK,ENxfJ,aA8VM,CA9VN,EA8VN,IACqB,GACzB,GAC8C,eMlC5B,OD88BF,MC98BE,MACyB,OAvXnB,OAAN,EAAM,EAAN,MACd,oBADc,MAEd,SAFoB,EAGhB,0CAMJ,kBAEe,cADA,IAOe,oBACE,QAAjB,MACyB,QAAjB,MACS,QAAjB,UT0EwC,K,EAAA,U,IAgGd,MSvKxB,STkHF,KASA,KCpRT,KDoRS,KATA,KD/PO,GC+PP,OC3QT,GDoRS,YSrHA,a,EAAA,MTiEwC,OA6FvD,CSpKiB,SADf,QV5IoB,OU4IpB,KTgH+D,OShH/D,ITgHiD,MS7HnD,EV/HgB,OAAM,GU8IL,GR1JX,EFYU,KEZV,GFaM,CEbN,OFYU,KEZV,IFaM,KU6IK,GTqJO,I,CAAA,MS9LxB,ET8LqC,KAAlC,EAAkC,EAE3B,M,GShMV,GT2GuD,OS3GvD,CAK2B,CTqG+B,SSrG/B,CAqCV,KT0Kd,KAAoE,kBSpNvE,IA0CiB,UACQ,YA+VlB,OT9PiB,IAFd,aAAV,IAAsC,QAAjB,GAChB,UAAiB,GAAZ,K,CAAA,EAAmC,KAAjB,GACJ,UQ8sChB,KAnC2B,cAAU,IAC7B,CADC,EAA4B,KAA5B,OAuCX,kCJlzCC,sBAGT,OI+yCQ,MJ18CwB,KAArB,KAAa,CA4JR,KACH,SAAN,QI6yCC,QCngCH,MAAkC,GAAM,GDmgCrC,8BA1zCa,KAAnB,EAAmB,EAEA,OADrB,gBAOQ,MAAN,GAE6C,eAA/C,mBsBxKI,GtByKiD,MsBzKjD,GtB0KI,WAAY,MsB1KhB,GtB0KF,IAF2D,GAA7D,UA4zCoB,MCn+BJ,WACyB,OAvXnB,iBACpB,oBADc,MAEd,SAFoB,EAGhB,gCAMJ,UAEe,cADA,MACA,KAMe,oBACE,QAAjB,IACyB,QAAjB,IACS,QAAjB,MAEb,OAOa,eA4VR,OADsC,aDk+B3C,CAAG,KAAH,CAzD2B,KAAjC,GAiE8B,SALc,OAA5C,MC3xBmB,KAGV,QDyxB+B,UC5xBrB,UAGV,eACA,OACA,KAAM,KAAgB,OAAM,KAAhB,GACG,KAA+B,KAAzB,GACf,MAA2B,MAAhB,WN6RnB,0BAEK,S,CAAoB,SACpB,KADoB,cAFrB,cAEC,S,CAAoB,SACpB,KADoB,IA37BxB,OATE,WAAO,CAAP,EASK,KAAU,EARV,iBAQA,KAAU,GACvB,SMsoBE,EAGkC,QAAtC,IACgE,SAAnC,OAA3B,QAAiC,CAAa,GAA9C,+BADiD,CAAnB,OAAM,MAAf,CAAvB,GAGW,KAAM,M,GAAA,IAAM,C,CAAN,EACgC,QAAf,IAElC,WDgyB8D,CAAlB,KAA5C,GAK8B,WCj4BjB,cADmB,gBAIhC,UACA,yBACkB,KACR,QAAN,EAAM,EXpdA,KAAN,EAAM,EACR,cAGe,OAFA,G,EWodD,I,GAAd,S,EAEsB,MAAV,ST5UP,GAA+B,MAAK,GQ0sCL,GACpC,eAEF,sBAEA,mDAuT4E,CAAN,KAApE,UAoBE,GACF,O,CAAA,kEArqDqB,OADrB,OAOQ,MAAN,SAg9Dc,eA98D+B,eAA/C,eA8pDA,6CsBt0DI,GtByKiD,MsBzKjD,GtB0KI,WAAY,MsB1KhB,GtB0KF,IAF2D,GAA7D,KAo+DwB,eRn6DiC,WA6FvD,CQs0DsB,IRn6DiC,CA6FvD,EQs0DsB,CRt0DtB,GA7FuD,QA6FvD,E,CAGyC,MQm0D+B,GAA9C,EACL,MAArB,qBAI2C,oBAEhC,KAAS,WACmB,OAHI,gBA/TpC,QAAP,cACF,WRziDe,CAAV,EAAoC,KQ0iDK,GAAsB,OAAU,CAAhC,EAC5C,YVxoDiB,M,CAAA,EA1Bf,WACe,QACnB,MACmB,SAHf,EAGe,IAEJ,YU6pDb,W,EAAA,qBAI8B,cAAlC,4BA5VsB,WA4VtB,EA5VsB,KACI,QAQG,MAGlB,MAAkB,EAAlB,EEn+CJ,KFm+C+D,GAChE,QIl7CE,CJk7CF,EAAR,KAAuC,IIt8CrC,SJs8CwC,cI96CxB,KACA,KJ66CmE,EAArF,WAAqF,IAC1D,MAAkB,KAAG,OALjB,GAwVJ,uBAAD,SAIb,KAAK,KAAa,OAER,MADA,kBRrjDJ,CQqjDI,E,GRrjDsB,UAA1B,CAA0B,E,GAAA,MQujDmB,KACzC,GAIsB,UAAnC,WLvkDV,SKukDU,ELtkD6B,KAEf,EKokDd,ELpkDc,QAEtB,EKkkDQ,OLlkDR,eACgB,SAAU,CAAI,EAAa,SAAY,CAAzB,QAEoB,EAAzB,YAEV,CAAU,EACV,SAAY,CAAI,EAChB,OAAU,CAAI,EACd,OAAO,CADO,QAI0B,EAAzB,SAEV,CAAU,EACV,OAAY,CAAI,SAChB,OAAU,CAAI,EACd,OAAO,CADO,EAID,eAC/B,eAAgC,SACmC,WACnE,SLlHwB,SAAK,CACV,OAAR,GADa,EAIP,EAHN,IAC4B,CAEtB,yBA7Bb,MACe,YACnB,GACmB,WAHf,EAKW,cKsIf,W,GAAA,mBACO,kBAvBc,CAAvB,EACgB,SAAU,CAAI,EAAa,SAAY,CAAzB,QAEoB,EAAzB,YAEV,CAAU,EACV,SAAY,CAAI,EAChB,OAAU,CAAI,EACd,KAAO,GADO,QAI0B,EAAzB,SAEV,CAAU,EACV,OAAY,CAAI,SAChB,OAAU,CAAI,EACd,KAAO,GADO,EAID,eAC/B,eAAgC,SACmC,OACnE,SLlHwB,SAAK,CACV,OAAR,GADa,EAIP,EAHN,IAC4B,CAEtB,yBA7Bb,MACe,YACnB,GACmB,WAHf,EAKW,cKsIf,W,GAAA,mBACO,kBAvBwB,CAAV,KAAvB,IA0Bc,KAAK,KAAnB,UACS,2BACyC,gBAAzB,GH6DN,KG5DoC,QAAzB,GAC5B,KH2DiB,OG3DjB,UACA,oBACA,iBANY,KAAK,KAAnB,IAQF,OKgiDU,EA7Wc,cAmXO,QAC4B,CApXnC,GA6Wd,EA7Wc,KACI,QAQG,MAGlB,MAAkB,EAAlB,EEn+CJ,KFm+C+D,GAChE,QIl7CE,CJk7CF,EAAR,KAAuC,IIt8CrC,SJs8CwC,cI96CxB,KACA,KJ66CmE,EAArF,WAAqF,IAC1D,MAAkB,KAAG,OALjB,OAmWI,CAA3B,GAeE,sBAE6B,KAAnC,EAAmC,EAAnC,cACkB,kBRjlDH,CAAV,EAAoC,KQklDD,GAAc,OAAU,CAAxB,EACpC,UVjrDoB,UAAK,CACV,QAAR,GADa,EAIP,EAHN,IAC4B,CAEtB,yBA7Bb,MACe,YACnB,GACmB,WAHf,EAKW,gBUqsDX,Y,GAAA,iBAH+B,YAAc,CAA1B,KAAvB,GAjCgC,O,GAAlC,QAwUyB,IACzB,S,CAAA,+CA5/DI,GA4/DJ,4BAlgEuB,YAkgEvB,CAngEE,OAOQ,MAAN,IAE6C,eAA/C,eDjKe,QCgqET,QAJR,W,CLzrCA,wB2B1+BM,EtBmqEN,MsBnqEM,GtBmqEN,GsBnqEM,GtByKiD,MsBzKjD,GtB0KI,WAAY,MsB1KhB,GtB0KF,IAF2D,GAA7D,KAi2CoE,IAqpB3C,QACzB,GDxpEe,QCgqET,OA9U0B,EA+UpB,OACA,SDlqEG,QAEA,OADF,aAEW,QAAF,SAC8C,CAAtE,EADwB,EACxB,WAC6B,WC+pEP,IAGtB,YAEF,QAUmB,IAEK,IACtB,OW19DA,U,CAzEF,OA5Hc,CAiID,KACkB,OAlIjB,CA8HZ,UAOgC,OAzIpB,SA0II,KAGhB,G,EAc4C,KAA4B,KAAjE,EAAP,C,EAiDF,gBACW,G,EACe,EdiPT,GAAR,GACM,KclPW,EAC0B,SAAF,CAAvB,OACzB,eACA,iCACiB,EArJ4B,SAzDjC,CAyDM,GACyB,SA1D/B,CA0DI,GACiD,SA3DrD,CA2Dc,GACmC,SA5DjD,CA4DY,GAHqB,SAzDjC,CAyDM,GACyB,SA1D/B,CA0DI,GACiD,SA3DrD,CA2Dc,GACmC,SA5DjD,CA4DY,OAiJe,OAAvC,wBACiB,EArJ4B,SAzDjC,CAyDM,GACyB,SA1D/B,CA0DI,GACiD,SA3DrD,CA2Dc,GACmC,SA5DjD,CA4DY,IAoJL,EACA,OADA,OAErB,Q,EAOkC,MACd,CAAlB,C,EAIgC,QACd,CAAlB,C,CAQF,Y,EAE+B,EfjPnB,KAAY,CAAZ,EAEK,QADG,O,GAAA,GeiPC,EADU,Ef1O/B,Ee4OqB,GADgB,OAAhB,GAErB,Q,EAEA,YAGqB,EADQ,E,Ef3O7B,Ie2O6B,Ef3O7B,KAC+D,YA4F9C,SAAN,OA5FqG,CAA1G,G,EAAA,EACM,KAOZ,GAH2B,UAAN,S,EAAA,KACX,GACM,UAAN,GeqOW,GADgB,OAAhB,GAErB,Q,EAMA,YnBPgB,EmBQgB,EnBRhB,iBAC+B,GAD/B,YAEZ,GAEiB,oBAJL,E,EM5PE,K,EAAA,K,EAAA,EACd,G,EAAA,K,EAAA,K,EAAA,KaaQ,EAAO,OAIP,GAJO,OAEP,GAFO,OAAP,GAAO,SAJL,CAOF,GAHO,SAJL,CAKF,GAsPZ,Q,EAEA,cAGgD,SAC7B,SArQL,CAwDC,GA6MI,OA9MP,GA+MI,cAtQF,C,IZemB,KPuOjB,EmBgBA,EnBhBA,iBAC+B,GAD/B,YAEZ,GAEiB,oBAJL,E,EM5PE,K,EAAA,K,EAAA,EACd,G,EPAwB,KOAxB,G,EPCc,KEbN,CKYR,G,EAAA,MPCc,EEbN,MKYR,Gaae,OAIP,GAJO,OAEP,GAFO,OAAP,GAAO,SAJL,CAOF,GAHO,SAJL,CAKF,GA+PZ,Q,EAEA,cA7LqB,IAG2B,OAhFlC,CAgFI,GACgC,SAjFpC,CAiFM,GAC8B,SAlFpC,CAkFM,GALC,mBACE,mBACA,mBZxDvB,SYqPE,EZpP+B,OACL,aAAN,EACP,KAAkB,E,EAAA,GAAT,GADI,EACJ,IACE,GACM,E,EAAA,GAAgC,KAAnB,CAArB,SAGd,GAFiB,E,EAAA,K,EAEjB,GNzCE,GMuCe,ENvCf,MAPA,CMgDF,O,EAAA,GNzCE,GAPA,CM8Ce,I,EAAA,GNvCf,OMuCe,ENvCf,MAPA,CM8Ce,KAIS,E,EAAA,GAAR,OAEC,OADH,GAElB,GAE+B,E,EAAA,GAAR,KACT,OACS,E,EAAA,OAEhB,OAAoB,E,EAAA,GAAT,GAAX,EACiB,E,EAAA,GAAkC,KAArB,CAArB,SAGhB,GAFmB,E,EAAA,K,EAEnB,GNxDI,GMsDe,ENtDf,MAPA,CM+DJ,O,EAAA,GNxDI,GAPA,CM6De,I,EAAA,GNtDf,OMsDe,ENtDf,MAPA,CM6De,KAIS,E,EAAA,GAAR,OAEC,OADH,GAEpB,GACmC,E,EAAA,GAAR,KACT,OACS,E,EAAA,WA9BuB,CAAvB,OAAR,CAAvB,MJkEY,mBI/BC,e,EJ8hBf,YL7buB,U,EKocrB,K,EAAA,K,EAAA,K,EAAA,K,EAAA,O,EAAA,2CIriBa,KJqiBb,qBAUoB,YH1RH,UAAV,EGgRP,EHjWc,KAC2B,QAV3B,oBAC8B,EAD9B,OAC8B,EAC1C,GAwFK,WAtFY,OAJL,OAaK,cATA,MGsWnB,EJrmB0B,OI0nBa,EHlXpB,OGkXoB,EHnagC,sBGmahC,CAChB,GADgB,EACL,IAoFU,6CA9FR,KAUU,oBAoFF,wBAhFnB,SJ9nBT,GENN,OFMM,EENN,MAPA,CFaM,CI8nBS,EFpoBf,OEooBe,EFpoBf,MAPA,GAOA,KAPA,CFaM,OAMD,KAPW,OI4oBc,gBAPZ,OJ9nBb,iCAWA,K,CAAA,MEvBL,OFuBK,EEvBL,eFuBK,EEvBL,2BFaM,IEbN,OFaM,EEbN,MFaM,IADD,KAYb,GIynBmB,OAAmB,wBJroBzB,OIqoByB,EJroBzB,UEZL,OFYK,EEZL,MFaM,GEbN,6BFuBK,mBEvBL,OFuBK,EEvBL,WFYW,CEZX,MFaM,IEbN,OFaM,EEbN,MFaM,IADD,QEnBL,IFaM,EAMD,EANC,KEbN,IFaM,IEbN,KFaM,IADU,MI+nBD,EJ/nBC,gBIkQtB,IAAU,YAAV,WACU,KAAU,GAzB4B,OHZjC,IAAkB,CGab,YAExB,wBACqE,WAAvB,QACpB,cAEJ,EAmSR,Q,CArSY,EOtNjB,EP4fT,KO5fS,MP8fT,MAvSqC,YAAc,CAA1B,E,EAAA,CAAvB,OAGmB,SAAV,GAxOmB,qCACpB,WAAO,GACI,YAC6B,KAAhD,KAAJ,OAAI,OAsOiC,mB,EAAA,Q,EAAA,WAIjB,GAalB,gCAkZkB,CAlZlB,EAkZM,OACE,sEAEuB,KACK,CADL,sBADC,CACD,CAEF,YA7iBR,OAAK,EAAL,EAAK,MACjB,iBAA6B,GAApC,MAEO,SAHY,EAGZ,EAijBc,GADK,OADT,cADG,kBADA,SAOgB,CAAd,WADH,IAAF,KAEC,UAFD,IAUI,WARH,GAEF,CAOK,OATH,CASG,OAKA,cADG,0BA7FX,CA6FW,EA7FtB,IACqB,GACzB,GACyB,cA+FT,mBHpaC,CGoaD,EHpaT,IG0bqC,GH1bD,KGuazC,E,CHvayC,EGuazC,IAmB0C,iCAlBtB,wBHlcR,mBAAV,EAAU,EAAV,IACyC,GAD/B,YD3PY,EC2PZ,KD3PY,CEZhB,KD2QS,KASA,KCpRT,KD2QS,OC3QT,GDoRS,YATA,KD/PO,EC2PZ,ED3PY,KCuN6C,aG4e7C,EAAqC,EH5eQ,oBG4e7C,GAAqC,CAArC,EAAqC,OAMvC,WACsB,qCAEd,KHvXzB,QG0XqC,GH1XrC,Q,CAAA,EG0XqC,mDJ7rB7B,OAXA,OEZL,OFaM,EEbN,MFaM,CAUD,EEvBL,OFuBK,EEvBL,YFaM,QAUD,OEvBL,OFaM,EEbN,MFaM,CAUD,EEvBL,OFuBK,EEvBL,YFaM,OADD,QAWA,sBAXM,IEZX,OFYW,EEZX,MFYW,GEZX,MFaM,IEbN,OFaM,EEbN,MFaM,IADD,MAWA,EI+sBS,SAAmB,4B,CAAA,mBAAnB,EAAmB,ML1iBZ,CAClB,OAGM,EAHN,IAC4B,CAEtB,yBA7Bb,IACe,cACnB,GACmB,mBK6kBjB,8FAlDoE,CAAN,KAAhE,IA9EF,KLreI,IACF,W,IK4mBK,MACT,OIvrBe,UJqCQ,KAAjB,EAAiB,EACuB,OAA1C,4DACU,IAAiC,GAAzC,UAAQ,KAAiC,GAAzC,QAAQ,KAAiC,GAAzC,QAAQ,KAAiC,GAAzC,YAD+C,OAAjD,4BACU,EAAiC,GAAzC,YAD+C,OAAjD,ULoCA,WK/BmB,KAAjB,EAAiB,EL+BnB,WSxEJ,OYgNA,Q,EAEA,Y,EAEoB,EZjNF,GAAR,SACU,UAC0B,OAAqB,CAAjE,EAA4C,EAA9C,OAAE,OYgNyB,OAAzB,QACiB,EAtN4B,SAzDjC,CAyDM,GACyB,SA1D/B,CA0DI,GACiD,SA3DrD,CA2Dc,GACmC,SA5DjD,CA4DY,OAkNe,CAAd,OAAF,GAAvB,QAGmB,EACA,OADA,OAErB,Q,EAEA,cZnNA,aACa,KACA,YP8KG,EmBqCI,EnBrCJ,+BAC+B,CAC3C,GAEiB,oBAJL,EAIK,IgBnHK,GADb,YlBsBU,sBkBnBrB,6ChB6Gc,mCAC+B,CAC3C,GAEiB,oBAJL,EAIK,IgBnHK,GADb,OAGX,OlB0CqB,K,CAAA,EA1Bf,WACe,QACnB,MACmB,SAHf,EAGe,IAEJ,ekBrBjB,+CT7Da,YAED,KAA2B,KAC3B,KAA2B,KAFvC,OAOU,EAEE,K,EV2Qd,U,EAAA,EA1QE,G,EACA,K,IC2FqB,KAAR,GA1BP,WACe,QACnB,MACmB,SAHf,E,EAGe,EAEJ,G,EAAA,K,EDtEjB,IC2FqB,ED3FrB,QEhFO,kBFgFP,qB,EAAA,oBAOY,E,EAAA,Q,EAAA,M,EAAA,KADM,OACN,WADM,iB,EAAA,EAPlB,G,EACA,K,EC2FqB,G,CAAA,EA1Bf,WACe,QACnB,MACmB,SAHf,E,EAGe,EAEJ,G,EAAA,K,EDtEjB,M,IAAA,MEhFO,oBFgFP,IUJU,EVIV,iB,EAAA,sB,EAOY,M,IAAA,M,EAAA,OADM,KACN,WADM,iBAcO,oBAAD,0BACd,SAAN,CAAM,EACK,YAAb,GI/HQ,EJ+HR,MAFuB,CAAD,GG0IV,UHxIZ,EGwIY,qBAC+B,CAC3C,GAEiB,oBH5IjB,EI/HQ,CFaM,CC8PG,EC3QT,QFaM,OADU,QFiHD,oBAAD,gCAAC,CAAD,GG0IV,UH1IU,EG0IV,OAC+B,GAD/B,YAEZ,GAEiB,oBH9IK,EI7Hd,KFaM,CC8PG,EC3QT,QFaM,OADU,SFgXP,EEhXO,EFgXP,CEhXO,EFgXP,yBAGO,EAHP,IAGO,G,EAAA,GClNL,QDlKnB,2CECwB,EFDxB,UAwJmC,GAE3B,iBAAN,CAAM,EACF,OAIR,YAHG,4BAIwB,EAAD,WAElB,WACoB,CAAuC,GAGrD,GAAK,GK0BZ,KACC,KAAsC,KAAR,KAApC,ELjCwB,OKiCxB,QLtBuC,EGsCkB,kCHtClB,eAZtB,GAAnB,SAYyC,OAC7B,kCAlBF,EAkBE,IApByB,GAE3B,iBAAN,CAAM,EACF,OAIR,YAHG,4BAIwB,EAAD,WAElB,WACoB,CAAuC,GAGrD,GAAK,GK0BZ,KACC,KAAsC,KAAR,KAApC,ELjCwB,OKiCxB,QLtBuC,EGsCkB,kCHtClB,eAZtB,GAAnB,SAYyC,OAC7B,kCAlBF,EAkBE,IGoCkD,GHpClD,EGoCkD,aHpClD,EGoCkD,QHgG5C,IGhG4C,S,CAAA,MH+FzD,GG/FyD,SH+F5C,GAAb,KAAa,wBACA,cACG,SAAoB,yBG5C3B,C,CH4C2B,EGxCtB,YAJL,C,CAIK,UAlDiD,4CAuH7D,E,CAAA,mB,CAAA,iBAzHoD,aA6FvD,CA7FuD,EA6FvD,EA7FuD,CA6FvD,GA7FuD,QA6FvD,E,CAGyC,MAhGc,eA6FvD,CA7FuD,EA6FvD,EA7FuD,CA6FvD,GA7FuD,QA6FvD,E,CAGyC,MAhGc,EHwG/C,KAAa,WAEd,KAAY,kCAGT,OAA+C,gBG9GE,yBHiH5B,EAEP,aMspBrB,OAAI,YAEC,S,CAAoB,SACpB,KADoB,YAFzB,OAAI,YAEC,S,CAAoB,SACpB,KADoB,IA37BxB,OATE,SAAO,CAAP,EASK,KAAU,EARV,iBAQA,KAAU,KNuFA,eAAD,0BAAC,eAAD,sCAAC,CAAD,GGiIV,UHjIU,EGiIV,OD3PY,GC2PZ,SAC+B,CCxQnC,KDuQI,KCvQJ,UJwIN,IGwIU,ODpQY,GEZhB,GD2QS,KC3QT,ED2QS,OC3QT,aD2QS,KD/PO,KF4HtB,ME3HY,UF4Hd,KG2IiB,OCpRT,YDoRS,YDxQO,IF0HF,EEzHR,GEbN,KFaM,MFyHQ,YAAC,CAAD,GGiIV,UHjIU,EGiIV,OD3PY,GC2PZ,SAC+B,CCxQnC,KDuQI,KCvQJ,UJwIN,IGwIU,ODpQY,GEZhB,GD2QS,KC3QT,ED2QS,OC3QT,aD2QS,KD/PO,KF4HtB,ME3HY,UF4Hd,KG2IiB,OCpRT,YDoRS,YDxQO,IF0HF,EEzHR,GEbN,KFaM,MANG,KAArB,iBIyCI,SNgSiC,GA1MV,eAAD,YAAC,CAAD,GGiIV,UAAV,EHjIoB,EGiIV,OD3PY,GF4HtB,I,CGwIU,ODpQY,CEZhB,GD2QS,KD/PO,KF4HtB,I,CG4Ie,KDxQO,IF0HF,EE1HE,I,EAAA,GFSO,GAAjC,E,EAAA,WAEsB,EAFtB,MACmB,EACN,KAAS,CAFtB,EAAiC,EAEX,IAF0B,CAAf,GAAjC,MAGe,KAAW,GA2XpB,OA7QkB,gBGiIpB,UAAU,OD3PY,GC2PZ,SAC+B,CCxQnC,KDuQI,KCvQJ,UJwIN,IGwIU,ODpQY,GEZhB,GD2QS,KC3QT,ED2QS,OC3QT,aD2QS,KD/PO,KF4HtB,ME3HY,mBCuQG,OCpRT,YDoRS,YDxQO,IC2PtB,ED1PY,GEbN,KFaM,YF0ZN,yBACE,I,CAlSa,kBAAD,oCAAC,CAAD,GGiIV,UHjIU,EGiIV,OD3PY,GC2PZ,SAC+B,CCxQnC,KDuQI,KCvQJ,UJwIA,KAAN,EGwIU,ODpQY,GEZhB,GD2QS,KC3QT,ED2QS,OC3QT,aD2QS,KD/PO,KF4HhB,OAAN,IE3HY,iBCuQG,OCpRT,YDoRS,YDxQO,IF0HF,EEzHR,GEbN,KFaM,UF+ZC,IAtSQ,kBAAD,oCAAC,CAAD,GGiIV,UHjIU,EGiIV,OD3PY,GC2PZ,SAC+B,CCxQnC,KDuQI,KCvQJ,UJwIA,KAAN,EGwIU,ODpQY,GEZhB,GD2QS,KC3QT,ED2QS,OC3QT,aD2QS,KD/PO,KF4HhB,OAAN,IE3HY,iBCuQG,OCpRT,YDoRS,YDxQO,IF0HF,EEzHR,GEbN,KFaM,UFyHS,kBAAD,0BAAC,kBAAD,sCAAC,CAAD,GGiIV,UHjIU,EGiIV,OD3PY,GC2PZ,SAC+B,CCxQnC,KDuQI,KCvQJ,UJwIA,KAAN,EGwIU,ODpQY,GEZhB,GD2QS,KC3QT,ED2QS,OC3QT,aD2QS,KD/PO,KF4HhB,OAAN,IE3HY,UF4Hd,KG2IiB,OCpRT,YDoRS,YDxQO,IF0HF,EEzHR,GEbN,KFaM,MFyHQ,YAAC,CAAD,GGiIV,UHjIU,EGiIV,OD3PY,GC2PZ,SAC+B,CCxQnC,KDuQI,KCvQJ,UJwIA,KAAN,EGwIU,ODpQY,GEZhB,GD2QS,KC3QT,ED2QS,OC3QT,aD2QS,KD/PO,KF4HhB,OAAN,IE3HY,UF4Hd,KG2IiB,OCpRT,YDoRS,YDxQO,IF0HF,EEzHR,GEbN,KFaM,MANG,KAArB,sBCoNgE,EDpNhE,IF6bO,OAAyB,KA9TL,mBAAD,YAAC,CAAD,GGiIV,UHjIU,EGiIV,OD3PY,GF4HhB,KAAN,E,CGwIU,ODpQY,CEZhB,GD2QS,KD/PO,KF4HhB,KAAN,E,CG4Ie,KDxQO,IFybiB,GAFzC,EAGE,OAFC,KAAyB,UAIzB,SAAyB,EAAzB,EAlUoB,eAAD,YAAC,CAAD,GGiIV,UHjIU,EGiIV,OD3PY,GF4HhB,KAAN,E,CGwIU,ODpQY,CEZhB,GD2QS,KD/PO,KF4HhB,KAAN,E,CG4Ie,KDxQO,IF6biB,GAFzC,EAGE,IAFC,IAAyB,wBAKE,GALF,EAK5B,oBA5TE,IA8CA,QA/CqB,OAAD,GG4EmC,QH7BvD,EG6Bu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",
  "sourcesContent": [
    "#include \"alloc.h\"\n#include \"tree_sitter/api.h\"\n#include <stdlib.h>\n\nstatic void *ts_malloc_default(size_t size) {\n  void *result = malloc(size);\n  if (size > 0 && !result) {\n    fprintf(stderr, \"tree-sitter failed to allocate %zu bytes\", size);\n    abort();\n  }\n  return result;\n}\n\nstatic void *ts_calloc_default(size_t count, size_t size) {\n  void *result = calloc(count, size);\n  if (count > 0 && !result) {\n    fprintf(stderr, \"tree-sitter failed to allocate %zu bytes\", count * size);\n    abort();\n  }\n  return result;\n}\n\nstatic void *ts_realloc_default(void *buffer, size_t size) {\n  void *result = realloc(buffer, size);\n  if (size > 0 && !result) {\n    fprintf(stderr, \"tree-sitter failed to reallocate %zu bytes\", size);\n    abort();\n  }\n  return result;\n}\n\n// Allow clients to override allocation functions dynamically\nTS_PUBLIC void *(*ts_current_malloc)(size_t) = ts_malloc_default;\nTS_PUBLIC void *(*ts_current_calloc)(size_t, size_t) = ts_calloc_default;\nTS_PUBLIC void *(*ts_current_realloc)(void *, size_t) = ts_realloc_default;\nTS_PUBLIC void (*ts_current_free)(void *) = free;\n\nvoid ts_set_allocator(\n  void *(*new_malloc)(size_t size),\n  void *(*new_calloc)(size_t count, size_t size),\n  void *(*new_realloc)(void *ptr, size_t size),\n  void (*new_free)(void *ptr)\n) {\n  ts_current_malloc = new_malloc ? new_malloc : ts_malloc_default;\n  ts_current_calloc = new_calloc ? new_calloc : ts_calloc_default;\n  ts_current_realloc = new_realloc ? new_realloc : ts_realloc_default;\n  ts_current_free = new_free ? new_free : free;\n}\n",
    "#include \"./get_changed_ranges.h\"\n#include \"./subtree.h\"\n#include \"./language.h\"\n#include \"./error_costs.h\"\n#include \"./tree_cursor.h\"\n#include \"./ts_assert.h\"\n\n// #define DEBUG_GET_CHANGED_RANGES\n\nstatic void ts_range_array_add(\n  TSRangeArray *self,\n  Length start,\n  Length end\n) {\n  if (self->size > 0) {\n    TSRange *last_range = array_back(self);\n    if (start.bytes <= last_range->end_byte) {\n      last_range->end_byte = end.bytes;\n      last_range->end_point = end.extent;\n      return;\n    }\n  }\n\n  if (start.bytes < end.bytes) {\n    TSRange range = { start.extent, end.extent, start.bytes, end.bytes };\n    array_push(self, range);\n  }\n}\n\nbool ts_range_array_intersects(\n  const TSRangeArray *self,\n  unsigned start_index,\n  uint32_t start_byte,\n  uint32_t end_byte\n) {\n  for (unsigned i = start_index; i < self->size; i++) {\n    TSRange *range = array_get(self, i);\n    if (range->end_byte > start_byte) {\n      if (range->start_byte >= end_byte) break;\n      return true;\n    }\n  }\n  return false;\n}\n\nvoid ts_range_array_get_changed_ranges(\n  const TSRange *old_ranges, unsigned old_range_count,\n  const TSRange *new_ranges, unsigned new_range_count,\n  TSRangeArray *differences\n) {\n  unsigned new_index = 0;\n  unsigned old_index = 0;\n  Length current_position = length_zero();\n  bool in_old_range = false;\n  bool in_new_range = false;\n\n  while (old_index < old_range_count || new_index < new_range_count) {\n    const TSRange *old_range = &old_ranges[old_index];\n    const TSRange *new_range = &new_ranges[new_index];\n\n    Length next_old_position;\n    if (in_old_range) {\n      next_old_position = (Length) {old_range->end_byte, old_range->end_point};\n    } else if (old_index < old_range_count) {\n      next_old_position = (Length) {old_range->start_byte, old_range->start_point};\n    } else {\n      next_old_position = LENGTH_MAX;\n    }\n\n    Length next_new_position;\n    if (in_new_range) {\n      next_new_position = (Length) {new_range->end_byte, new_range->end_point};\n    } else if (new_index < new_range_count) {\n      next_new_position = (Length) {new_range->start_byte, new_range->start_point};\n    } else {\n      next_new_position = LENGTH_MAX;\n    }\n\n    if (next_old_position.bytes < next_new_position.bytes) {\n      if (in_old_range != in_new_range) {\n        ts_range_array_add(differences, current_position, next_old_position);\n      }\n      if (in_old_range) old_index++;\n      current_position = next_old_position;\n      in_old_range = !in_old_range;\n    } else if (next_new_position.bytes < next_old_position.bytes) {\n      if (in_old_range != in_new_range) {\n        ts_range_array_add(differences, current_position, next_new_position);\n      }\n      if (in_new_range) new_index++;\n      current_position = next_new_position;\n      in_new_range = !in_new_range;\n    } else {\n      if (in_old_range != in_new_range) {\n        ts_range_array_add(differences, current_position, next_new_position);\n      }\n      if (in_old_range) old_index++;\n      if (in_new_range) new_index++;\n      in_old_range = !in_old_range;\n      in_new_range = !in_new_range;\n      current_position = next_new_position;\n    }\n  }\n}\n\ntypedef struct {\n  TreeCursor cursor;\n  const TSLanguage *language;\n  unsigned visible_depth;\n  bool in_padding;\n  Subtree prev_external_token;\n} Iterator;\n\nstatic Iterator iterator_new(\n  TreeCursor *cursor,\n  const Subtree *tree,\n  const TSLanguage *language\n) {\n  array_clear(&cursor->stack);\n  array_push(&cursor->stack, ((TreeCursorEntry) {\n    .subtree = tree,\n    .position = length_zero(),\n    .child_index = 0,\n    .structural_child_index = 0,\n  }));\n  return (Iterator) {\n    .cursor = *cursor,\n    .language = language,\n    .visible_depth = 1,\n    .in_padding = false,\n    .prev_external_token = NULL_SUBTREE,\n  };\n}\n\nstatic bool iterator_done(Iterator *self) {\n  return self->cursor.stack.size == 0;\n}\n\nstatic Length iterator_start_position(Iterator *self) {\n  TreeCursorEntry entry = *array_back(&self->cursor.stack);\n  if (self->in_padding) {\n    return entry.position;\n  } else {\n    return length_add(entry.position, ts_subtree_padding(*entry.subtree));\n  }\n}\n\nstatic Length iterator_end_position(Iterator *self) {\n  TreeCursorEntry entry = *array_back(&self->cursor.stack);\n  Length result = length_add(entry.position, ts_subtree_padding(*entry.subtree));\n  if (self->in_padding) {\n    return result;\n  } else {\n    return length_add(result, ts_subtree_size(*entry.subtree));\n  }\n}\n\nstatic bool iterator_tree_is_visible(const Iterator *self) {\n  TreeCursorEntry entry = *array_back(&self->cursor.stack);\n  if (ts_subtree_visible(*entry.subtree)) return true;\n  if (self->cursor.stack.size > 1) {\n    Subtree parent = *array_get(&self->cursor.stack, self->cursor.stack.size - 2)->subtree;\n    return ts_language_alias_at(\n      self->language,\n      parent.ptr->production_id,\n      entry.structural_child_index\n    ) != 0;\n  }\n  return false;\n}\n\nstatic void iterator_get_visible_state(\n  const Iterator *self,\n  Subtree *tree,\n  TSSymbol *alias_symbol,\n  uint32_t *start_byte\n) {\n  uint32_t i = self->cursor.stack.size - 1;\n\n  if (self->in_padding) {\n    if (i == 0) return;\n    i--;\n  }\n\n  for (; i + 1 > 0; i--) {\n    TreeCursorEntry entry = *array_get(&self->cursor.stack, i);\n\n    if (i > 0) {\n      const Subtree *parent = array_get(&self->cursor.stack, i - 1)->subtree;\n      *alias_symbol = ts_language_alias_at(\n        self->language,\n        parent->ptr->production_id,\n        entry.structural_child_index\n      );\n    }\n\n    if (ts_subtree_visible(*entry.subtree) || *alias_symbol) {\n      *tree = *entry.subtree;\n      *start_byte = entry.position.bytes;\n      break;\n    }\n  }\n}\n\nstatic void iterator_ascend(Iterator *self) {\n  if (iterator_done(self)) return;\n  if (iterator_tree_is_visible(self) && !self->in_padding) self->visible_depth--;\n  if (array_back(&self->cursor.stack)->child_index > 0) self->in_padding = false;\n  self->cursor.stack.size--;\n}\n\nstatic bool iterator_descend(Iterator *self, uint32_t goal_position) {\n  if (self->in_padding) return false;\n\n  bool did_descend = false;\n  do {\n    did_descend = false;\n    TreeCursorEntry entry = *array_back(&self->cursor.stack);\n    Length position = entry.position;\n    uint32_t structural_child_index = 0;\n    for (uint32_t i = 0, n = ts_subtree_child_count(*entry.subtree); i < n; i++) {\n      const Subtree *child = &ts_subtree_children(*entry.subtree)[i];\n      Length child_left = length_add(position, ts_subtree_padding(*child));\n      Length child_right = length_add(child_left, ts_subtree_size(*child));\n\n      if (child_right.bytes > goal_position) {\n        array_push(&self->cursor.stack, ((TreeCursorEntry) {\n          .subtree = child,\n          .position = position,\n          .child_index = i,\n          .structural_child_index = structural_child_index,\n        }));\n\n        if (iterator_tree_is_visible(self)) {\n          if (child_left.bytes > goal_position) {\n            self->in_padding = true;\n          } else {\n            self->visible_depth++;\n          }\n          return true;\n        }\n\n        did_descend = true;\n        break;\n      }\n\n      position = child_right;\n      if (!ts_subtree_extra(*child)) structural_child_index++;\n      Subtree last_external_token = ts_subtree_last_external_token(*child);\n      if (last_external_token.ptr) {\n        self->prev_external_token = last_external_token;\n      }\n    }\n  } while (did_descend);\n\n  return false;\n}\n\nstatic void iterator_advance(Iterator *self) {\n  if (self->in_padding) {\n    self->in_padding = false;\n    if (iterator_tree_is_visible(self)) {\n      self->visible_depth++;\n    } else {\n      iterator_descend(self, 0);\n    }\n    return;\n  }\n\n  for (;;) {\n    if (iterator_tree_is_visible(self)) self->visible_depth--;\n    TreeCursorEntry entry = array_pop(&self->cursor.stack);\n    if (iterator_done(self)) return;\n\n    const Subtree *parent = array_back(&self->cursor.stack)->subtree;\n    uint32_t child_index = entry.child_index + 1;\n    Subtree last_external_token = ts_subtree_last_external_token(*entry.subtree);\n    if (last_external_token.ptr) {\n      self->prev_external_token = last_external_token;\n    }\n    if (ts_subtree_child_count(*parent) > child_index) {\n      Length position = length_add(entry.position, ts_subtree_total_size(*entry.subtree));\n      uint32_t structural_child_index = entry.structural_child_index;\n      if (!ts_subtree_extra(*entry.subtree)) structural_child_index++;\n      const Subtree *next_child = &ts_subtree_children(*parent)[child_index];\n\n      array_push(&self->cursor.stack, ((TreeCursorEntry) {\n        .subtree = next_child,\n        .position = position,\n        .child_index = child_index,\n        .structural_child_index = structural_child_index,\n      }));\n\n      if (iterator_tree_is_visible(self)) {\n        if (ts_subtree_padding(*next_child).bytes > 0) {\n          self->in_padding = true;\n        } else {\n          self->visible_depth++;\n        }\n      } else {\n        iterator_descend(self, 0);\n      }\n      break;\n    }\n  }\n}\n\ntypedef enum {\n  IteratorDiffers,\n  IteratorMayDiffer,\n  IteratorMatches,\n} IteratorComparison;\n\nstatic IteratorComparison iterator_compare(\n  const Iterator *old_iter,\n  const Iterator *new_iter\n) {\n  Subtree old_tree = NULL_SUBTREE;\n  Subtree new_tree = NULL_SUBTREE;\n  uint32_t old_start = 0;\n  uint32_t new_start = 0;\n  TSSymbol old_alias_symbol = 0;\n  TSSymbol new_alias_symbol = 0;\n  iterator_get_visible_state(old_iter, &old_tree, &old_alias_symbol, &old_start);\n  iterator_get_visible_state(new_iter, &new_tree, &new_alias_symbol, &new_start);\n  TSSymbol old_symbol = ts_subtree_symbol(old_tree);\n  TSSymbol new_symbol = ts_subtree_symbol(new_tree);\n\n  if (!old_tree.ptr && !new_tree.ptr) return IteratorMatches;\n  if (!old_tree.ptr || !new_tree.ptr) return IteratorDiffers;\n  if (old_alias_symbol != new_alias_symbol || old_symbol != new_symbol) return IteratorDiffers;\n\n  uint32_t old_size = ts_subtree_size(old_tree).bytes;\n  uint32_t new_size = ts_subtree_size(new_tree).bytes;\n  TSStateId old_state = ts_subtree_parse_state(old_tree);\n  TSStateId new_state = ts_subtree_parse_state(new_tree);\n  bool old_has_external_tokens = ts_subtree_has_external_tokens(old_tree);\n  bool new_has_external_tokens = ts_subtree_has_external_tokens(new_tree);\n  uint32_t old_error_cost = ts_subtree_error_cost(old_tree);\n  uint32_t new_error_cost = ts_subtree_error_cost(new_tree);\n\n  if (\n    old_start != new_start ||\n    old_symbol == ts_builtin_sym_error ||\n    old_size != new_size ||\n    old_state == TS_TREE_STATE_NONE ||\n    new_state == TS_TREE_STATE_NONE ||\n    ((old_state == ERROR_STATE) != (new_state == ERROR_STATE)) ||\n    old_error_cost != new_error_cost ||\n    old_has_external_tokens != new_has_external_tokens ||\n    ts_subtree_has_changes(old_tree) ||\n    (\n      old_has_external_tokens &&\n      !ts_subtree_external_scanner_state_eq(old_iter->prev_external_token, new_iter->prev_external_token)\n    )\n  ) {\n    return IteratorMayDiffer;\n  }\n\n  return IteratorMatches;\n}\n\n#ifdef DEBUG_GET_CHANGED_RANGES\nstatic inline void iterator_print_state(Iterator *self) {\n  TreeCursorEntry entry = *array_back(&self->cursor.stack);\n  TSPoint start = iterator_start_position(self).extent;\n  TSPoint end = iterator_end_position(self).extent;\n  const char *name = ts_language_symbol_name(self->language, ts_subtree_symbol(*entry.subtree));\n  printf(\n    \"(%-25s %s\\t depth:%u [%u, %u] - [%u, %u])\",\n    name, self->in_padding ? \"(p)\" : \"   \",\n    self->visible_depth,\n    start.row, start.column,\n    end.row, end.column\n  );\n}\n#endif\n\nunsigned ts_subtree_get_changed_ranges(\n  const Subtree *old_tree, const Subtree *new_tree,\n  TreeCursor *cursor1, TreeCursor *cursor2,\n  const TSLanguage *language,\n  const TSRangeArray *included_range_differences,\n  TSRange **ranges\n) {\n  TSRangeArray results = array_new();\n\n  Iterator old_iter = iterator_new(cursor1, old_tree, language);\n  Iterator new_iter = iterator_new(cursor2, new_tree, language);\n\n  unsigned included_range_difference_index = 0;\n\n  Length position = iterator_start_position(&old_iter);\n  Length next_position = iterator_start_position(&new_iter);\n  if (position.bytes < next_position.bytes) {\n    ts_range_array_add(&results, position, next_position);\n    position = next_position;\n  } else if (position.bytes > next_position.bytes) {\n    ts_range_array_add(&results, next_position, position);\n    next_position = position;\n  }\n\n  do {\n    #ifdef DEBUG_GET_CHANGED_RANGES\n    printf(\"At [%-2u, %-2u] Compare \", position.extent.row, position.extent.column);\n    iterator_print_state(&old_iter);\n    printf(\"\\tvs\\t\");\n    iterator_print_state(&new_iter);\n    puts(\"\");\n    #endif\n\n    // Compare the old and new subtrees.\n    IteratorComparison comparison = iterator_compare(&old_iter, &new_iter);\n\n    // Even if the two subtrees appear to be identical, they could differ\n    // internally if they contain a range of text that was previously\n    // excluded from the parse, and is now included, or vice-versa.\n    if (comparison == IteratorMatches && ts_range_array_intersects(\n      included_range_differences,\n      included_range_difference_index,\n      position.bytes,\n      iterator_end_position(&old_iter).bytes\n    )) {\n      comparison = IteratorMayDiffer;\n    }\n\n    bool is_changed = false;\n    switch (comparison) {\n      // If the subtrees are definitely identical, move to the end\n      // of both subtrees.\n      case IteratorMatches:\n        next_position = iterator_end_position(&old_iter);\n        break;\n\n      // If the subtrees might differ internally, descend into both\n      // subtrees, finding the first child that spans the current position.\n      case IteratorMayDiffer:\n        if (iterator_descend(&old_iter, position.bytes)) {\n          if (!iterator_descend(&new_iter, position.bytes)) {\n            is_changed = true;\n            next_position = iterator_end_position(&old_iter);\n          }\n        } else if (iterator_descend(&new_iter, position.bytes)) {\n          is_changed = true;\n          next_position = iterator_end_position(&new_iter);\n        } else {\n          next_position = length_min(\n            iterator_end_position(&old_iter),\n            iterator_end_position(&new_iter)\n          );\n        }\n        break;\n\n      // If the subtrees are different, record a change and then move\n      // to the end of both subtrees.\n      case IteratorDiffers:\n        is_changed = true;\n        next_position = length_min(\n          iterator_end_position(&old_iter),\n          iterator_end_position(&new_iter)\n        );\n        break;\n    }\n\n    // Ensure that both iterators are caught up to the current position.\n    while (\n      !iterator_done(&old_iter) &&\n      iterator_end_position(&old_iter).bytes <= next_position.bytes\n    ) iterator_advance(&old_iter);\n    while (\n      !iterator_done(&new_iter) &&\n      iterator_end_position(&new_iter).bytes <= next_position.bytes\n    ) iterator_advance(&new_iter);\n\n    // Ensure that both iterators are at the same depth in the tree.\n    while (old_iter.visible_depth > new_iter.visible_depth) {\n      iterator_ascend(&old_iter);\n    }\n    while (new_iter.visible_depth > old_iter.visible_depth) {\n      iterator_ascend(&new_iter);\n    }\n\n    if (is_changed) {\n      #ifdef DEBUG_GET_CHANGED_RANGES\n      printf(\n        \"  change: [[%u, %u] - [%u, %u]]\\n\",\n        position.extent.row + 1, position.extent.column,\n        next_position.extent.row + 1, next_position.extent.column\n      );\n      #endif\n\n      ts_range_array_add(&results, position, next_position);\n    }\n\n    position = next_position;\n\n    // Keep track of the current position in the included range differences\n    // array in order to avoid scanning the entire array on each iteration.\n    while (included_range_difference_index < included_range_differences->size) {\n      const TSRange *range = array_get(included_range_differences,\n        included_range_difference_index\n      );\n      if (range->end_byte <= position.bytes) {\n        included_range_difference_index++;\n      } else {\n        break;\n      }\n    }\n  } while (!iterator_done(&old_iter) && !iterator_done(&new_iter));\n\n  Length old_size = ts_subtree_total_size(*old_tree);\n  Length new_size = ts_subtree_total_size(*new_tree);\n  if (old_size.bytes < new_size.bytes) {\n    ts_range_array_add(&results, old_size, new_size);\n  } else if (new_size.bytes < old_size.bytes) {\n    ts_range_array_add(&results, new_size, old_size);\n  }\n\n  *cursor1 = old_iter.cursor;\n  *cursor2 = new_iter.cursor;\n  *ranges = results.contents;\n  return results.size;\n}\n",
    "#ifndef TREE_SITTER_ARRAY_H_\n#define TREE_SITTER_ARRAY_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"./alloc.h\"\n#include \"./ts_assert.h\"\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef _MSC_VER\n#pragma warning(push)\n#pragma warning(disable : 4101)\n#elif defined(__GNUC__) || defined(__clang__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-variable\"\n#endif\n\n#define Array(T)       \\\n  struct {             \\\n    T *contents;       \\\n    uint32_t size;     \\\n    uint32_t capacity; \\\n  }\n\n/// Initialize an array.\n#define array_init(self) \\\n  ((self)->size = 0, (self)->capacity = 0, (self)->contents = NULL)\n\n/// Create an empty array.\n#define array_new() \\\n  { NULL, 0, 0 }\n\n/// Get a pointer to the element at a given `index` in the array.\n#define array_get(self, _index) \\\n  (ts_assert((uint32_t)(_index) < (self)->size), &(self)->contents[_index])\n\n/// Get a pointer to the first element in the array.\n#define array_front(self) array_get(self, 0)\n\n/// Get a pointer to the last element in the array.\n#define array_back(self) array_get(self, (self)->size - 1)\n\n/// Clear the array, setting its size to zero. Note that this does not free any\n/// memory allocated for the array's contents.\n#define array_clear(self) ((self)->size = 0)\n\n/// Reserve `new_capacity` elements of space in the array. If `new_capacity` is\n/// less than the array's current capacity, this function has no effect.\n#define array_reserve(self, new_capacity) \\\n  _array__reserve((Array *)(self), array_elem_size(self), new_capacity)\n\n/// Free any memory allocated for this array. Note that this does not free any\n/// memory allocated for the array's contents.\n#define array_delete(self) _array__delete((Array *)(self))\n\n/// Push a new `element` onto the end of the array.\n#define array_push(self, element)                            \\\n  (_array__grow((Array *)(self), 1, array_elem_size(self)), \\\n   (self)->contents[(self)->size++] = (element))\n\n/// Increase the array's size by `count` elements.\n/// New elements are zero-initialized.\n#define array_grow_by(self, count) \\\n  do { \\\n    if ((count) == 0) break; \\\n    _array__grow((Array *)(self), count, array_elem_size(self)); \\\n    memset((self)->contents + (self)->size, 0, (count) * array_elem_size(self)); \\\n    (self)->size += (count); \\\n  } while (0)\n\n/// Append all elements from one array to the end of another.\n#define array_push_all(self, other)                                       \\\n  array_extend((self), (other)->size, (other)->contents)\n\n/// Append `count` elements to the end of the array, reading their values from the\n/// `contents` pointer.\n#define array_extend(self, count, contents)                    \\\n  _array__splice(                                               \\\n    (Array *)(self), array_elem_size(self), (self)->size, \\\n    0, count,  contents                                        \\\n  )\n\n/// Remove `old_count` elements from the array starting at the given `index`. At\n/// the same index, insert `new_count` new elements, reading their values from the\n/// `new_contents` pointer.\n#define array_splice(self, _index, old_count, new_count, new_contents)  \\\n  _array__splice(                                                       \\\n    (Array *)(self), array_elem_size(self), _index,                \\\n    old_count, new_count, new_contents                                 \\\n  )\n\n/// Insert one `element` into the array at the given `index`.\n#define array_insert(self, _index, element) \\\n  _array__splice((Array *)(self), array_elem_size(self), _index, 0, 1, &(element))\n\n/// Remove one element from the array at the given `index`.\n#define array_erase(self, _index) \\\n  _array__erase((Array *)(self), array_elem_size(self), _index)\n\n/// Pop the last element off the array, returning the element by value.\n#define array_pop(self) ((self)->contents[--(self)->size])\n\n/// Assign the contents of one array to another, reallocating if necessary.\n#define array_assign(self, other) \\\n  _array__assign((Array *)(self), (const Array *)(other), array_elem_size(self))\n\n/// Swap one array with another\n#define array_swap(self, other) \\\n  _array__swap((Array *)(self), (Array *)(other))\n\n/// Get the size of the array contents\n#define array_elem_size(self) (sizeof *(self)->contents)\n\n/// Search a sorted array for a given `needle` value, using the given `compare`\n/// callback to determine the order.\n///\n/// If an existing element is found to be equal to `needle`, then the `index`\n/// out-parameter is set to the existing value's index, and the `exists`\n/// out-parameter is set to true. Otherwise, `index` is set to an index where\n/// `needle` should be inserted in order to preserve the sorting, and `exists`\n/// is set to false.\n#define array_search_sorted_with(self, compare, needle, _index, _exists) \\\n  _array__search_sorted(self, 0, compare, , needle, _index, _exists)\n\n/// Search a sorted array for a given `needle` value, using integer comparisons\n/// of a given struct field (specified with a leading dot) to determine the order.\n///\n/// See also `array_search_sorted_with`.\n#define array_search_sorted_by(self, field, needle, _index, _exists) \\\n  _array__search_sorted(self, 0, _compare_int, field, needle, _index, _exists)\n\n/// Insert a given `value` into a sorted array, using the given `compare`\n/// callback to determine the order.\n#define array_insert_sorted_with(self, compare, value) \\\n  do { \\\n    unsigned _index, _exists; \\\n    array_search_sorted_with(self, compare, &(value), &_index, &_exists); \\\n    if (!_exists) array_insert(self, _index, value); \\\n  } while (0)\n\n/// Insert a given `value` into a sorted array, using integer comparisons of\n/// a given struct field (specified with a leading dot) to determine the order.\n///\n/// See also `array_search_sorted_by`.\n#define array_insert_sorted_by(self, field, value) \\\n  do { \\\n    unsigned _index, _exists; \\\n    array_search_sorted_by(self, field, (value) field, &_index, &_exists); \\\n    if (!_exists) array_insert(self, _index, value); \\\n  } while (0)\n\n// Private\n\ntypedef Array(void) Array;\n\n/// This is not what you're looking for, see `array_delete`.\nstatic inline void _array__delete(Array *self) {\n  if (self->contents) {\n    ts_free(self->contents);\n    self->contents = NULL;\n    self->size = 0;\n    self->capacity = 0;\n  }\n}\n\n/// This is not what you're looking for, see `array_erase`.\nstatic inline void _array__erase(Array *self, size_t element_size,\n                                uint32_t index) {\n  ts_assert(index < self->size);\n  char *contents = (char *)self->contents;\n  memmove(contents + index * element_size, contents + (index + 1) * element_size,\n          (self->size - index - 1) * element_size);\n  self->size--;\n}\n\n/// This is not what you're looking for, see `array_reserve`.\nstatic inline void _array__reserve(Array *self, size_t element_size, uint32_t new_capacity) {\n  if (new_capacity > self->capacity) {\n    if (self->contents) {\n      self->contents = ts_realloc(self->contents, new_capacity * element_size);\n    } else {\n      self->contents = ts_malloc(new_capacity * element_size);\n    }\n    self->capacity = new_capacity;\n  }\n}\n\n/// This is not what you're looking for, see `array_assign`.\nstatic inline void _array__assign(Array *self, const Array *other, size_t element_size) {\n  _array__reserve(self, element_size, other->size);\n  self->size = other->size;\n  memcpy(self->contents, other->contents, self->size * element_size);\n}\n\n/// This is not what you're looking for, see `array_swap`.\nstatic inline void _array__swap(Array *self, Array *other) {\n  Array swap = *other;\n  *other = *self;\n  *self = swap;\n}\n\n/// This is not what you're looking for, see `array_push` or `array_grow_by`.\nstatic inline void _array__grow(Array *self, uint32_t count, size_t element_size) {\n  uint32_t new_size = self->size + count;\n  if (new_size > self->capacity) {\n    uint32_t new_capacity = self->capacity * 2;\n    if (new_capacity < 8) new_capacity = 8;\n    if (new_capacity < new_size) new_capacity = new_size;\n    _array__reserve(self, element_size, new_capacity);\n  }\n}\n\n/// This is not what you're looking for, see `array_splice`.\nstatic inline void _array__splice(Array *self, size_t element_size,\n                                 uint32_t index, uint32_t old_count,\n                                 uint32_t new_count, const void *elements) {\n  uint32_t new_size = self->size + new_count - old_count;\n  uint32_t old_end = index + old_count;\n  uint32_t new_end = index + new_count;\n  ts_assert(old_end <= self->size);\n\n  _array__reserve(self, element_size, new_size);\n\n  char *contents = (char *)self->contents;\n  if (self->size > old_end) {\n    memmove(\n      contents + new_end * element_size,\n      contents + old_end * element_size,\n      (self->size - old_end) * element_size\n    );\n  }\n  if (new_count > 0) {\n    if (elements) {\n      memcpy(\n        (contents + index * element_size),\n        elements,\n        new_count * element_size\n      );\n    } else {\n      memset(\n        (contents + index * element_size),\n        0,\n        new_count * element_size\n      );\n    }\n  }\n  self->size += new_count - old_count;\n}\n\n/// A binary search routine, based on Rust's `std::slice::binary_search_by`.\n/// This is not what you're looking for, see `array_search_sorted_with` or `array_search_sorted_by`.\n#define _array__search_sorted(self, start, compare, suffix, needle, _index, _exists) \\\n  do { \\\n    *(_index) = start; \\\n    *(_exists) = false; \\\n    uint32_t size = (self)->size - *(_index); \\\n    if (size == 0) break; \\\n    int comparison; \\\n    while (size > 1) { \\\n      uint32_t half_size = size / 2; \\\n      uint32_t mid_index = *(_index) + half_size; \\\n      comparison = compare(&((self)->contents[mid_index] suffix), (needle)); \\\n      if (comparison <= 0) *(_index) = mid_index; \\\n      size -= half_size; \\\n    } \\\n    comparison = compare(&((self)->contents[*(_index)] suffix), (needle)); \\\n    if (comparison == 0) *(_exists) = true; \\\n    else if (comparison < 0) *(_index) += 1; \\\n  } while (0)\n\n/// Helper macro for the `_sorted_by` routines below. This takes the left (existing)\n/// parameter by reference in order to work with the generic sorting function above.\n#define _compare_int(a, b) ((int)*(a) - (int)(b))\n\n#ifdef _MSC_VER\n#pragma warning(pop)\n#elif defined(__GNUC__) || defined(__clang__)\n#pragma GCC diagnostic pop\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  // TREE_SITTER_ARRAY_H_\n",
    "#ifndef TREE_SITTER_LENGTH_H_\n#define TREE_SITTER_LENGTH_H_\n\n#include <stdlib.h>\n#include <stdbool.h>\n#include \"./point.h\"\n#include \"tree_sitter/api.h\"\n\ntypedef struct {\n  uint32_t bytes;\n  TSPoint extent;\n} Length;\n\nstatic const Length LENGTH_UNDEFINED = {0, {0, 1}};\nstatic const Length LENGTH_MAX = {UINT32_MAX, {UINT32_MAX, UINT32_MAX}};\n\nstatic inline bool length_is_undefined(Length length) {\n  return length.bytes == 0 && length.extent.column != 0;\n}\n\nstatic inline Length length_min(Length len1, Length len2) {\n  return (len1.bytes < len2.bytes) ? len1 : len2;\n}\n\nstatic inline Length length_add(Length len1, Length len2) {\n  Length result;\n  result.bytes = len1.bytes + len2.bytes;\n  result.extent = point_add(len1.extent, len2.extent);\n  return result;\n}\n\nstatic inline Length length_sub(Length len1, Length len2) {\n  Length result;\n  result.bytes = (len1.bytes >= len2.bytes) ? len1.bytes - len2.bytes : 0;\n  result.extent = point_sub(len1.extent, len2.extent);\n  return result;\n}\n\nstatic inline Length length_zero(void) {\n  Length result = {0, {0, 0}};\n  return result;\n}\n\nstatic inline Length length_saturating_sub(Length len1, Length len2) {\n  if (len1.bytes > len2.bytes) {\n    return length_sub(len1, len2);\n  } else {\n    return length_zero();\n  }\n}\n\n#endif\n",
    "#ifndef TREE_SITTER_SUBTREE_H_\n#define TREE_SITTER_SUBTREE_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <limits.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include \"./length.h\"\n#include \"./array.h\"\n#include \"./error_costs.h\"\n#include \"./host.h\"\n#include \"tree_sitter/api.h\"\n#include \"./parser.h\"\n\n#define TS_TREE_STATE_NONE USHRT_MAX\n#define NULL_SUBTREE ((Subtree) {.ptr = NULL})\n\n// The serialized state of an external scanner.\n//\n// Every time an external token subtree is created after a call to an\n// external scanner, the scanner's `serialize` function is called to\n// retrieve a serialized copy of its state. The bytes are then copied\n// onto the subtree itself so that the scanner's state can later be\n// restored using its `deserialize` function.\n//\n// Small byte arrays are stored inline, and long ones are allocated\n// separately on the heap.\ntypedef struct {\n  union {\n    char *long_data;\n    char short_data[24];\n  };\n  uint32_t length;\n} ExternalScannerState;\n\n// A compact representation of a subtree.\n//\n// This representation is used for small leaf nodes that are not\n// errors, and were not created by an external scanner.\n//\n// The idea behind the layout of this struct is that the `is_inline`\n// bit will fall exactly into the same location as the least significant\n// bit of the pointer in `Subtree` or `MutableSubtree`, respectively.\n// Because of alignment, for any valid pointer this will be 0, giving\n// us the opportunity to make use of this bit to signify whether to use\n// the pointer or the inline struct.\ntypedef struct SubtreeInlineData SubtreeInlineData;\n\n#define SUBTREE_BITS    \\\n  bool visible : 1;     \\\n  bool named : 1;       \\\n  bool extra : 1;       \\\n  bool has_changes : 1; \\\n  bool is_missing : 1;  \\\n  bool is_keyword : 1;\n\n#define SUBTREE_SIZE           \\\n  uint8_t padding_columns;     \\\n  uint8_t padding_rows : 4;    \\\n  uint8_t lookahead_bytes : 4; \\\n  uint8_t padding_bytes;       \\\n  uint8_t size_bytes;\n\n#if TS_BIG_ENDIAN\n#if TS_PTR_SIZE == 32\n\nstruct SubtreeInlineData {\n  uint16_t parse_state;\n  uint8_t symbol;\n  SUBTREE_BITS\n  bool unused : 1;\n  bool is_inline : 1;\n  SUBTREE_SIZE\n};\n\n#else\n\nstruct SubtreeInlineData {\n  SUBTREE_SIZE\n  uint16_t parse_state;\n  uint8_t symbol;\n  SUBTREE_BITS\n  bool unused : 1;\n  bool is_inline : 1;\n};\n\n#endif\n#else\n\nstruct SubtreeInlineData {\n  bool is_inline : 1;\n  SUBTREE_BITS\n  uint8_t symbol;\n  uint16_t parse_state;\n  SUBTREE_SIZE\n};\n\n#endif\n\n#undef SUBTREE_BITS\n#undef SUBTREE_SIZE\n\n// A heap-allocated representation of a subtree.\n//\n// This representation is used for parent nodes, external tokens,\n// errors, and other leaf nodes whose data is too large to fit into\n// the inline representation.\ntypedef struct {\n  volatile uint32_t ref_count;\n  Length padding;\n  Length size;\n  uint32_t lookahead_bytes;\n  uint32_t error_cost;\n  uint32_t child_count;\n  TSSymbol symbol;\n  TSStateId parse_state;\n\n  bool visible : 1;\n  bool named : 1;\n  bool extra : 1;\n  bool fragile_left : 1;\n  bool fragile_right : 1;\n  bool has_changes : 1;\n  bool has_external_tokens : 1;\n  bool has_external_scanner_state_change : 1;\n  bool depends_on_column: 1;\n  bool is_missing : 1;\n  bool is_keyword : 1;\n\n  union {\n    // Non-terminal subtrees (`child_count > 0`)\n    struct {\n      uint32_t visible_child_count;\n      uint32_t named_child_count;\n      uint32_t visible_descendant_count;\n      int32_t dynamic_precedence;\n      uint16_t repeat_depth;\n      uint16_t production_id;\n      struct {\n        TSSymbol symbol;\n        TSStateId parse_state;\n      } first_leaf;\n    };\n\n    // External terminal subtrees (`child_count == 0 && has_external_tokens`)\n    ExternalScannerState external_scanner_state;\n\n    // Error terminal subtrees (`child_count == 0 && symbol == ts_builtin_sym_error`)\n    int32_t lookahead_char;\n  };\n} SubtreeHeapData;\n\n// The fundamental building block of a syntax tree.\ntypedef union {\n  SubtreeInlineData data;\n  const SubtreeHeapData *ptr;\n} Subtree;\n\n// Like Subtree, but mutable.\ntypedef union {\n  SubtreeInlineData data;\n  SubtreeHeapData *ptr;\n} MutableSubtree;\n\ntypedef Array(Subtree) SubtreeArray;\ntypedef Array(MutableSubtree) MutableSubtreeArray;\n\ntypedef struct {\n  MutableSubtreeArray free_trees;\n  MutableSubtreeArray tree_stack;\n} SubtreePool;\n\nvoid ts_external_scanner_state_init(ExternalScannerState *self, const char *data, unsigned length);\nconst char *ts_external_scanner_state_data(const ExternalScannerState *self);\nbool ts_external_scanner_state_eq(const ExternalScannerState *self, const char *buffer, unsigned length);\nvoid ts_external_scanner_state_delete(ExternalScannerState *self);\n\nvoid ts_subtree_array_copy(SubtreeArray self, SubtreeArray *dest);\nvoid ts_subtree_array_clear(SubtreePool *pool, SubtreeArray *self);\nvoid ts_subtree_array_delete(SubtreePool *pool, SubtreeArray *self);\nvoid ts_subtree_array_remove_trailing_extras(SubtreeArray *self, SubtreeArray *destination);\nvoid ts_subtree_array_reverse(SubtreeArray *self);\n\nSubtreePool ts_subtree_pool_new(uint32_t capacity);\nvoid ts_subtree_pool_delete(SubtreePool *self);\n\nSubtree ts_subtree_new_leaf(\n  SubtreePool *pool, TSSymbol symbol, Length padding, Length size,\n  uint32_t lookahead_bytes, TSStateId parse_state,\n  bool has_external_tokens, bool depends_on_column,\n  bool is_keyword, const TSLanguage *language\n);\nSubtree ts_subtree_new_error(\n  SubtreePool *pool, int32_t lookahead_char, Length padding, Length size,\n  uint32_t bytes_scanned, TSStateId parse_state, const TSLanguage *language\n);\nMutableSubtree ts_subtree_new_node(\n  TSSymbol symbol,\n  SubtreeArray *chiildren,\n  unsigned production_id,\n  const TSLanguage *language\n);\nSubtree ts_subtree_new_error_node(\n  SubtreeArray *children,\n  bool extra,\n  const TSLanguage * language\n);\nSubtree ts_subtree_new_missing_leaf(\n  SubtreePool *pool,\n  TSSymbol symbol,\n  Length padding,\n  uint32_t lookahead_bytes,\n  const TSLanguage *language\n);\nMutableSubtree ts_subtree_make_mut(SubtreePool *pool, Subtree self);\nvoid ts_subtree_retain(Subtree self);\nvoid ts_subtree_release(SubtreePool *pool, Subtree self);\nint ts_subtree_compare(Subtree left, Subtree right, SubtreePool *pool);\nvoid ts_subtree_set_symbol(MutableSubtree *self, TSSymbol symbol, const TSLanguage *language);\nvoid ts_subtree_compress(MutableSubtree self, unsigned count, const TSLanguage *language, MutableSubtreeArray *stack);\nvoid ts_subtree_summarize_children(MutableSubtree self, const TSLanguage *language);\nSubtree ts_subtree_edit(Subtree self, const TSInputEdit *edit, SubtreePool *pool);\nchar *ts_subtree_string(Subtree self, TSSymbol alias_symbol, bool alias_is_named, const TSLanguage *language, bool include_all);\nvoid ts_subtree_print_dot_graph(Subtree self, const TSLanguage *language, FILE *f);\nSubtree ts_subtree_last_external_token(Subtree tree);\nconst ExternalScannerState *ts_subtree_external_scanner_state(Subtree self);\nbool ts_subtree_external_scanner_state_eq(Subtree self, Subtree other);\n\n#define SUBTREE_GET(self, name) ((self).data.is_inline ? (self).data.name : (self).ptr->name)\n\nstatic inline TSSymbol ts_subtree_symbol(Subtree self) { return SUBTREE_GET(self, symbol); }\nstatic inline bool ts_subtree_visible(Subtree self) { return SUBTREE_GET(self, visible); }\nstatic inline bool ts_subtree_named(Subtree self) { return SUBTREE_GET(self, named); }\nstatic inline bool ts_subtree_extra(Subtree self) { return SUBTREE_GET(self, extra); }\nstatic inline bool ts_subtree_has_changes(Subtree self) { return SUBTREE_GET(self, has_changes); }\nstatic inline bool ts_subtree_missing(Subtree self) { return SUBTREE_GET(self, is_missing); }\nstatic inline bool ts_subtree_is_keyword(Subtree self) { return SUBTREE_GET(self, is_keyword); }\nstatic inline TSStateId ts_subtree_parse_state(Subtree self) { return SUBTREE_GET(self, parse_state); }\nstatic inline uint32_t ts_subtree_lookahead_bytes(Subtree self) { return SUBTREE_GET(self, lookahead_bytes); }\n\n#undef SUBTREE_GET\n\n// Get the size needed to store a heap-allocated subtree with the given\n// number of children.\nstatic inline size_t ts_subtree_alloc_size(uint32_t child_count) {\n  return child_count * sizeof(Subtree) + sizeof(SubtreeHeapData);\n}\n\n// Get a subtree's children, which are allocated immediately before the\n// tree's own heap data.\n#define ts_subtree_children(self) \\\n  ((self).data.is_inline ? NULL : (Subtree *)((self).ptr) - (self).ptr->child_count)\n\nstatic inline void ts_subtree_set_extra(MutableSubtree *self, bool is_extra) {\n  if (self->data.is_inline) {\n    self->data.extra = is_extra;\n  } else {\n    self->ptr->extra = is_extra;\n  }\n}\n\nstatic inline TSSymbol ts_subtree_leaf_symbol(Subtree self) {\n  if (self.data.is_inline) return self.data.symbol;\n  if (self.ptr->child_count == 0) return self.ptr->symbol;\n  return self.ptr->first_leaf.symbol;\n}\n\nstatic inline TSStateId ts_subtree_leaf_parse_state(Subtree self) {\n  if (self.data.is_inline) return self.data.parse_state;\n  if (self.ptr->child_count == 0) return self.ptr->parse_state;\n  return self.ptr->first_leaf.parse_state;\n}\n\nstatic inline Length ts_subtree_padding(Subtree self) {\n  if (self.data.is_inline) {\n    Length result = {self.data.padding_bytes, {self.data.padding_rows, self.data.padding_columns}};\n    return result;\n  } else {\n    return self.ptr->padding;\n  }\n}\n\nstatic inline Length ts_subtree_size(Subtree self) {\n  if (self.data.is_inline) {\n    Length result = {self.data.size_bytes, {0, self.data.size_bytes}};\n    return result;\n  } else {\n    return self.ptr->size;\n  }\n}\n\nstatic inline Length ts_subtree_total_size(Subtree self) {\n  return length_add(ts_subtree_padding(self), ts_subtree_size(self));\n}\n\nstatic inline uint32_t ts_subtree_total_bytes(Subtree self) {\n  return ts_subtree_total_size(self).bytes;\n}\n\nstatic inline uint32_t ts_subtree_child_count(Subtree self) {\n  return self.data.is_inline ? 0 : self.ptr->child_count;\n}\n\nstatic inline uint32_t ts_subtree_repeat_depth(Subtree self) {\n  return self.data.is_inline ? 0 : self.ptr->repeat_depth;\n}\n\nstatic inline uint32_t ts_subtree_is_repetition(Subtree self) {\n  return self.data.is_inline\n    ? 0\n    : !self.ptr->named && !self.ptr->visible && self.ptr->child_count != 0;\n}\n\nstatic inline uint32_t ts_subtree_visible_descendant_count(Subtree self) {\n  return (self.data.is_inline || self.ptr->child_count == 0)\n    ? 0\n    : self.ptr->visible_descendant_count;\n}\n\nstatic inline uint32_t ts_subtree_visible_child_count(Subtree self) {\n  if (ts_subtree_child_count(self) > 0) {\n    return self.ptr->visible_child_count;\n  } else {\n    return 0;\n  }\n}\n\nstatic inline uint32_t ts_subtree_error_cost(Subtree self) {\n  if (ts_subtree_missing(self)) {\n    return ERROR_COST_PER_MISSING_TREE + ERROR_COST_PER_RECOVERY;\n  } else {\n    return self.data.is_inline ? 0 : self.ptr->error_cost;\n  }\n}\n\nstatic inline int32_t ts_subtree_dynamic_precedence(Subtree self) {\n  return (self.data.is_inline || self.ptr->child_count == 0) ? 0 : self.ptr->dynamic_precedence;\n}\n\nstatic inline uint16_t ts_subtree_production_id(Subtree self) {\n  if (ts_subtree_child_count(self) > 0) {\n    return self.ptr->production_id;\n  } else {\n    return 0;\n  }\n}\n\nstatic inline bool ts_subtree_fragile_left(Subtree self) {\n  return self.data.is_inline ? false : self.ptr->fragile_left;\n}\n\nstatic inline bool ts_subtree_fragile_right(Subtree self) {\n  return self.data.is_inline ? false : self.ptr->fragile_right;\n}\n\nstatic inline bool ts_subtree_has_external_tokens(Subtree self) {\n  return self.data.is_inline ? false : self.ptr->has_external_tokens;\n}\n\nstatic inline bool ts_subtree_has_external_scanner_state_change(Subtree self) {\n  return self.data.is_inline ? false : self.ptr->has_external_scanner_state_change;\n}\n\nstatic inline bool ts_subtree_depends_on_column(Subtree self) {\n  return self.data.is_inline ? false : self.ptr->depends_on_column;\n}\n\nstatic inline bool ts_subtree_is_fragile(Subtree self) {\n  return self.data.is_inline ? false : (self.ptr->fragile_left || self.ptr->fragile_right);\n}\n\nstatic inline bool ts_subtree_is_error(Subtree self) {\n  return ts_subtree_symbol(self) == ts_builtin_sym_error;\n}\n\nstatic inline bool ts_subtree_is_eof(Subtree self) {\n  return ts_subtree_symbol(self) == ts_builtin_sym_end;\n}\n\nstatic inline Subtree ts_subtree_from_mut(MutableSubtree self) {\n  Subtree result;\n  result.data = self.data;\n  return result;\n}\n\nstatic inline MutableSubtree ts_subtree_to_mut_unsafe(Subtree self) {\n  MutableSubtree result;\n  result.data = self.data;\n  return result;\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  // TREE_SITTER_SUBTREE_H_\n",
    "#ifndef TREE_SITTER_POINT_H_\n#define TREE_SITTER_POINT_H_\n\n#include \"tree_sitter/api.h\"\n\n#define POINT_ZERO ((TSPoint) {0, 0})\n#define POINT_MAX ((TSPoint) {UINT32_MAX, UINT32_MAX})\n\nstatic inline TSPoint point__new(unsigned row, unsigned column) {\n  TSPoint result = {row, column};\n  return result;\n}\n\nstatic inline TSPoint point_add(TSPoint a, TSPoint b) {\n  if (b.row > 0)\n    return point__new(a.row + b.row, b.column);\n  else\n    return point__new(a.row, a.column + b.column);\n}\n\nstatic inline TSPoint point_sub(TSPoint a, TSPoint b) {\n  if (a.row > b.row)\n    return point__new(a.row - b.row, a.column);\n  else\n    return point__new(0, (a.column >= b.column) ? a.column - b.column : 0);\n}\n\nstatic inline bool point_lte(TSPoint a, TSPoint b) {\n  return (a.row < b.row) || (a.row == b.row && a.column <= b.column);\n}\n\nstatic inline bool point_lt(TSPoint a, TSPoint b) {\n  return (a.row < b.row) || (a.row == b.row && a.column < b.column);\n}\n\nstatic inline bool point_gt(TSPoint a, TSPoint b) {\n  return (a.row > b.row) || (a.row == b.row && a.column > b.column);\n}\n\nstatic inline bool point_gte(TSPoint a, TSPoint b) {\n  return (a.row > b.row) || (a.row == b.row && a.column >= b.column);\n}\n\nstatic inline bool point_eq(TSPoint a, TSPoint b) {\n  return a.row == b.row && a.column == b.column;\n}\n\n#endif\n",
    "#ifndef TREE_SITTER_LANGUAGE_H_\n#define TREE_SITTER_LANGUAGE_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"./subtree.h\"\n#include \"./parser.h\"\n\n#define ts_builtin_sym_error_repeat (ts_builtin_sym_error - 1)\n\n#define LANGUAGE_VERSION_WITH_RESERVED_WORDS 15\n#define LANGUAGE_VERSION_WITH_PRIMARY_STATES 14\n\ntypedef struct {\n  const TSParseAction *actions;\n  uint32_t action_count;\n  bool is_reusable;\n} TableEntry;\n\ntypedef struct {\n  const TSLanguage *language;\n  const uint16_t *data;\n  const uint16_t *group_end;\n  TSStateId state;\n  uint16_t table_value;\n  uint16_t section_index;\n  uint16_t group_count;\n  bool is_small_state;\n\n  const TSParseAction *actions;\n  TSSymbol symbol;\n  TSStateId next_state;\n  uint16_t action_count;\n} LookaheadIterator;\n\nvoid ts_language_table_entry(const TSLanguage *self, TSStateId state, TSSymbol symbol, TableEntry *result);\nTSLexerMode ts_language_lex_mode_for_state(const TSLanguage *self, TSStateId state);\nbool ts_language_is_reserved_word(const TSLanguage *self, TSStateId state, TSSymbol symbol);\nTSSymbolMetadata ts_language_symbol_metadata(const TSLanguage *self, TSSymbol symbol);\nTSSymbol ts_language_public_symbol(const TSLanguage *self, TSSymbol symbol);\n\nstatic inline const TSParseAction *ts_language_actions(\n  const TSLanguage *self,\n  TSStateId state,\n  TSSymbol symbol,\n  uint32_t *count\n) {\n  TableEntry entry;\n  ts_language_table_entry(self, state, symbol, &entry);\n  *count = entry.action_count;\n  return entry.actions;\n}\n\nstatic inline bool ts_language_has_reduce_action(\n  const TSLanguage *self,\n  TSStateId state,\n  TSSymbol symbol\n) {\n  TableEntry entry;\n  ts_language_table_entry(self, state, symbol, &entry);\n  return entry.action_count > 0 && entry.actions[0].type == TSParseActionTypeReduce;\n}\n\n// Lookup the table value for a given symbol and state.\n//\n// For non-terminal symbols, the table value represents a successor state.\n// For terminal symbols, it represents an index in the actions table.\n// For 'large' parse states, this is a direct lookup. For 'small' parse\n// states, this requires searching through the symbol groups to find\n// the given symbol.\nstatic inline uint16_t ts_language_lookup(\n  const TSLanguage *self,\n  TSStateId state,\n  TSSymbol symbol\n) {\n  if (state >= self->large_state_count) {\n    uint32_t index = self->small_parse_table_map[state - self->large_state_count];\n    const uint16_t *data = &self->small_parse_table[index];\n    uint16_t group_count = *(data++);\n    for (unsigned i = 0; i < group_count; i++) {\n      uint16_t section_value = *(data++);\n      uint16_t symbol_count = *(data++);\n      for (unsigned j = 0; j < symbol_count; j++) {\n        if (*(data++) == symbol) return section_value;\n      }\n    }\n    return 0;\n  } else {\n    return self->parse_table[state * self->symbol_count + symbol];\n  }\n}\n\nstatic inline bool ts_language_has_actions(\n  const TSLanguage *self,\n  TSStateId state,\n  TSSymbol symbol\n) {\n  return ts_language_lookup(self, state, symbol) != 0;\n}\n\n// Iterate over all of the symbols that are valid in the given state.\n//\n// For 'large' parse states, this just requires iterating through\n// all possible symbols and checking the parse table for each one.\n// For 'small' parse states, this exploits the structure of the\n// table to only visit the valid symbols.\nstatic inline LookaheadIterator ts_language_lookaheads(\n  const TSLanguage *self,\n  TSStateId state\n) {\n  bool is_small_state = state >= self->large_state_count;\n  const uint16_t *data;\n  const uint16_t *group_end = NULL;\n  uint16_t group_count = 0;\n  if (is_small_state) {\n    uint32_t index = self->small_parse_table_map[state - self->large_state_count];\n    data = &self->small_parse_table[index];\n    group_end = data + 1;\n    group_count = *data;\n  } else {\n    data = &self->parse_table[state * self->symbol_count] - 1;\n  }\n  return (LookaheadIterator) {\n    .language = self,\n    .data = data,\n    .group_end = group_end,\n    .group_count = group_count,\n    .is_small_state = is_small_state,\n    .symbol = UINT16_MAX,\n    .next_state = 0,\n  };\n}\n\nstatic inline bool ts_lookahead_iterator__next(LookaheadIterator *self) {\n  // For small parse states, valid symbols are listed explicitly,\n  // grouped by their value. There's no need to look up the actions\n  // again until moving to the next group.\n  if (self->is_small_state) {\n    self->data++;\n    if (self->data == self->group_end) {\n      if (self->group_count == 0) return false;\n      self->group_count--;\n      self->table_value = *(self->data++);\n      unsigned symbol_count = *(self->data++);\n      self->group_end = self->data + symbol_count;\n      self->symbol = *self->data;\n    } else {\n      self->symbol = *self->data;\n      return true;\n    }\n  }\n\n  // For large parse states, iterate through every symbol until one\n  // is found that has valid actions.\n  else {\n    do {\n      self->data++;\n      self->symbol++;\n      if (self->symbol >= self->language->symbol_count) return false;\n      self->table_value = *self->data;\n    } while (!self->table_value);\n  }\n\n  // Depending on if the symbols is terminal or non-terminal, the table value either\n  // represents a list of actions or a successor state.\n  if (self->symbol < self->language->token_count) {\n    const TSParseActionEntry *entry = &self->language->parse_actions[self->table_value];\n    self->action_count = entry->entry.count;\n    self->actions = (const TSParseAction *)(entry + 1);\n    self->next_state = 0;\n  } else {\n    self->action_count = 0;\n    self->next_state = self->table_value;\n  }\n  return true;\n}\n\n// Whether the state is a \"primary state\". If this returns false, it indicates that there exists\n// another state that behaves identically to this one with respect to query analysis.\nstatic inline bool ts_language_state_is_primary(\n  const TSLanguage *self,\n  TSStateId state\n) {\n  if (self->abi_version >= LANGUAGE_VERSION_WITH_PRIMARY_STATES) {\n    return state == self->primary_state_ids[state];\n  } else {\n    return true;\n  }\n}\n\nstatic inline const bool *ts_language_enabled_external_tokens(\n  const TSLanguage *self,\n  unsigned external_scanner_state\n) {\n  if (external_scanner_state == 0) {\n    return NULL;\n  } else {\n    return self->external_scanner.states + self->external_token_count * external_scanner_state;\n  }\n}\n\nstatic inline const TSSymbol *ts_language_alias_sequence(\n  const TSLanguage *self,\n  uint32_t production_id\n) {\n  return production_id ?\n    &self->alias_sequences[production_id * self->max_alias_sequence_length] :\n    NULL;\n}\n\nstatic inline TSSymbol ts_language_alias_at(\n  const TSLanguage *self,\n  uint32_t production_id,\n  uint32_t child_index\n) {\n  return production_id ?\n    self->alias_sequences[production_id * self->max_alias_sequence_length + child_index] :\n    0;\n}\n\nstatic inline void ts_language_field_map(\n  const TSLanguage *self,\n  uint32_t production_id,\n  const TSFieldMapEntry **start,\n  const TSFieldMapEntry **end\n) {\n  if (self->field_count == 0) {\n    *start = NULL;\n    *end = NULL;\n    return;\n  }\n\n  TSMapSlice slice = self->field_map_slices[production_id];\n  *start = &self->field_map_entries[slice.index];\n  *end = &self->field_map_entries[slice.index] + slice.length;\n}\n\nstatic inline void ts_language_aliases_for_symbol(\n  const TSLanguage *self,\n  TSSymbol original_symbol,\n  const TSSymbol **start,\n  const TSSymbol **end\n) {\n  *start = &self->public_symbol_map[original_symbol];\n  *end = *start + 1;\n\n  unsigned idx = 0;\n  for (;;) {\n    TSSymbol symbol = self->alias_map[idx++];\n    if (symbol == 0 || symbol > original_symbol) break;\n    uint16_t count = self->alias_map[idx++];\n    if (symbol == original_symbol) {\n      *start = &self->alias_map[idx];\n      *end = &self->alias_map[idx + count];\n      break;\n    }\n    idx += count;\n  }\n}\n\nstatic inline void ts_language_write_symbol_as_dot_string(\n  const TSLanguage *self,\n  FILE *f,\n  TSSymbol symbol\n) {\n  const char *name = ts_language_symbol_name(self, symbol);\n  for (const char *chr = name; *chr; chr++) {\n    switch (*chr) {\n      case '\"':\n      case '\\\\':\n        fputc('\\\\', f);\n        fputc(*chr, f);\n        break;\n      case '\\n':\n        fputs(\"\\\\n\", f);\n        break;\n      case '\\t':\n        fputs(\"\\\\t\", f);\n        break;\n      default:\n        fputc(*chr, f);\n        break;\n    }\n  }\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  // TREE_SITTER_LANGUAGE_H_\n",
    "#include <ctype.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n#include <stdio.h>\n#include \"./alloc.h\"\n#include \"./array.h\"\n#include \"./atomic.h\"\n#include \"./subtree.h\"\n#include \"./length.h\"\n#include \"./language.h\"\n#include \"./error_costs.h\"\n#include \"./ts_assert.h\"\n#include <stddef.h>\n\ntypedef struct {\n  Length start;\n  Length old_end;\n  Length new_end;\n} Edit;\n\n#define TS_MAX_INLINE_TREE_LENGTH UINT8_MAX\n#define TS_MAX_TREE_POOL_SIZE 32\n\n// ExternalScannerState\n\nvoid ts_external_scanner_state_init(ExternalScannerState *self, const char *data, unsigned length) {\n  self->length = length;\n  if (length > sizeof(self->short_data)) {\n    self->long_data = ts_malloc(length);\n    memcpy(self->long_data, data, length);\n  } else {\n    memcpy(self->short_data, data, length);\n  }\n}\n\nExternalScannerState ts_external_scanner_state_copy(const ExternalScannerState *self) {\n  ExternalScannerState result = *self;\n  if (self->length > sizeof(self->short_data)) {\n    result.long_data = ts_malloc(self->length);\n    memcpy(result.long_data, self->long_data, self->length);\n  }\n  return result;\n}\n\nvoid ts_external_scanner_state_delete(ExternalScannerState *self) {\n  if (self->length > sizeof(self->short_data)) {\n    ts_free(self->long_data);\n  }\n}\n\nconst char *ts_external_scanner_state_data(const ExternalScannerState *self) {\n  if (self->length > sizeof(self->short_data)) {\n    return self->long_data;\n  } else {\n    return self->short_data;\n  }\n}\n\nbool ts_external_scanner_state_eq(const ExternalScannerState *self, const char *buffer, unsigned length) {\n  return\n    self->length == length &&\n    memcmp(ts_external_scanner_state_data(self), buffer, length) == 0;\n}\n\n// SubtreeArray\n\nvoid ts_subtree_array_copy(SubtreeArray self, SubtreeArray *dest) {\n  dest->size = self.size;\n  dest->capacity = self.capacity;\n  dest->contents = self.contents;\n  if (self.capacity > 0) {\n    dest->contents = ts_calloc(self.capacity, sizeof(Subtree));\n    memcpy(dest->contents, self.contents, self.size * sizeof(Subtree));\n    for (uint32_t i = 0; i < self.size; i++) {\n      ts_subtree_retain(*array_get(dest, i));\n    }\n  }\n}\n\nvoid ts_subtree_array_clear(SubtreePool *pool, SubtreeArray *self) {\n  for (uint32_t i = 0; i < self->size; i++) {\n    ts_subtree_release(pool, *array_get(self, i));\n  }\n  array_clear(self);\n}\n\nvoid ts_subtree_array_delete(SubtreePool *pool, SubtreeArray *self) {\n  ts_subtree_array_clear(pool, self);\n  array_delete(self);\n}\n\nvoid ts_subtree_array_remove_trailing_extras(\n  SubtreeArray *self,\n  SubtreeArray *destination\n) {\n  array_clear(destination);\n  while (self->size > 0) {\n    Subtree last = *array_get(self, self->size - 1);\n    if (ts_subtree_extra(last)) {\n      self->size--;\n      array_push(destination, last);\n    } else {\n      break;\n    }\n  }\n  ts_subtree_array_reverse(destination);\n}\n\nvoid ts_subtree_array_reverse(SubtreeArray *self) {\n  for (uint32_t i = 0, limit = self->size / 2; i < limit; i++) {\n    size_t reverse_index = self->size - 1 - i;\n    Subtree swap = *array_get(self, i);\n    *array_get(self, i) = *array_get(self, reverse_index);\n    *array_get(self, reverse_index) = swap;\n  }\n}\n\n// SubtreePool\n\nSubtreePool ts_subtree_pool_new(uint32_t capacity) {\n  SubtreePool self = {array_new(), array_new()};\n  array_reserve(&self.free_trees, capacity);\n  return self;\n}\n\nvoid ts_subtree_pool_delete(SubtreePool *self) {\n  if (self->free_trees.contents) {\n    for (unsigned i = 0; i < self->free_trees.size; i++) {\n      ts_free(array_get(&self->free_trees, i)->ptr);\n    }\n    array_delete(&self->free_trees);\n  }\n  if (self->tree_stack.contents) array_delete(&self->tree_stack);\n}\n\nstatic SubtreeHeapData *ts_subtree_pool_allocate(SubtreePool *self) {\n  if (self->free_trees.size > 0) {\n    return array_pop(&self->free_trees).ptr;\n  } else {\n    return ts_malloc(sizeof(SubtreeHeapData));\n  }\n}\n\nstatic void ts_subtree_pool_free(SubtreePool *self, SubtreeHeapData *tree) {\n  if (self->free_trees.capacity > 0 && self->free_trees.size + 1 <= TS_MAX_TREE_POOL_SIZE) {\n    array_push(&self->free_trees, (MutableSubtree) {.ptr = tree});\n  } else {\n    ts_free(tree);\n  }\n}\n\n// Subtree\n\nstatic inline bool ts_subtree_can_inline(Length padding, Length size, uint32_t lookahead_bytes) {\n  return\n    padding.bytes < TS_MAX_INLINE_TREE_LENGTH &&\n    padding.extent.row < 16 &&\n    padding.extent.column < TS_MAX_INLINE_TREE_LENGTH &&\n    size.bytes < TS_MAX_INLINE_TREE_LENGTH &&\n    size.extent.row == 0 &&\n    size.extent.column < TS_MAX_INLINE_TREE_LENGTH &&\n    lookahead_bytes < 16;\n}\n\nSubtree ts_subtree_new_leaf(\n  SubtreePool *pool, TSSymbol symbol, Length padding, Length size,\n  uint32_t lookahead_bytes, TSStateId parse_state,\n  bool has_external_tokens, bool depends_on_column,\n  bool is_keyword, const TSLanguage *language\n) {\n  TSSymbolMetadata metadata = ts_language_symbol_metadata(language, symbol);\n  bool extra = symbol == ts_builtin_sym_end;\n\n  bool is_inline = (\n    symbol <= UINT8_MAX &&\n    !has_external_tokens &&\n    ts_subtree_can_inline(padding, size, lookahead_bytes)\n  );\n\n  if (is_inline) {\n    return (Subtree) {{\n      .parse_state = parse_state,\n      .symbol = symbol,\n      .padding_bytes = padding.bytes,\n      .padding_rows = padding.extent.row,\n      .padding_columns = padding.extent.column,\n      .size_bytes = size.bytes,\n      .lookahead_bytes = lookahead_bytes,\n      .visible = metadata.visible,\n      .named = metadata.named,\n      .extra = extra,\n      .has_changes = false,\n      .is_missing = false,\n      .is_keyword = is_keyword,\n      .is_inline = true,\n    }};\n  } else {\n    SubtreeHeapData *data = ts_subtree_pool_allocate(pool);\n    *data = (SubtreeHeapData) {\n      .ref_count = 1,\n      .padding = padding,\n      .size = size,\n      .lookahead_bytes = lookahead_bytes,\n      .error_cost = 0,\n      .child_count = 0,\n      .symbol = symbol,\n      .parse_state = parse_state,\n      .visible = metadata.visible,\n      .named = metadata.named,\n      .extra = extra,\n      .fragile_left = false,\n      .fragile_right = false,\n      .has_changes = false,\n      .has_external_tokens = has_external_tokens,\n      .has_external_scanner_state_change = false,\n      .depends_on_column = depends_on_column,\n      .is_missing = false,\n      .is_keyword = is_keyword,\n      {{.first_leaf = {.symbol = 0, .parse_state = 0}}}\n    };\n    return (Subtree) {.ptr = data};\n  }\n}\n\nvoid ts_subtree_set_symbol(\n  MutableSubtree *self,\n  TSSymbol symbol,\n  const TSLanguage *language\n) {\n  TSSymbolMetadata metadata = ts_language_symbol_metadata(language, symbol);\n  if (self->data.is_inline) {\n    ts_assert(symbol < UINT8_MAX);\n    self->data.symbol = symbol;\n    self->data.named = metadata.named;\n    self->data.visible = metadata.visible;\n  } else {\n    self->ptr->symbol = symbol;\n    self->ptr->named = metadata.named;\n    self->ptr->visible = metadata.visible;\n  }\n}\n\nSubtree ts_subtree_new_error(\n  SubtreePool *pool, int32_t lookahead_char, Length padding, Length size,\n  uint32_t bytes_scanned, TSStateId parse_state, const TSLanguage *language\n) {\n  Subtree result = ts_subtree_new_leaf(\n    pool, ts_builtin_sym_error, padding, size, bytes_scanned,\n    parse_state, false, false, false, language\n  );\n  SubtreeHeapData *data = (SubtreeHeapData *)result.ptr;\n  data->fragile_left = true;\n  data->fragile_right = true;\n  data->lookahead_char = lookahead_char;\n  return result;\n}\n\n// Clone a subtree.\nMutableSubtree ts_subtree_clone(Subtree self) {\n  size_t alloc_size = ts_subtree_alloc_size(self.ptr->child_count);\n  Subtree *new_children = ts_malloc(alloc_size);\n  Subtree *old_children = ts_subtree_children(self);\n  memcpy(new_children, old_children, alloc_size);\n  SubtreeHeapData *result = (SubtreeHeapData *)&new_children[self.ptr->child_count];\n  if (self.ptr->child_count > 0) {\n    for (uint32_t i = 0; i < self.ptr->child_count; i++) {\n      ts_subtree_retain(new_children[i]);\n    }\n  } else if (self.ptr->has_external_tokens) {\n    result->external_scanner_state = ts_external_scanner_state_copy(\n      &self.ptr->external_scanner_state\n    );\n  }\n  result->ref_count = 1;\n  return (MutableSubtree) {.ptr = result};\n}\n\n// Get mutable version of a subtree.\n//\n// This takes ownership of the subtree. If the subtree has only one owner,\n// this will directly convert it into a mutable version. Otherwise, it will\n// perform a copy.\nMutableSubtree ts_subtree_make_mut(SubtreePool *pool, Subtree self) {\n  if (self.data.is_inline) return (MutableSubtree) {self.data};\n  if (self.ptr->ref_count == 1) return ts_subtree_to_mut_unsafe(self);\n  MutableSubtree result = ts_subtree_clone(self);\n  ts_subtree_release(pool, self);\n  return result;\n}\n\nvoid ts_subtree_compress(\n  MutableSubtree self,\n  unsigned count,\n  const TSLanguage *language,\n  MutableSubtreeArray *stack\n) {\n  unsigned initial_stack_size = stack->size;\n\n  MutableSubtree tree = self;\n  TSSymbol symbol = tree.ptr->symbol;\n  for (unsigned i = 0; i < count; i++) {\n    if (tree.ptr->ref_count > 1 || tree.ptr->child_count < 2) break;\n\n    MutableSubtree child = ts_subtree_to_mut_unsafe(ts_subtree_children(tree)[0]);\n    if (\n      child.data.is_inline ||\n      child.ptr->child_count < 2 ||\n      child.ptr->ref_count > 1 ||\n      child.ptr->symbol != symbol\n    ) break;\n\n    MutableSubtree grandchild = ts_subtree_to_mut_unsafe(ts_subtree_children(child)[0]);\n    if (\n      grandchild.data.is_inline ||\n      grandchild.ptr->child_count < 2 ||\n      grandchild.ptr->ref_count > 1 ||\n      grandchild.ptr->symbol != symbol\n    ) break;\n\n    ts_subtree_children(tree)[0] = ts_subtree_from_mut(grandchild);\n    ts_subtree_children(child)[0] = ts_subtree_children(grandchild)[grandchild.ptr->child_count - 1];\n    ts_subtree_children(grandchild)[grandchild.ptr->child_count - 1] = ts_subtree_from_mut(child);\n    array_push(stack, tree);\n    tree = grandchild;\n  }\n\n  while (stack->size > initial_stack_size) {\n    tree = array_pop(stack);\n    MutableSubtree child = ts_subtree_to_mut_unsafe(ts_subtree_children(tree)[0]);\n    MutableSubtree grandchild = ts_subtree_to_mut_unsafe(ts_subtree_children(child)[child.ptr->child_count - 1]);\n    ts_subtree_summarize_children(grandchild, language);\n    ts_subtree_summarize_children(child, language);\n    ts_subtree_summarize_children(tree, language);\n  }\n}\n\n// Assign all of the node's properties that depend on its children.\nvoid ts_subtree_summarize_children(\n  MutableSubtree self,\n  const TSLanguage *language\n) {\n  ts_assert(!self.data.is_inline);\n\n  self.ptr->named_child_count = 0;\n  self.ptr->visible_child_count = 0;\n  self.ptr->error_cost = 0;\n  self.ptr->repeat_depth = 0;\n  self.ptr->visible_descendant_count = 0;\n  self.ptr->has_external_tokens = false;\n  self.ptr->depends_on_column = false;\n  self.ptr->has_external_scanner_state_change = false;\n  self.ptr->dynamic_precedence = 0;\n\n  uint32_t structural_index = 0;\n  const TSSymbol *alias_sequence = ts_language_alias_sequence(language, self.ptr->production_id);\n  uint32_t lookahead_end_byte = 0;\n\n  const Subtree *children = ts_subtree_children(self);\n  for (uint32_t i = 0; i < self.ptr->child_count; i++) {\n    Subtree child = children[i];\n\n    if (\n      self.ptr->size.extent.row == 0 &&\n      ts_subtree_depends_on_column(child)\n    ) {\n      self.ptr->depends_on_column = true;\n    }\n\n    if (ts_subtree_has_external_scanner_state_change(child)) {\n      self.ptr->has_external_scanner_state_change = true;\n    }\n\n    if (i == 0) {\n      self.ptr->padding = ts_subtree_padding(child);\n      self.ptr->size = ts_subtree_size(child);\n    } else {\n      self.ptr->size = length_add(self.ptr->size, ts_subtree_total_size(child));\n    }\n\n    uint32_t child_lookahead_end_byte =\n      self.ptr->padding.bytes +\n      self.ptr->size.bytes +\n      ts_subtree_lookahead_bytes(child);\n    if (child_lookahead_end_byte > lookahead_end_byte) {\n      lookahead_end_byte = child_lookahead_end_byte;\n    }\n\n    if (ts_subtree_symbol(child) != ts_builtin_sym_error_repeat) {\n      self.ptr->error_cost += ts_subtree_error_cost(child);\n    }\n\n    uint32_t grandchild_count = ts_subtree_child_count(child);\n    if (\n      self.ptr->symbol == ts_builtin_sym_error ||\n      self.ptr->symbol == ts_builtin_sym_error_repeat\n    ) {\n      if (!ts_subtree_extra(child) && !(ts_subtree_is_error(child) && grandchild_count == 0)) {\n        if (ts_subtree_visible(child)) {\n          self.ptr->error_cost += ERROR_COST_PER_SKIPPED_TREE;\n        } else if (grandchild_count > 0) {\n          self.ptr->error_cost += ERROR_COST_PER_SKIPPED_TREE * child.ptr->visible_child_count;\n        }\n      }\n    }\n\n    self.ptr->dynamic_precedence += ts_subtree_dynamic_precedence(child);\n    self.ptr->visible_descendant_count += ts_subtree_visible_descendant_count(child);\n\n    if (\n      !ts_subtree_extra(child) &&\n      ts_subtree_symbol(child) != 0 &&\n      alias_sequence &&\n      alias_sequence[structural_index] != 0\n    ) {\n      self.ptr->visible_descendant_count++;\n      self.ptr->visible_child_count++;\n      if (ts_language_symbol_metadata(language, alias_sequence[structural_index]).named) {\n        self.ptr->named_child_count++;\n      }\n    } else if (ts_subtree_visible(child)) {\n      self.ptr->visible_descendant_count++;\n      self.ptr->visible_child_count++;\n      if (ts_subtree_named(child)) self.ptr->named_child_count++;\n    } else if (grandchild_count > 0) {\n      self.ptr->visible_child_count += child.ptr->visible_child_count;\n      self.ptr->named_child_count += child.ptr->named_child_count;\n    }\n\n    if (ts_subtree_has_external_tokens(child)) self.ptr->has_external_tokens = true;\n\n    if (ts_subtree_is_error(child)) {\n      self.ptr->fragile_left = self.ptr->fragile_right = true;\n      self.ptr->parse_state = TS_TREE_STATE_NONE;\n    }\n\n    if (!ts_subtree_extra(child)) structural_index++;\n  }\n\n  self.ptr->lookahead_bytes = lookahead_end_byte - self.ptr->size.bytes - self.ptr->padding.bytes;\n\n  if (\n    self.ptr->symbol == ts_builtin_sym_error ||\n    self.ptr->symbol == ts_builtin_sym_error_repeat\n  ) {\n    self.ptr->error_cost +=\n      ERROR_COST_PER_RECOVERY +\n      ERROR_COST_PER_SKIPPED_CHAR * self.ptr->size.bytes +\n      ERROR_COST_PER_SKIPPED_LINE * self.ptr->size.extent.row;\n  }\n\n  if (self.ptr->child_count > 0) {\n    Subtree first_child = children[0];\n    Subtree last_child = children[self.ptr->child_count - 1];\n\n    self.ptr->first_leaf.symbol = ts_subtree_leaf_symbol(first_child);\n    self.ptr->first_leaf.parse_state = ts_subtree_leaf_parse_state(first_child);\n\n    if (ts_subtree_fragile_left(first_child)) self.ptr->fragile_left = true;\n    if (ts_subtree_fragile_right(last_child)) self.ptr->fragile_right = true;\n\n    if (\n      self.ptr->child_count >= 2 &&\n      !self.ptr->visible &&\n      !self.ptr->named &&\n      ts_subtree_symbol(first_child) == self.ptr->symbol\n    ) {\n      if (ts_subtree_repeat_depth(first_child) > ts_subtree_repeat_depth(last_child)) {\n        self.ptr->repeat_depth = ts_subtree_repeat_depth(first_child) + 1;\n      } else {\n        self.ptr->repeat_depth = ts_subtree_repeat_depth(last_child) + 1;\n      }\n    }\n  }\n}\n\n// Create a new parent node with the given children.\n//\n// This takes ownership of the children array.\nMutableSubtree ts_subtree_new_node(\n  TSSymbol symbol,\n  SubtreeArray *children,\n  unsigned production_id,\n  const TSLanguage *language\n) {\n  TSSymbolMetadata metadata = ts_language_symbol_metadata(language, symbol);\n  bool fragile = symbol == ts_builtin_sym_error || symbol == ts_builtin_sym_error_repeat;\n\n  // Allocate the node's data at the end of the array of children.\n  size_t new_byte_size = ts_subtree_alloc_size(children->size);\n  if (children->capacity * sizeof(Subtree) < new_byte_size) {\n    children->contents = ts_realloc(children->contents, new_byte_size);\n    children->capacity = (uint32_t)(new_byte_size / sizeof(Subtree));\n  }\n  SubtreeHeapData *data = (SubtreeHeapData *)&children->contents[children->size];\n\n  *data = (SubtreeHeapData) {\n    .ref_count = 1,\n    .symbol = symbol,\n    .child_count = children->size,\n    .visible = metadata.visible,\n    .named = metadata.named,\n    .has_changes = false,\n    .has_external_scanner_state_change = false,\n    .fragile_left = fragile,\n    .fragile_right = fragile,\n    .is_keyword = false,\n    {{\n      .visible_descendant_count = 0,\n      .production_id = production_id,\n      .first_leaf = {.symbol = 0, .parse_state = 0},\n    }}\n  };\n  MutableSubtree result = {.ptr = data};\n  ts_subtree_summarize_children(result, language);\n  return result;\n}\n\n// Create a new error node containing the given children.\n//\n// This node is treated as 'extra'. Its children are prevented from having\n// having any effect on the parse state.\nSubtree ts_subtree_new_error_node(\n  SubtreeArray *children,\n  bool extra,\n  const TSLanguage *language\n) {\n  MutableSubtree result = ts_subtree_new_node(\n    ts_builtin_sym_error, children, 0, language\n  );\n  result.ptr->extra = extra;\n  return ts_subtree_from_mut(result);\n}\n\n// Create a new 'missing leaf' node.\n//\n// This node is treated as 'extra'. Its children are prevented from having\n// having any effect on the parse state.\nSubtree ts_subtree_new_missing_leaf(\n  SubtreePool *pool,\n  TSSymbol symbol,\n  Length padding,\n  uint32_t lookahead_bytes,\n  const TSLanguage *language\n) {\n  Subtree result = ts_subtree_new_leaf(\n    pool, symbol, padding, length_zero(), lookahead_bytes,\n    0, false, false, false, language\n  );\n  if (result.data.is_inline) {\n    result.data.is_missing = true;\n  } else {\n    ((SubtreeHeapData *)result.ptr)->is_missing = true;\n  }\n  return result;\n}\n\nvoid ts_subtree_retain(Subtree self) {\n  if (self.data.is_inline) return;\n  ts_assert(self.ptr->ref_count > 0);\n  atomic_inc((volatile uint32_t *)&self.ptr->ref_count);\n  ts_assert(self.ptr->ref_count != 0);\n}\n\nvoid ts_subtree_release(SubtreePool *pool, Subtree self) {\n  if (self.data.is_inline) return;\n  array_clear(&pool->tree_stack);\n\n  ts_assert(self.ptr->ref_count > 0);\n  if (atomic_dec((volatile uint32_t *)&self.ptr->ref_count) == 0) {\n    array_push(&pool->tree_stack, ts_subtree_to_mut_unsafe(self));\n  }\n\n  while (pool->tree_stack.size > 0) {\n    MutableSubtree tree = array_pop(&pool->tree_stack);\n    if (tree.ptr->child_count > 0) {\n      Subtree *children = ts_subtree_children(tree);\n      for (uint32_t i = 0; i < tree.ptr->child_count; i++) {\n        Subtree child = children[i];\n        if (child.data.is_inline) continue;\n        ts_assert(child.ptr->ref_count > 0);\n        if (atomic_dec((volatile uint32_t *)&child.ptr->ref_count) == 0) {\n          array_push(&pool->tree_stack, ts_subtree_to_mut_unsafe(child));\n        }\n      }\n      ts_free(children);\n    } else {\n      if (tree.ptr->has_external_tokens) {\n        ts_external_scanner_state_delete(&tree.ptr->external_scanner_state);\n      }\n      ts_subtree_pool_free(pool, tree.ptr);\n    }\n  }\n}\n\nint ts_subtree_compare(Subtree left, Subtree right, SubtreePool *pool) {\n  array_push(&pool->tree_stack, ts_subtree_to_mut_unsafe(left));\n  array_push(&pool->tree_stack, ts_subtree_to_mut_unsafe(right));\n\n  while (pool->tree_stack.size > 0) {\n    right = ts_subtree_from_mut(array_pop(&pool->tree_stack));\n    left = ts_subtree_from_mut(array_pop(&pool->tree_stack));\n\n    int result = 0;\n    if (ts_subtree_symbol(left) < ts_subtree_symbol(right)) result = -1;\n    else if (ts_subtree_symbol(right) < ts_subtree_symbol(left)) result = 1;\n    else if (ts_subtree_child_count(left) < ts_subtree_child_count(right)) result = -1;\n    else if (ts_subtree_child_count(right) < ts_subtree_child_count(left)) result = 1;\n    if (result != 0) {\n      array_clear(&pool->tree_stack);\n      return result;\n    }\n\n    for (uint32_t i = ts_subtree_child_count(left); i > 0; i--) {\n      Subtree left_child = ts_subtree_children(left)[i - 1];\n      Subtree right_child = ts_subtree_children(right)[i - 1];\n      array_push(&pool->tree_stack, ts_subtree_to_mut_unsafe(left_child));\n      array_push(&pool->tree_stack, ts_subtree_to_mut_unsafe(right_child));\n    }\n  }\n\n  return 0;\n}\n\nstatic inline void ts_subtree_set_has_changes(MutableSubtree *self) {\n  if (self->data.is_inline) {\n    self->data.has_changes = true;\n  } else {\n    self->ptr->has_changes = true;\n  }\n}\n\nSubtree ts_subtree_edit(Subtree self, const TSInputEdit *input_edit, SubtreePool *pool) {\n  typedef struct {\n    Subtree *tree;\n    Edit edit;\n  } EditEntry;\n\n  Array(EditEntry) stack = array_new();\n  array_push(&stack, ((EditEntry) {\n    .tree = &self,\n    .edit = (Edit) {\n      .start = {input_edit->start_byte, input_edit->start_point},\n      .old_end = {input_edit->old_end_byte, input_edit->old_end_point},\n      .new_end = {input_edit->new_end_byte, input_edit->new_end_point},\n    },\n  }));\n\n  while (stack.size) {\n    EditEntry entry = array_pop(&stack);\n    Edit edit = entry.edit;\n    bool is_noop = edit.old_end.bytes == edit.start.bytes && edit.new_end.bytes == edit.start.bytes;\n    bool is_pure_insertion = edit.old_end.bytes == edit.start.bytes;\n    bool parent_depends_on_column = ts_subtree_depends_on_column(*entry.tree);\n    bool column_shifted = edit.new_end.extent.column != edit.old_end.extent.column;\n\n    Length size = ts_subtree_size(*entry.tree);\n    Length padding = ts_subtree_padding(*entry.tree);\n    Length total_size = length_add(padding, size);\n    uint32_t lookahead_bytes = ts_subtree_lookahead_bytes(*entry.tree);\n    uint32_t end_byte = total_size.bytes + lookahead_bytes;\n    if (edit.start.bytes > end_byte || (is_noop && edit.start.bytes == end_byte)) continue;\n\n    // If the edit is entirely within the space before this subtree, then shift this\n    // subtree over according to the edit without changing its size.\n    if (edit.old_end.bytes <= padding.bytes) {\n      padding = length_add(edit.new_end, length_sub(padding, edit.old_end));\n    }\n\n    // If the edit starts in the space before this subtree and extends into this subtree,\n    // shrink the subtree's content to compensate for the change in the space before it.\n    else if (edit.start.bytes < padding.bytes) {\n      size = length_saturating_sub(size, length_sub(edit.old_end, padding));\n      padding = edit.new_end;\n    }\n\n    // If the edit is within this subtree, resize the subtree to reflect the edit.\n    else if (\n      edit.start.bytes < total_size.bytes ||\n      (edit.start.bytes == total_size.bytes && is_pure_insertion)\n    ) {\n      size = length_add(\n        length_sub(edit.new_end, padding),\n        length_saturating_sub(total_size, edit.old_end)\n      );\n    }\n\n    MutableSubtree result = ts_subtree_make_mut(pool, *entry.tree);\n\n    if (result.data.is_inline) {\n      if (ts_subtree_can_inline(padding, size, lookahead_bytes)) {\n        result.data.padding_bytes = padding.bytes;\n        result.data.padding_rows = padding.extent.row;\n        result.data.padding_columns = padding.extent.column;\n        result.data.size_bytes = size.bytes;\n      } else {\n        SubtreeHeapData *data = ts_subtree_pool_allocate(pool);\n        data->ref_count = 1;\n        data->padding = padding;\n        data->size = size;\n        data->lookahead_bytes = lookahead_bytes;\n        data->error_cost = 0;\n        data->child_count = 0;\n        data->symbol = result.data.symbol;\n        data->parse_state = result.data.parse_state;\n        data->visible = result.data.visible;\n        data->named = result.data.named;\n        data->extra = result.data.extra;\n        data->fragile_left = false;\n        data->fragile_right = false;\n        data->has_changes = false;\n        data->has_external_tokens = false;\n        data->depends_on_column = false;\n        data->is_missing = result.data.is_missing;\n        data->is_keyword = result.data.is_keyword;\n        result.ptr = data;\n      }\n    } else {\n      result.ptr->padding = padding;\n      result.ptr->size = size;\n    }\n\n    ts_subtree_set_has_changes(&result);\n    *entry.tree = ts_subtree_from_mut(result);\n\n    Length child_left, child_right = length_zero();\n    for (uint32_t i = 0, n = ts_subtree_child_count(*entry.tree); i < n; i++) {\n      Subtree *child = &ts_subtree_children(*entry.tree)[i];\n      Length child_size = ts_subtree_total_size(*child);\n      child_left = child_right;\n      child_right = length_add(child_left, child_size);\n\n      // If this child ends before the edit, it is not affected.\n      if (child_right.bytes + ts_subtree_lookahead_bytes(*child) < edit.start.bytes) continue;\n\n      // Keep editing child nodes until a node is reached that starts after the edit.\n      // Also, if this node's validity depends on its column position, then continue\n      // invalidating child nodes until reaching a line break.\n      if ((\n        (child_left.bytes > edit.old_end.bytes) ||\n        (child_left.bytes == edit.old_end.bytes && child_size.bytes > 0 && i > 0)\n      ) && (\n        !parent_depends_on_column ||\n        child_left.extent.row > padding.extent.row\n      ) && (\n        !ts_subtree_depends_on_column(*child) ||\n        !column_shifted ||\n        child_left.extent.row > edit.old_end.extent.row\n      )) {\n        break;\n      }\n\n      // Transform edit into the child's coordinate space.\n      Edit child_edit = {\n        .start = length_saturating_sub(edit.start, child_left),\n        .old_end = length_saturating_sub(edit.old_end, child_left),\n        .new_end = length_saturating_sub(edit.new_end, child_left),\n      };\n\n      // Interpret all inserted text as applying to the *first* child that touches the edit.\n      // Subsequent children are only never have any text inserted into them; they are only\n      // shrunk to compensate for the edit.\n      if (\n        child_right.bytes > edit.start.bytes ||\n        (child_right.bytes == edit.start.bytes && is_pure_insertion)\n      ) {\n        edit.new_end = edit.start;\n      }\n\n      // Children that occur before the edit are not reshaped by the edit.\n      else {\n        child_edit.old_end = child_edit.start;\n        child_edit.new_end = child_edit.start;\n      }\n\n      // Queue processing of this child's subtree.\n      array_push(&stack, ((EditEntry) {\n        .tree = child,\n        .edit = child_edit,\n      }));\n    }\n  }\n\n  array_delete(&stack);\n  return self;\n}\n\nSubtree ts_subtree_last_external_token(Subtree tree) {\n  if (!ts_subtree_has_external_tokens(tree)) return NULL_SUBTREE;\n  while (tree.ptr->child_count > 0) {\n    for (uint32_t i = tree.ptr->child_count - 1; i + 1 > 0; i--) {\n      Subtree child = ts_subtree_children(tree)[i];\n      if (ts_subtree_has_external_tokens(child)) {\n        tree = child;\n        break;\n      }\n    }\n  }\n  return tree;\n}\n\nstatic size_t ts_subtree__write_char_to_string(char *str, size_t n, int32_t chr) {\n  if (chr == -1)\n    return snprintf(str, n, \"INVALID\");\n  else if (chr == '\\0')\n    return snprintf(str, n, \"'\\\\0'\");\n  else if (chr == '\\n')\n    return snprintf(str, n, \"'\\\\n'\");\n  else if (chr == '\\t')\n    return snprintf(str, n, \"'\\\\t'\");\n  else if (chr == '\\r')\n    return snprintf(str, n, \"'\\\\r'\");\n  else if (0 < chr && chr < 128 && isprint(chr))\n    return snprintf(str, n, \"'%c'\", chr);\n  else\n    return snprintf(str, n, \"%d\", chr);\n}\n\nstatic const char *const ROOT_FIELD = \"__ROOT__\";\n\nstatic size_t ts_subtree__write_to_string(\n  Subtree self, char *string, size_t limit,\n  const TSLanguage *language, bool include_all,\n  TSSymbol alias_symbol, bool alias_is_named, const char *field_name\n) {\n  if (!self.ptr) return snprintf(string, limit, \"(NULL)\");\n\n  char *cursor = string;\n  char **writer = (limit > 1) ? &cursor : &string;\n  bool is_root = field_name == ROOT_FIELD;\n  bool is_visible =\n    include_all ||\n    ts_subtree_missing(self) ||\n    (\n      alias_symbol\n        ? alias_is_named\n        : ts_subtree_visible(self) && ts_subtree_named(self)\n    );\n\n  if (is_visible) {\n    if (!is_root) {\n      cursor += snprintf(*writer, limit, \" \");\n      if (field_name) {\n        cursor += snprintf(*writer, limit, \"%s: \", field_name);\n      }\n    }\n\n    if (ts_subtree_is_error(self) && ts_subtree_child_count(self) == 0 && self.ptr->size.bytes > 0) {\n      cursor += snprintf(*writer, limit, \"(UNEXPECTED \");\n      cursor += ts_subtree__write_char_to_string(*writer, limit, self.ptr->lookahead_char);\n    } else {\n      TSSymbol symbol = alias_symbol ? alias_symbol : ts_subtree_symbol(self);\n      const char *symbol_name = ts_language_symbol_name(language, symbol);\n      if (ts_subtree_missing(self)) {\n        cursor += snprintf(*writer, limit, \"(MISSING \");\n        if (alias_is_named || ts_subtree_named(self)) {\n          cursor += snprintf(*writer, limit, \"%s\", symbol_name);\n        } else {\n          cursor += snprintf(*writer, limit, \"\\\"%s\\\"\", symbol_name);\n        }\n      } else {\n        cursor += snprintf(*writer, limit, \"(%s\", symbol_name);\n      }\n    }\n  } else if (is_root) {\n    TSSymbol symbol = alias_symbol ? alias_symbol : ts_subtree_symbol(self);\n    const char *symbol_name = ts_language_symbol_name(language, symbol);\n    if (ts_subtree_child_count(self) > 0) {\n      cursor += snprintf(*writer, limit, \"(%s\", symbol_name);\n    } else if (ts_subtree_named(self)) {\n      cursor += snprintf(*writer, limit, \"(%s)\", symbol_name);\n    } else {\n      cursor += snprintf(*writer, limit, \"(\\\"%s\\\")\", symbol_name);\n    }\n  }\n\n  if (ts_subtree_child_count(self)) {\n    const TSSymbol *alias_sequence = ts_language_alias_sequence(language, self.ptr->production_id);\n    const TSFieldMapEntry *field_map, *field_map_end;\n    ts_language_field_map(\n      language,\n      self.ptr->production_id,\n      &field_map,\n      &field_map_end\n    );\n\n    uint32_t structural_child_index = 0;\n    for (uint32_t i = 0; i < self.ptr->child_count; i++) {\n      Subtree child = ts_subtree_children(self)[i];\n      if (ts_subtree_extra(child)) {\n        cursor += ts_subtree__write_to_string(\n          child, *writer, limit,\n          language, include_all,\n          0, false, NULL\n        );\n      } else {\n        TSSymbol subtree_alias_symbol = alias_sequence\n          ? alias_sequence[structural_child_index]\n          : 0;\n        bool subtree_alias_is_named = subtree_alias_symbol\n          ? ts_language_symbol_metadata(language, subtree_alias_symbol).named\n          : false;\n\n        const char *child_field_name = is_visible ? NULL : field_name;\n        for (const TSFieldMapEntry *map = field_map; map < field_map_end; map++) {\n          if (!map->inherited && map->child_index == structural_child_index) {\n            child_field_name = language->field_names[map->field_id];\n            break;\n          }\n        }\n\n        cursor += ts_subtree__write_to_string(\n          child, *writer, limit,\n          language, include_all,\n          subtree_alias_symbol, subtree_alias_is_named, child_field_name\n        );\n        structural_child_index++;\n      }\n    }\n  }\n\n  if (is_visible) cursor += snprintf(*writer, limit, \")\");\n\n  return cursor - string;\n}\n\nchar *ts_subtree_string(\n  Subtree self,\n  TSSymbol alias_symbol,\n  bool alias_is_named,\n  const TSLanguage *language,\n  bool include_all\n) {\n  char scratch_string[1];\n  size_t size = ts_subtree__write_to_string(\n    self, scratch_string, 1,\n    language, include_all,\n    alias_symbol, alias_is_named, ROOT_FIELD\n  ) + 1;\n  char *result = ts_malloc(size * sizeof(char));\n  ts_subtree__write_to_string(\n    self, result, size,\n    language, include_all,\n    alias_symbol, alias_is_named, ROOT_FIELD\n  );\n  return result;\n}\n\nvoid ts_subtree__print_dot_graph(const Subtree *self, uint32_t start_offset,\n                                 const TSLanguage *language, TSSymbol alias_symbol,\n                                 FILE *f) {\n  TSSymbol subtree_symbol = ts_subtree_symbol(*self);\n  TSSymbol symbol = alias_symbol ? alias_symbol : subtree_symbol;\n  uint32_t end_offset = start_offset + ts_subtree_total_bytes(*self);\n  fprintf(f, \"tree_%p [label=\\\"\", (void *)self);\n  ts_language_write_symbol_as_dot_string(language, f, symbol);\n  fprintf(f, \"\\\"\");\n\n  if (ts_subtree_child_count(*self) == 0) fprintf(f, \", shape=plaintext\");\n  if (ts_subtree_extra(*self)) fprintf(f, \", fontcolor=gray\");\n  if (ts_subtree_has_changes(*self)) fprintf(f, \", color=green, penwidth=2\");\n\n  fprintf(f, \", tooltip=\\\"\"\n    \"range: %u - %u\\n\"\n    \"state: %d\\n\"\n    \"error-cost: %u\\n\"\n    \"has-changes: %u\\n\"\n    \"depends-on-column: %u\\n\"\n    \"descendant-count: %u\\n\"\n    \"repeat-depth: %u\\n\"\n    \"lookahead-bytes: %u\",\n    start_offset, end_offset,\n    ts_subtree_parse_state(*self),\n    ts_subtree_error_cost(*self),\n    ts_subtree_has_changes(*self),\n    ts_subtree_depends_on_column(*self),\n    ts_subtree_visible_descendant_count(*self),\n    ts_subtree_repeat_depth(*self),\n    ts_subtree_lookahead_bytes(*self)\n  );\n\n  if (ts_subtree_is_error(*self) && ts_subtree_child_count(*self) == 0 && self->ptr->lookahead_char != 0) {\n    fprintf(f, \"\\ncharacter: '%c'\", self->ptr->lookahead_char);\n  }\n\n  fprintf(f, \"\\\"]\\n\");\n\n  uint32_t child_start_offset = start_offset;\n  uint32_t child_info_offset =\n    language->max_alias_sequence_length *\n    ts_subtree_production_id(*self);\n  for (uint32_t i = 0, n = ts_subtree_child_count(*self); i < n; i++) {\n    const Subtree *child = &ts_subtree_children(*self)[i];\n    TSSymbol subtree_alias_symbol = 0;\n    if (!ts_subtree_extra(*child) && child_info_offset) {\n      subtree_alias_symbol = language->alias_sequences[child_info_offset];\n      child_info_offset++;\n    }\n    ts_subtree__print_dot_graph(child, child_start_offset, language, subtree_alias_symbol, f);\n    fprintf(f, \"tree_%p -> tree_%p [tooltip=%u]\\n\", (void *)self, (void *)child, i);\n    child_start_offset += ts_subtree_total_bytes(*child);\n  }\n}\n\nvoid ts_subtree_print_dot_graph(Subtree self, const TSLanguage *language, FILE *f) {\n  fprintf(f, \"digraph tree {\\n\");\n  fprintf(f, \"edge [arrowhead=none]\\n\");\n  ts_subtree__print_dot_graph(&self, 0, language, 0, f);\n  fprintf(f, \"}\\n\");\n}\n\nconst ExternalScannerState *ts_subtree_external_scanner_state(Subtree self) {\n  static const ExternalScannerState empty_state = {{.short_data = {0}}, .length = 0};\n  if (\n    self.ptr &&\n    !self.data.is_inline &&\n    self.ptr->has_external_tokens &&\n    self.ptr->child_count == 0\n  ) {\n    return &self.ptr->external_scanner_state;\n  } else {\n    return &empty_state;\n  }\n}\n\nbool ts_subtree_external_scanner_state_eq(Subtree self, Subtree other) {\n  const ExternalScannerState *state_self = ts_subtree_external_scanner_state(self);\n  const ExternalScannerState *state_other = ts_subtree_external_scanner_state(other);\n  return ts_external_scanner_state_eq(\n    state_self,\n    ts_external_scanner_state_data(state_other),\n    state_other->length\n  );\n}\n",
    "#include \"./language.h\"\n#include \"./wasm_store.h\"\n#include \"tree_sitter/api.h\"\n#include <string.h>\n\nconst TSLanguage *ts_language_copy(const TSLanguage *self) {\n  if (self && ts_language_is_wasm(self)) {\n    ts_wasm_language_retain(self);\n  }\n  return self;\n}\n\nvoid ts_language_delete(const TSLanguage *self) {\n  if (self && ts_language_is_wasm(self)) {\n    ts_wasm_language_release(self);\n  }\n}\n\nuint32_t ts_language_symbol_count(const TSLanguage *self) {\n  return self->symbol_count + self->alias_count;\n}\n\nuint32_t ts_language_state_count(const TSLanguage *self) {\n  return self->state_count;\n}\n\nconst TSSymbol *ts_language_supertypes(const TSLanguage *self, uint32_t *length) {\n  if (self->abi_version >= LANGUAGE_VERSION_WITH_RESERVED_WORDS) {\n    *length = self->supertype_count;\n    return self->supertype_symbols;\n  } else {\n    *length = 0;\n    return NULL;\n  }\n}\n\nconst TSSymbol *ts_language_subtypes(\n  const TSLanguage *self,\n  TSSymbol supertype,\n  uint32_t *length\n) {\n  if (self->abi_version < LANGUAGE_VERSION_WITH_RESERVED_WORDS || !ts_language_symbol_metadata(self, supertype).supertype) {\n    *length = 0;\n    return NULL;\n  }\n\n  TSMapSlice slice = self->supertype_map_slices[supertype];\n  *length = slice.length;\n  return &self->supertype_map_entries[slice.index];\n}\n\nuint32_t ts_language_version(const TSLanguage *self) {\n  return self->abi_version;\n}\n\nuint32_t ts_language_abi_version(const TSLanguage *self) {\n  return self->abi_version;\n}\n\nconst TSLanguageMetadata *ts_language_metadata(const TSLanguage *self) {\n    return self->abi_version >= LANGUAGE_VERSION_WITH_RESERVED_WORDS ? &self->metadata : NULL;\n}\n\nconst char *ts_language_name(const TSLanguage *self) {\n  return self->abi_version >= LANGUAGE_VERSION_WITH_RESERVED_WORDS ? self->name : NULL;\n}\n\nuint32_t ts_language_field_count(const TSLanguage *self) {\n  return self->field_count;\n}\n\nvoid ts_language_table_entry(\n  const TSLanguage *self,\n  TSStateId state,\n  TSSymbol symbol,\n  TableEntry *result\n) {\n  if (symbol == ts_builtin_sym_error || symbol == ts_builtin_sym_error_repeat) {\n    result->action_count = 0;\n    result->is_reusable = false;\n    result->actions = NULL;\n  } else {\n    ts_assert(symbol < self->token_count);\n    uint32_t action_index = ts_language_lookup(self, state, symbol);\n    const TSParseActionEntry *entry = &self->parse_actions[action_index];\n    result->action_count = entry->entry.count;\n    result->is_reusable = entry->entry.reusable;\n    result->actions = (const TSParseAction *)(entry + 1);\n  }\n}\n\nTSLexerMode ts_language_lex_mode_for_state(\n   const TSLanguage *self,\n   TSStateId state\n) {\n  if (self->abi_version < 15) {\n    TSLexMode mode = ((const TSLexMode *)self->lex_modes)[state];\n    return (TSLexerMode) {\n      .lex_state = mode.lex_state,\n      .external_lex_state = mode.external_lex_state,\n      .reserved_word_set_id = 0,\n    };\n  } else {\n    return self->lex_modes[state];\n  }\n}\n\nbool ts_language_is_reserved_word(\n  const TSLanguage *self,\n  TSStateId state,\n  TSSymbol symbol\n) {\n  TSLexerMode lex_mode = ts_language_lex_mode_for_state(self, state);\n  if (lex_mode.reserved_word_set_id > 0) {\n    unsigned start = lex_mode.reserved_word_set_id * self->max_reserved_word_set_size;\n    unsigned end = start + self->max_reserved_word_set_size;\n    for (unsigned i = start; i < end; i++) {\n      if (self->reserved_words[i] == symbol) return true;\n      if (self->reserved_words[i] == 0) break;\n    }\n  }\n  return false;\n}\n\nTSSymbolMetadata ts_language_symbol_metadata(\n  const TSLanguage *self,\n  TSSymbol symbol\n) {\n  if (symbol == ts_builtin_sym_error)  {\n    return (TSSymbolMetadata) {.visible = true, .named = true};\n  } else if (symbol == ts_builtin_sym_error_repeat) {\n    return (TSSymbolMetadata) {.visible = false, .named = false};\n  } else {\n    return self->symbol_metadata[symbol];\n  }\n}\n\nTSSymbol ts_language_public_symbol(\n  const TSLanguage *self,\n  TSSymbol symbol\n) {\n  if (symbol == ts_builtin_sym_error) return symbol;\n  return self->public_symbol_map[symbol];\n}\n\nTSStateId ts_language_next_state(\n  const TSLanguage *self,\n  TSStateId state,\n  TSSymbol symbol\n) {\n  if (symbol == ts_builtin_sym_error || symbol == ts_builtin_sym_error_repeat) {\n    return 0;\n  } else if (symbol < self->token_count) {\n    uint32_t count;\n    const TSParseAction *actions = ts_language_actions(self, state, symbol, &count);\n    if (count > 0) {\n      TSParseAction action = actions[count - 1];\n      if (action.type == TSParseActionTypeShift) {\n        return action.shift.extra ? state : action.shift.state;\n      }\n    }\n    return 0;\n  } else {\n    return ts_language_lookup(self, state, symbol);\n  }\n}\n\nconst char *ts_language_symbol_name(\n  const TSLanguage *self,\n  TSSymbol symbol\n) {\n  if (symbol == ts_builtin_sym_error) {\n    return \"ERROR\";\n  } else if (symbol == ts_builtin_sym_error_repeat) {\n    return \"_ERROR\";\n  } else if (symbol < ts_language_symbol_count(self)) {\n    return self->symbol_names[symbol];\n  } else {\n    return NULL;\n  }\n}\n\nTSSymbol ts_language_symbol_for_name(\n  const TSLanguage *self,\n  const char *string,\n  uint32_t length,\n  bool is_named\n) {\n  if (is_named && !strncmp(string, \"ERROR\", length)) return ts_builtin_sym_error;\n  uint16_t count = (uint16_t)ts_language_symbol_count(self);\n  for (TSSymbol i = 0; i < count; i++) {\n    TSSymbolMetadata metadata = ts_language_symbol_metadata(self, i);\n    if ((!metadata.visible && !metadata.supertype) || metadata.named != is_named) continue;\n    const char *symbol_name = self->symbol_names[i];\n    if (!strncmp(symbol_name, string, length) && !symbol_name[length]) {\n      return self->public_symbol_map[i];\n    }\n  }\n  return 0;\n}\n\nTSSymbolType ts_language_symbol_type(\n  const TSLanguage *self,\n  TSSymbol symbol\n) {\n  TSSymbolMetadata metadata = ts_language_symbol_metadata(self, symbol);\n  if (metadata.named && metadata.visible) {\n    return TSSymbolTypeRegular;\n  } else if (metadata.visible) {\n    return TSSymbolTypeAnonymous;\n  } else if (metadata.supertype) {\n    return TSSymbolTypeSupertype;\n  } else {\n    return TSSymbolTypeAuxiliary;\n  }\n}\n\nconst char *ts_language_field_name_for_id(\n  const TSLanguage *self,\n  TSFieldId id\n) {\n  uint32_t count = ts_language_field_count(self);\n  if (count && id <= count) {\n    return self->field_names[id];\n  } else {\n    return NULL;\n  }\n}\n\nTSFieldId ts_language_field_id_for_name(\n  const TSLanguage *self,\n  const char *name,\n  uint32_t name_length\n) {\n  uint16_t count = (uint16_t)ts_language_field_count(self);\n  for (TSSymbol i = 1; i < count + 1; i++) {\n    switch (strncmp(name, self->field_names[i], name_length)) {\n      case 0:\n        if (self->field_names[i][name_length] == 0) return i;\n        break;\n      case -1:\n        return 0;\n      default:\n        break;\n    }\n  }\n  return 0;\n}\n\nTSLookaheadIterator *ts_lookahead_iterator_new(const TSLanguage *self, TSStateId state) {\n  if (state >= self->state_count) return NULL;\n  LookaheadIterator *iterator = ts_malloc(sizeof(LookaheadIterator));\n  *iterator = ts_language_lookaheads(self, state);\n  return (TSLookaheadIterator *)iterator;\n}\n\nvoid ts_lookahead_iterator_delete(TSLookaheadIterator *self) {\n  ts_free(self);\n}\n\nbool ts_lookahead_iterator_reset_state(TSLookaheadIterator * self, TSStateId state) {\n  LookaheadIterator *iterator = (LookaheadIterator *)self;\n  if (state >= iterator->language->state_count) return false;\n  *iterator = ts_language_lookaheads(iterator->language, state);\n  return true;\n}\n\nconst TSLanguage *ts_lookahead_iterator_language(const TSLookaheadIterator *self) {\n  const LookaheadIterator *iterator = (const LookaheadIterator *)self;\n  return iterator->language;\n}\n\nbool ts_lookahead_iterator_reset(TSLookaheadIterator *self, const TSLanguage *language, TSStateId state) {\n  if (state >= language->state_count) return false;\n  LookaheadIterator *iterator = (LookaheadIterator *)self;\n  *iterator = ts_language_lookaheads(language, state);\n  return true;\n}\n\nbool ts_lookahead_iterator_next(TSLookaheadIterator *self) {\n  LookaheadIterator *iterator = (LookaheadIterator *)self;\n  return ts_lookahead_iterator__next(iterator);\n}\n\nTSSymbol ts_lookahead_iterator_current_symbol(const TSLookaheadIterator *self) {\n  const LookaheadIterator *iterator = (const LookaheadIterator *)self;\n  return iterator->symbol;\n}\n\nconst char *ts_lookahead_iterator_current_symbol_name(const TSLookaheadIterator *self) {\n  const LookaheadIterator *iterator = (const LookaheadIterator *)self;\n  return ts_language_symbol_name(iterator->language, iterator->symbol);\n}\n",
    "#include \"./length.h\"\n#include \"./lexer.h\"\n#include \"./unicode.h\"\n\n#include \"tree_sitter/api.h\"\n\n#include <stdarg.h>\n#include <stdio.h>\n\n#define LOG(message, character)              \\\n  if (self->logger.log) {                    \\\n    snprintf(                                \\\n      self->debug_buffer,                    \\\n      TREE_SITTER_SERIALIZATION_BUFFER_SIZE, \\\n      32 <= character && character < 127 ?   \\\n        message \" character:'%c'\" :          \\\n        message \" character:%d\",             \\\n      character                              \\\n    );                                       \\\n    self->logger.log(                        \\\n      self->logger.payload,                  \\\n      TSLogTypeLex,                          \\\n      self->debug_buffer                     \\\n    );                                       \\\n  }\n\nstatic const int32_t BYTE_ORDER_MARK = 0xFEFF;\n\nstatic const TSRange DEFAULT_RANGE = {\n  .start_point = {\n    .row = 0,\n    .column = 0,\n  },\n  .end_point = {\n    .row = UINT32_MAX,\n    .column = UINT32_MAX,\n  },\n  .start_byte = 0,\n  .end_byte = UINT32_MAX\n};\n\n/**\n * Sets the column data to the given value and marks it valid.\n * @param self The lexer state.\n * @param val The new value of the column data.\n */\nstatic void ts_lexer__set_column_data(Lexer *self, uint32_t val) {\n  self->column_data.valid = true;\n  self->column_data.value = val;\n}\n\n/**\n * Increments the value of the column data; no-op if invalid.\n * @param self The lexer state.\n */\nstatic void ts_lexer__increment_column_data(Lexer *self) {\n  if (self->column_data.valid) {\n    self->column_data.value++;\n  }\n}\n\n/**\n * Marks the column data as invalid.\n * @param self The lexer state.\n */\nstatic void ts_lexer__invalidate_column_data(Lexer *self) {\n  self->column_data.valid = false;\n  self->column_data.value = 0;\n}\n\n// Check if the lexer has reached EOF. This state is stored\n// by setting the lexer's `current_included_range_index` such that\n// it has consumed all of its available ranges.\nstatic bool ts_lexer__eof(const TSLexer *_self) {\n  Lexer *self = (Lexer *)_self;\n  return self->current_included_range_index == self->included_range_count;\n}\n\n// Clear the currently stored chunk of source code, because the lexer's\n// position has changed.\nstatic void ts_lexer__clear_chunk(Lexer *self) {\n  self->chunk = NULL;\n  self->chunk_size = 0;\n  self->chunk_start = 0;\n}\n\n// Call the lexer's input callback to obtain a new chunk of source code\n// for the current position.\nstatic void ts_lexer__get_chunk(Lexer *self) {\n  self->chunk_start = self->current_position.bytes;\n  self->chunk = self->input.read(\n    self->input.payload,\n    self->current_position.bytes,\n    self->current_position.extent,\n    &self->chunk_size\n  );\n  if (!self->chunk_size) {\n    self->current_included_range_index = self->included_range_count;\n    self->chunk = NULL;\n  }\n}\n\n// Decode the next unicode character in the current chunk of source code.\n// This assumes that the lexer has already retrieved a chunk of source\n// code that spans the current position.\nstatic void ts_lexer__get_lookahead(Lexer *self) {\n  uint32_t position_in_chunk = self->current_position.bytes - self->chunk_start;\n  uint32_t size = self->chunk_size - position_in_chunk;\n\n  if (size == 0) {\n    self->lookahead_size = 1;\n    self->data.lookahead = '\\0';\n    return;\n  }\n\n  const uint8_t *chunk = (const uint8_t *)self->chunk + position_in_chunk;\n  TSDecodeFunction decode =\n    self->input.encoding == TSInputEncodingUTF8    ? ts_decode_utf8     :\n    self->input.encoding == TSInputEncodingUTF16LE ? ts_decode_utf16_le :\n    self->input.encoding == TSInputEncodingUTF16BE ? ts_decode_utf16_be : self->input.decode;\n\n  self->lookahead_size = decode(chunk, size, &self->data.lookahead);\n\n  // If this chunk ended in the middle of a multi-byte character,\n  // try again with a fresh chunk.\n  if (self->data.lookahead == TS_DECODE_ERROR && size < 4) {\n    ts_lexer__get_chunk(self);\n    chunk = (const uint8_t *)self->chunk;\n    size = self->chunk_size;\n    self->lookahead_size = decode(chunk, size, &self->data.lookahead);\n  }\n\n  if (self->data.lookahead == TS_DECODE_ERROR) {\n    self->lookahead_size = 1;\n  }\n}\n\nstatic void ts_lexer_goto(Lexer *self, Length position) {\n  if (position.bytes != self->current_position.bytes) {\n    ts_lexer__invalidate_column_data(self);\n  }\n\n  self->current_position = position;\n\n  // Move to the first valid position at or after the given position.\n  bool found_included_range = false;\n  for (unsigned i = 0; i < self->included_range_count; i++) {\n    TSRange *included_range = &self->included_ranges[i];\n    if (\n      included_range->end_byte > self->current_position.bytes &&\n      included_range->end_byte > included_range->start_byte\n    ) {\n      if (included_range->start_byte >= self->current_position.bytes) {\n        self->current_position = (Length) {\n          .bytes = included_range->start_byte,\n          .extent = included_range->start_point,\n        };\n      }\n\n      self->current_included_range_index = i;\n      found_included_range = true;\n      break;\n    }\n  }\n\n  if (found_included_range) {\n    // If the current position is outside of the current chunk of text,\n    // then clear out the current chunk of text.\n    if (self->chunk && (\n      self->current_position.bytes < self->chunk_start ||\n      self->current_position.bytes >= self->chunk_start + self->chunk_size\n    )) {\n      ts_lexer__clear_chunk(self);\n    }\n\n    self->lookahead_size = 0;\n    self->data.lookahead = '\\0';\n  }\n\n  // If the given position is beyond any of included ranges, move to the EOF\n  // state - past the end of the included ranges.\n  else {\n    self->current_included_range_index = self->included_range_count;\n    TSRange *last_included_range = &self->included_ranges[self->included_range_count - 1];\n    self->current_position = (Length) {\n      .bytes = last_included_range->end_byte,\n      .extent = last_included_range->end_point,\n    };\n    ts_lexer__clear_chunk(self);\n    self->lookahead_size = 1;\n    self->data.lookahead = '\\0';\n  }\n}\n\n/**\n * Actually advances the lexer. Does not log anything.\n * @param self The lexer state.\n * @param skip Whether to mark the consumed codepoint as whitespace.\n */\nstatic void ts_lexer__do_advance(Lexer *self, bool skip) {\n  if (self->lookahead_size) {\n    if (self->data.lookahead == '\\n') {\n      self->current_position.extent.row++;\n      self->current_position.extent.column = 0;\n      ts_lexer__set_column_data(self, 0);\n    } else {\n      bool is_bom = self->current_position.bytes == 0 && \n        self->data.lookahead == BYTE_ORDER_MARK;\n      if (!is_bom) ts_lexer__increment_column_data(self);\n      self->current_position.extent.column += self->lookahead_size;\n    }\n    self->current_position.bytes += self->lookahead_size;\n  }\n\n  const TSRange *current_range = &self->included_ranges[self->current_included_range_index];\n  while (\n    self->current_position.bytes >= current_range->end_byte ||\n    current_range->end_byte == current_range->start_byte\n  ) {\n    if (self->current_included_range_index < self->included_range_count) {\n      self->current_included_range_index++;\n    }\n    if (self->current_included_range_index < self->included_range_count) {\n      current_range++;\n      self->current_position = (Length) {\n        current_range->start_byte,\n        current_range->start_point,\n      };\n    } else {\n      current_range = NULL;\n      break;\n    }\n  }\n\n  if (skip) self->token_start_position = self->current_position;\n\n  if (current_range) {\n    if (\n      self->current_position.bytes < self->chunk_start ||\n      self->current_position.bytes >= self->chunk_start + self->chunk_size\n    ) {\n      ts_lexer__get_chunk(self);\n    }\n    ts_lexer__get_lookahead(self);\n  } else {\n    ts_lexer__clear_chunk(self);\n    self->data.lookahead = '\\0';\n    self->lookahead_size = 1;\n  }\n}\n\n// Advance to the next character in the source code, retrieving a new\n// chunk of source code if needed.\nstatic void ts_lexer__advance(TSLexer *_self, bool skip) {\n  Lexer *self = (Lexer *)_self;\n  if (!self->chunk) return;\n\n  if (skip) {\n    LOG(\"skip\", self->data.lookahead)\n  } else {\n    LOG(\"consume\", self->data.lookahead)\n  }\n\n  ts_lexer__do_advance(self, skip);\n}\n\n// Mark that a token match has completed. This can be called multiple\n// times if a longer match is found later.\nstatic void ts_lexer__mark_end(TSLexer *_self) {\n  Lexer *self = (Lexer *)_self;\n  if (!ts_lexer__eof(&self->data)) {\n    // If the lexer is right at the beginning of included range,\n    // then the token should be considered to end at the *end* of the\n    // previous included range, rather than here.\n    TSRange *current_included_range = &self->included_ranges[\n      self->current_included_range_index\n    ];\n    if (\n      self->current_included_range_index > 0 &&\n      self->current_position.bytes == current_included_range->start_byte\n    ) {\n      TSRange *previous_included_range = current_included_range - 1;\n      self->token_end_position = (Length) {\n        previous_included_range->end_byte,\n        previous_included_range->end_point,\n      };\n      return;\n    }\n  }\n  self->token_end_position = self->current_position;\n}\n\nstatic uint32_t ts_lexer__get_column(TSLexer *_self) {\n  Lexer *self = (Lexer *)_self;\n\n  self->did_get_column = true;\n\n  if (!self->column_data.valid) {\n    // Record current position\n    uint32_t goal_byte = self->current_position.bytes;\n\n    // Back up to the beginning of the line\n    Length start_of_col = {\n      self->current_position.bytes - self->current_position.extent.column,\n      {self->current_position.extent.row, 0},\n    };\n    ts_lexer_goto(self, start_of_col);\n    ts_lexer__set_column_data(self, 0);\n    ts_lexer__get_chunk(self);\n\n    if (!ts_lexer__eof(_self)) {\n      ts_lexer__get_lookahead(self);\n\n      // Advance to the recorded position\n      while (self->current_position.bytes < goal_byte && !ts_lexer__eof(_self) && self->chunk) {\n        ts_lexer__do_advance(self, false);\n        if (ts_lexer__eof(_self)) break;\n      }\n    }\n  }\n\n  return self->column_data.value;\n}\n\n// Is the lexer at a boundary between two disjoint included ranges of\n// source code? This is exposed as an API because some languages' external\n// scanners need to perform custom actions at these boundaries.\nstatic bool ts_lexer__is_at_included_range_start(const TSLexer *_self) {\n  const Lexer *self = (const Lexer *)_self;\n  if (self->current_included_range_index < self->included_range_count) {\n    TSRange *current_range = &self->included_ranges[self->current_included_range_index];\n    return self->current_position.bytes == current_range->start_byte;\n  } else {\n    return false;\n  }\n}\n\nstatic void ts_lexer__log(const TSLexer *_self, const char *fmt, ...) {\n  Lexer *self = (Lexer *)_self;\n  va_list args;\n  va_start(args, fmt);\n  if (self->logger.log) {\n    vsnprintf(self->debug_buffer, TREE_SITTER_SERIALIZATION_BUFFER_SIZE, fmt, args);\n    self->logger.log(self->logger.payload, TSLogTypeLex, self->debug_buffer);\n  }\n  va_end(args);\n}\n\nvoid ts_lexer_init(Lexer *self) {\n  *self = (Lexer) {\n    .data = {\n      // The lexer's methods are stored as struct fields so that generated\n      // parsers can call them without needing to be linked against this\n      // library.\n      .advance = ts_lexer__advance,\n      .mark_end = ts_lexer__mark_end,\n      .get_column = ts_lexer__get_column,\n      .is_at_included_range_start = ts_lexer__is_at_included_range_start,\n      .eof = ts_lexer__eof,\n      .log = ts_lexer__log,\n      .lookahead = 0,\n      .result_symbol = 0,\n    },\n    .chunk = NULL,\n    .chunk_size = 0,\n    .chunk_start = 0,\n    .current_position = {0, {0, 0}},\n    .logger = {\n      .payload = NULL,\n      .log = NULL\n    },\n    .included_ranges = NULL,\n    .included_range_count = 0,\n    .current_included_range_index = 0,\n    .did_get_column = false,\n    .column_data = {\n      .valid = false,\n      .value = 0\n    }\n  };\n  ts_lexer_set_included_ranges(self, NULL, 0);\n}\n\nvoid ts_lexer_delete(Lexer *self) {\n  ts_free(self->included_ranges);\n}\n\nvoid ts_lexer_set_input(Lexer *self, TSInput input) {\n  self->input = input;\n  ts_lexer__clear_chunk(self);\n  ts_lexer_goto(self, self->current_position);\n}\n\n// Move the lexer to the given position. This doesn't do any work\n// if the parser is already at the given position.\nvoid ts_lexer_reset(Lexer *self, Length position) {\n  if (position.bytes != self->current_position.bytes) {\n    ts_lexer_goto(self, position);\n  }\n}\n\nvoid ts_lexer_start(Lexer *self) {\n  self->token_start_position = self->current_position;\n  self->token_end_position = LENGTH_UNDEFINED;\n  self->data.result_symbol = 0;\n  self->did_get_column = false;\n  if (!ts_lexer__eof(&self->data)) {\n    if (!self->chunk_size) ts_lexer__get_chunk(self);\n    if (!self->lookahead_size) ts_lexer__get_lookahead(self);\n    if (self->current_position.bytes == 0) {\n      if (self->data.lookahead == BYTE_ORDER_MARK) {\n        ts_lexer__advance(&self->data, true);\n      }\n      ts_lexer__set_column_data(self, 0);\n    }\n  }\n}\n\nvoid ts_lexer_finish(Lexer *self, uint32_t *lookahead_end_byte) {\n  if (length_is_undefined(self->token_end_position)) {\n    ts_lexer__mark_end(&self->data);\n  }\n\n  // If the token ended at an included range boundary, then its end position\n  // will have been reset to the end of the preceding range. Reset the start\n  // position to match.\n  if (self->token_end_position.bytes < self->token_start_position.bytes) {\n    self->token_start_position = self->token_end_position;\n  }\n\n  uint32_t current_lookahead_end_byte = self->current_position.bytes + 1;\n\n  // In order to determine that a byte sequence is invalid UTF8 or UTF16,\n  // the character decoding algorithm may have looked at the following byte.\n  // Therefore, the next byte *after* the current (invalid) character\n  // affects the interpretation of the current character.\n  if (self->data.lookahead == TS_DECODE_ERROR) {\n    current_lookahead_end_byte += 4; // the maximum number of bytes read to identify an invalid code point\n  }\n\n  if (current_lookahead_end_byte > *lookahead_end_byte) {\n    *lookahead_end_byte = current_lookahead_end_byte;\n  }\n}\n\nvoid ts_lexer_mark_end(Lexer *self) {\n  ts_lexer__mark_end(&self->data);\n}\n\nbool ts_lexer_set_included_ranges(\n  Lexer *self,\n  const TSRange *ranges,\n  uint32_t count\n) {\n  if (count == 0 || !ranges) {\n    ranges = &DEFAULT_RANGE;\n    count = 1;\n  } else {\n    uint32_t previous_byte = 0;\n    for (unsigned i = 0; i < count; i++) {\n      const TSRange *range = &ranges[i];\n      if (\n        range->start_byte < previous_byte ||\n        range->end_byte < range->start_byte\n      ) return false;\n      previous_byte = range->end_byte;\n    }\n  }\n\n  size_t size = count * sizeof(TSRange);\n  self->included_ranges = ts_realloc(self->included_ranges, size);\n  memcpy(self->included_ranges, ranges, size);\n  self->included_range_count = count;\n  ts_lexer_goto(self, self->current_position);\n  return true;\n}\n\nTSRange *ts_lexer_included_ranges(const Lexer *self, uint32_t *count) {\n  *count = self->included_range_count;\n  return self->included_ranges;\n}\n\n#undef LOG\n",
    "#include <stdbool.h>\n#include \"./point.h\"\n#include \"./subtree.h\"\n#include \"./tree.h\"\n#include \"./language.h\"\n\ntypedef struct {\n  Subtree parent;\n  const TSTree *tree;\n  Length position;\n  uint32_t child_index;\n  uint32_t structural_child_index;\n  const TSSymbol *alias_sequence;\n} NodeChildIterator;\n\nstatic inline bool ts_node__is_relevant(TSNode self, bool include_anonymous);\n\n// TSNode - constructors\n\nTSNode ts_node_new(\n  const TSTree *tree,\n  const Subtree *subtree,\n  Length position,\n  TSSymbol alias\n) {\n  return (TSNode) {\n    {position.bytes, position.extent.row, position.extent.column, alias},\n    subtree,\n    tree,\n  };\n}\n\nstatic inline TSNode ts_node__null(void) {\n  return ts_node_new(NULL, NULL, length_zero(), 0);\n}\n\n// TSNode - accessors\n\nuint32_t ts_node_start_byte(TSNode self) {\n  return self.context[0];\n}\n\nTSPoint ts_node_start_point(TSNode self) {\n  return (TSPoint) {self.context[1], self.context[2]};\n}\n\nstatic inline uint32_t ts_node__alias(const TSNode *self) {\n  return self->context[3];\n}\n\nstatic inline Subtree ts_node__subtree(TSNode self) {\n  return *(const Subtree *)self.id;\n}\n\n// NodeChildIterator\n\nstatic inline NodeChildIterator ts_node_iterate_children(const TSNode *node) {\n  Subtree subtree = ts_node__subtree(*node);\n  if (ts_subtree_child_count(subtree) == 0) {\n    return (NodeChildIterator) {NULL_SUBTREE, node->tree, length_zero(), 0, 0, NULL};\n  }\n  const TSSymbol *alias_sequence = ts_language_alias_sequence(\n    node->tree->language,\n    subtree.ptr->production_id\n  );\n  return (NodeChildIterator) {\n    .tree = node->tree,\n    .parent = subtree,\n    .position = {ts_node_start_byte(*node), ts_node_start_point(*node)},\n    .child_index = 0,\n    .structural_child_index = 0,\n    .alias_sequence = alias_sequence,\n  };\n}\n\nstatic inline bool ts_node_child_iterator_done(NodeChildIterator *self) {\n  return self->child_index == self->parent.ptr->child_count;\n}\n\nstatic inline bool ts_node_child_iterator_next(\n  NodeChildIterator *self,\n  TSNode *result\n) {\n  if (!self->parent.ptr || ts_node_child_iterator_done(self)) return false;\n  const Subtree *child = &ts_subtree_children(self->parent)[self->child_index];\n  TSSymbol alias_symbol = 0;\n  if (!ts_subtree_extra(*child)) {\n    if (self->alias_sequence) {\n      alias_symbol = self->alias_sequence[self->structural_child_index];\n    }\n    self->structural_child_index++;\n  }\n  if (self->child_index > 0) {\n    self->position = length_add(self->position, ts_subtree_padding(*child));\n  }\n  *result = ts_node_new(\n    self->tree,\n    child,\n    self->position,\n    alias_symbol\n  );\n  self->position = length_add(self->position, ts_subtree_size(*child));\n  self->child_index++;\n  return true;\n}\n\n// TSNode - private\n\nstatic inline bool ts_node__is_relevant(TSNode self, bool include_anonymous) {\n  Subtree tree = ts_node__subtree(self);\n  if (include_anonymous) {\n    return ts_subtree_visible(tree) || ts_node__alias(&self);\n  } else {\n    TSSymbol alias = ts_node__alias(&self);\n    if (alias) {\n      return ts_language_symbol_metadata(self.tree->language, alias).named;\n    } else {\n      return ts_subtree_visible(tree) && ts_subtree_named(tree);\n    }\n  }\n}\n\nstatic inline uint32_t ts_node__relevant_child_count(\n  TSNode self,\n  bool include_anonymous\n) {\n  Subtree tree = ts_node__subtree(self);\n  if (ts_subtree_child_count(tree) > 0) {\n    if (include_anonymous) {\n      return tree.ptr->visible_child_count;\n    } else {\n      return tree.ptr->named_child_count;\n    }\n  } else {\n    return 0;\n  }\n}\n\nstatic inline TSNode ts_node__child(\n  TSNode self,\n  uint32_t child_index,\n  bool include_anonymous\n) {\n  TSNode result = self;\n  bool did_descend = true;\n\n  while (did_descend) {\n    did_descend = false;\n\n    TSNode child;\n    uint32_t index = 0;\n    NodeChildIterator iterator = ts_node_iterate_children(&result);\n    while (ts_node_child_iterator_next(&iterator, &child)) {\n      if (ts_node__is_relevant(child, include_anonymous)) {\n        if (index == child_index) {\n          return child;\n        }\n        index++;\n      } else {\n        uint32_t grandchild_index = child_index - index;\n        uint32_t grandchild_count = ts_node__relevant_child_count(child, include_anonymous);\n        if (grandchild_index < grandchild_count) {\n          did_descend = true;\n          result = child;\n          child_index = grandchild_index;\n          break;\n        }\n        index += grandchild_count;\n      }\n    }\n  }\n\n  return ts_node__null();\n}\n\nstatic bool ts_subtree_has_trailing_empty_descendant(\n  Subtree self,\n  Subtree other\n) {\n  for (unsigned i = ts_subtree_child_count(self) - 1; i + 1 > 0; i--) {\n    Subtree child = ts_subtree_children(self)[i];\n    if (ts_subtree_total_bytes(child) > 0) break;\n    if (child.ptr == other.ptr || ts_subtree_has_trailing_empty_descendant(child, other)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nstatic inline TSNode ts_node__prev_sibling(TSNode self, bool include_anonymous) {\n  Subtree self_subtree = ts_node__subtree(self);\n  bool self_is_empty = ts_subtree_total_bytes(self_subtree) == 0;\n  uint32_t target_end_byte = ts_node_end_byte(self);\n\n  TSNode node = ts_node_parent(self);\n  TSNode earlier_node = ts_node__null();\n  bool earlier_node_is_relevant = false;\n\n  while (!ts_node_is_null(node)) {\n    TSNode earlier_child = ts_node__null();\n    bool earlier_child_is_relevant = false;\n    bool found_child_containing_target = false;\n\n    TSNode child;\n    NodeChildIterator iterator = ts_node_iterate_children(&node);\n    while (ts_node_child_iterator_next(&iterator, &child)) {\n      if (child.id == self.id) break;\n      if (iterator.position.bytes > target_end_byte) {\n        found_child_containing_target = true;\n        break;\n      }\n\n      if (iterator.position.bytes == target_end_byte &&\n          (!self_is_empty ||\n           ts_subtree_has_trailing_empty_descendant(ts_node__subtree(child), self_subtree))) {\n        found_child_containing_target = true;\n        break;\n      }\n\n      if (ts_node__is_relevant(child, include_anonymous)) {\n        earlier_child = child;\n        earlier_child_is_relevant = true;\n      } else if (ts_node__relevant_child_count(child, include_anonymous) > 0) {\n        earlier_child = child;\n        earlier_child_is_relevant = false;\n      }\n    }\n\n    if (found_child_containing_target) {\n      if (!ts_node_is_null(earlier_child)) {\n        earlier_node = earlier_child;\n        earlier_node_is_relevant = earlier_child_is_relevant;\n      }\n      node = child;\n    } else if (earlier_child_is_relevant) {\n      return earlier_child;\n    } else if (!ts_node_is_null(earlier_child)) {\n      node = earlier_child;\n    } else if (earlier_node_is_relevant) {\n      return earlier_node;\n    } else {\n      node = earlier_node;\n      earlier_node = ts_node__null();\n      earlier_node_is_relevant = false;\n    }\n  }\n\n  return ts_node__null();\n}\n\nstatic inline TSNode ts_node__next_sibling(TSNode self, bool include_anonymous) {\n  uint32_t target_end_byte = ts_node_end_byte(self);\n\n  TSNode node = ts_node_parent(self);\n  TSNode later_node = ts_node__null();\n  bool later_node_is_relevant = false;\n\n  while (!ts_node_is_null(node)) {\n    TSNode later_child = ts_node__null();\n    bool later_child_is_relevant = false;\n    TSNode child_containing_target = ts_node__null();\n\n    TSNode child;\n    NodeChildIterator iterator = ts_node_iterate_children(&node);\n    while (ts_node_child_iterator_next(&iterator, &child)) {\n      if (iterator.position.bytes <= target_end_byte) continue;\n      uint32_t start_byte = ts_node_start_byte(self);\n      uint32_t child_start_byte = ts_node_start_byte(child);\n\n      bool is_empty = start_byte == target_end_byte;\n      bool contains_target = is_empty ?\n        child_start_byte < start_byte :\n        child_start_byte <= start_byte;\n\n      if (contains_target) {\n        if (ts_node__subtree(child).ptr != ts_node__subtree(self).ptr) {\n          child_containing_target = child;\n        }\n      } else if (ts_node__is_relevant(child, include_anonymous)) {\n        later_child = child;\n        later_child_is_relevant = true;\n        break;\n      } else if (ts_node__relevant_child_count(child, include_anonymous) > 0) {\n        later_child = child;\n        later_child_is_relevant = false;\n        break;\n      }\n    }\n\n    if (!ts_node_is_null(child_containing_target)) {\n      if (!ts_node_is_null(later_child)) {\n        later_node = later_child;\n        later_node_is_relevant = later_child_is_relevant;\n      }\n      node = child_containing_target;\n    } else if (later_child_is_relevant) {\n      return later_child;\n    } else if (!ts_node_is_null(later_child)) {\n      node = later_child;\n    } else if (later_node_is_relevant) {\n      return later_node;\n    } else {\n      node = later_node;\n    }\n  }\n\n  return ts_node__null();\n}\n\nstatic inline TSNode ts_node__first_child_for_byte(\n  TSNode self,\n  uint32_t goal,\n  bool include_anonymous\n) {\n  TSNode node = self;\n  bool did_descend = true;\n\n  NodeChildIterator last_iterator;\n  bool has_last_iterator = false;\n\n  while (did_descend) {\n    did_descend = false;\n\n    TSNode child;\n    NodeChildIterator iterator = ts_node_iterate_children(&node);\n  loop:\n    while (ts_node_child_iterator_next(&iterator, &child)) {\n      if (ts_node_end_byte(child) > goal) {\n        if (ts_node__is_relevant(child, include_anonymous)) {\n          return child;\n        } else if (ts_node_child_count(child) > 0) {\n          if (iterator.child_index < ts_subtree_child_count(ts_node__subtree(child))) {\n            last_iterator = iterator;\n            has_last_iterator = true;\n          }\n          did_descend = true;\n          node = child;\n          break;\n        }\n      }\n    }\n\n    if (!did_descend && has_last_iterator) {\n      iterator = last_iterator;\n      has_last_iterator = false;\n      goto loop;\n    }\n  }\n\n  return ts_node__null();\n}\n\nstatic inline TSNode ts_node__descendant_for_byte_range(\n  TSNode self,\n  uint32_t range_start,\n  uint32_t range_end,\n  bool include_anonymous\n) {\n  if (range_start > range_end) {\n    return ts_node__null();\n  }\n  TSNode node = self;\n  TSNode last_visible_node = self;\n\n  bool did_descend = true;\n  while (did_descend) {\n    did_descend = false;\n\n    TSNode child;\n    NodeChildIterator iterator = ts_node_iterate_children(&node);\n    while (ts_node_child_iterator_next(&iterator, &child)) {\n      uint32_t node_end = iterator.position.bytes;\n\n      // The end of this node must extend far enough forward to touch\n      // the end of the range\n      if (node_end < range_end) continue;\n\n      // ...and exceed the start of the range, unless the node itself is\n      // empty, in which case it must at least be equal to the start of the range.\n      bool is_empty = ts_node_start_byte(child) == node_end;\n      if (is_empty ? node_end < range_start : node_end <= range_start) continue;\n\n      // The start of this node must extend far enough backward to\n      // touch the start of the range.\n      if (range_start < ts_node_start_byte(child)) break;\n\n      node = child;\n      if (ts_node__is_relevant(node, include_anonymous)) {\n        last_visible_node = node;\n      }\n      did_descend = true;\n      break;\n    }\n  }\n\n  return last_visible_node;\n}\n\nstatic inline TSNode ts_node__descendant_for_point_range(\n  TSNode self,\n  TSPoint range_start,\n  TSPoint range_end,\n  bool include_anonymous\n) {\n  if (point_gt(range_start, range_end)) {\n    return ts_node__null();\n  }\n  TSNode node = self;\n  TSNode last_visible_node = self;\n\n  bool did_descend = true;\n  while (did_descend) {\n    did_descend = false;\n\n    TSNode child;\n    NodeChildIterator iterator = ts_node_iterate_children(&node);\n    while (ts_node_child_iterator_next(&iterator, &child)) {\n      TSPoint node_end = iterator.position.extent;\n\n      // The end of this node must extend far enough forward to touch\n      // the end of the range\n      if (point_lt(node_end, range_end)) continue;\n\n      // ...and exceed the start of the range, unless the node itself is\n      // empty, in which case it must at least be equal to the start of the range.\n      bool is_empty =  point_eq(ts_node_start_point(child), node_end);\n      if (is_empty ? point_lt(node_end, range_start) : point_lte(node_end, range_start)) {\n        continue;\n      }\n\n      // The start of this node must extend far enough backward to\n      // touch the start of the range.\n      if (point_lt(range_start, ts_node_start_point(child))) break;\n\n      node = child;\n      if (ts_node__is_relevant(node, include_anonymous)) {\n        last_visible_node = node;\n      }\n      did_descend = true;\n      break;\n    }\n  }\n\n  return last_visible_node;\n}\n\n// TSNode - public\n\nuint32_t ts_node_end_byte(TSNode self) {\n  return ts_node_start_byte(self) + ts_subtree_size(ts_node__subtree(self)).bytes;\n}\n\nTSPoint ts_node_end_point(TSNode self) {\n  return point_add(ts_node_start_point(self), ts_subtree_size(ts_node__subtree(self)).extent);\n}\n\nTSSymbol ts_node_symbol(TSNode self) {\n  TSSymbol symbol = ts_node__alias(&self);\n  if (!symbol) symbol = ts_subtree_symbol(ts_node__subtree(self));\n  return ts_language_public_symbol(self.tree->language, symbol);\n}\n\nconst char *ts_node_type(TSNode self) {\n  TSSymbol symbol = ts_node__alias(&self);\n  if (!symbol) symbol = ts_subtree_symbol(ts_node__subtree(self));\n  return ts_language_symbol_name(self.tree->language, symbol);\n}\n\nconst TSLanguage *ts_node_language(TSNode self) {\n  return self.tree->language;\n}\n\nTSSymbol ts_node_grammar_symbol(TSNode self) {\n  return ts_subtree_symbol(ts_node__subtree(self));\n}\n\nconst char *ts_node_grammar_type(TSNode self) {\n  TSSymbol symbol = ts_subtree_symbol(ts_node__subtree(self));\n  return ts_language_symbol_name(self.tree->language, symbol);\n}\n\nchar *ts_node_string(TSNode self) {\n  TSSymbol alias_symbol = ts_node__alias(&self);\n  return ts_subtree_string(\n    ts_node__subtree(self),\n    alias_symbol,\n    ts_language_symbol_metadata(self.tree->language, alias_symbol).visible,\n    self.tree->language,\n    false\n  );\n}\n\nbool ts_node_eq(TSNode self, TSNode other) {\n  return self.tree == other.tree && self.id == other.id;\n}\n\nbool ts_node_is_null(TSNode self) {\n  return self.id == 0;\n}\n\nbool ts_node_is_extra(TSNode self) {\n  return ts_subtree_extra(ts_node__subtree(self));\n}\n\nbool ts_node_is_named(TSNode self) {\n  TSSymbol alias = ts_node__alias(&self);\n  return alias\n    ? ts_language_symbol_metadata(self.tree->language, alias).named\n    : ts_subtree_named(ts_node__subtree(self));\n}\n\nbool ts_node_is_missing(TSNode self) {\n  return ts_subtree_missing(ts_node__subtree(self));\n}\n\nbool ts_node_has_changes(TSNode self) {\n  return ts_subtree_has_changes(ts_node__subtree(self));\n}\n\nbool ts_node_has_error(TSNode self) {\n  return ts_subtree_error_cost(ts_node__subtree(self)) > 0;\n}\n\nbool ts_node_is_error(TSNode self) {\n  TSSymbol symbol = ts_node_symbol(self);\n  return symbol == ts_builtin_sym_error;\n}\n\nuint32_t ts_node_descendant_count(TSNode self) {\n  return ts_subtree_visible_descendant_count(ts_node__subtree(self)) + 1;\n}\n\nTSStateId ts_node_parse_state(TSNode self) {\n  return ts_subtree_parse_state(ts_node__subtree(self));\n}\n\nTSStateId ts_node_next_parse_state(TSNode self) {\n  const TSLanguage *language = self.tree->language;\n  uint16_t state = ts_node_parse_state(self);\n  if (state == TS_TREE_STATE_NONE) {\n    return TS_TREE_STATE_NONE;\n  }\n  uint16_t symbol = ts_node_grammar_symbol(self);\n  return ts_language_next_state(language, state, symbol);\n}\n\nTSNode ts_node_parent(TSNode self) {\n  TSNode node = ts_tree_root_node(self.tree);\n  if (node.id == self.id) return ts_node__null();\n\n  while (true) {\n    TSNode next_node = ts_node_child_with_descendant(node, self);\n    if (next_node.id == self.id || ts_node_is_null(next_node)) break;\n    node = next_node;\n  }\n\n  return node;\n}\n\nTSNode ts_node_child_with_descendant(TSNode self, TSNode descendant) {\n  uint32_t start_byte = ts_node_start_byte(descendant);\n  uint32_t end_byte = ts_node_end_byte(descendant);\n  bool is_empty = start_byte == end_byte;\n\n  do {\n    NodeChildIterator iter = ts_node_iterate_children(&self);\n    do {\n      if (\n        !ts_node_child_iterator_next(&iter, &self)\n        || ts_node_start_byte(self) > start_byte\n      ) {\n        return ts_node__null();\n      }\n      if (self.id == descendant.id) {\n        return self;\n      }\n\n      // If the descendant is empty, and the end byte is within `self`,\n      // we check whether `self` contains it or not.\n      if (is_empty && iter.position.bytes >= end_byte && ts_node_child_count(self) > 0) {\n        TSNode child = ts_node_child_with_descendant(self, descendant);\n        // If the child is not null, return self if it's relevant, else return the child\n        if (!ts_node_is_null(child)) {\n          return ts_node__is_relevant(self, true) ? self : child;\n        }\n      }\n    } while ((is_empty ? iter.position.bytes <= end_byte : iter.position.bytes < end_byte) || ts_node_child_count(self) == 0);\n  } while (!ts_node__is_relevant(self, true));\n\n  return self;\n}\n\nTSNode ts_node_child(TSNode self, uint32_t child_index) {\n  return ts_node__child(self, child_index, true);\n}\n\nTSNode ts_node_named_child(TSNode self, uint32_t child_index) {\n  return ts_node__child(self, child_index, false);\n}\n\nTSNode ts_node_child_by_field_id(TSNode self, TSFieldId field_id) {\nrecur:\n  if (!field_id || ts_node_child_count(self) == 0) return ts_node__null();\n\n  const TSFieldMapEntry *field_map, *field_map_end;\n  ts_language_field_map(\n    self.tree->language,\n    ts_node__subtree(self).ptr->production_id,\n    &field_map,\n    &field_map_end\n  );\n  if (field_map == field_map_end) return ts_node__null();\n\n  // The field mappings are sorted by their field id. Scan all\n  // the mappings to find the ones for the given field id.\n  while (field_map->field_id < field_id) {\n    field_map++;\n    if (field_map == field_map_end) return ts_node__null();\n  }\n  while (field_map_end[-1].field_id > field_id) {\n    field_map_end--;\n    if (field_map == field_map_end) return ts_node__null();\n  }\n\n  TSNode child;\n  NodeChildIterator iterator = ts_node_iterate_children(&self);\n  while (ts_node_child_iterator_next(&iterator, &child)) {\n    if (!ts_subtree_extra(ts_node__subtree(child))) {\n      uint32_t index = iterator.structural_child_index - 1;\n      if (index < field_map->child_index) continue;\n\n      // Hidden nodes' fields are \"inherited\" by their visible parent.\n      if (field_map->inherited) {\n\n        // If this is the *last* possible child node for this field,\n        // then perform a tail call to avoid recursion.\n        if (field_map + 1 == field_map_end) {\n          self = child;\n          goto recur;\n        }\n\n        // Otherwise, descend into this child, but if it doesn't contain\n        // the field, continue searching subsequent children.\n        else {\n          TSNode result = ts_node_child_by_field_id(child, field_id);\n          if (result.id) return result;\n          field_map++;\n          if (field_map == field_map_end) return ts_node__null();\n        }\n      }\n\n      else if (ts_node__is_relevant(child, true)) {\n        return child;\n      }\n\n      // If the field refers to a hidden node with visible children,\n      // return the first visible child.\n      else if (ts_node_child_count(child) > 0 ) {\n        return ts_node_child(child, 0);\n      }\n\n      // Otherwise, continue searching subsequent children.\n      else {\n        field_map++;\n        if (field_map == field_map_end) return ts_node__null();\n      }\n    }\n  }\n\n  return ts_node__null();\n}\n\nstatic inline const char *ts_node__field_name_from_language(TSNode self, uint32_t structural_child_index) {\n    const TSFieldMapEntry *field_map, *field_map_end;\n    ts_language_field_map(\n      self.tree->language,\n      ts_node__subtree(self).ptr->production_id,\n      &field_map,\n      &field_map_end\n    );\n    for (; field_map != field_map_end; field_map++) {\n      if (!field_map->inherited && field_map->child_index == structural_child_index) {\n        return self.tree->language->field_names[field_map->field_id];\n      }\n    }\n    return NULL;\n}\n\nconst char *ts_node_field_name_for_child(TSNode self, uint32_t child_index) {\n  TSNode result = self;\n  bool did_descend = true;\n  const char *inherited_field_name = NULL;\n\n  while (did_descend) {\n    did_descend = false;\n\n    TSNode child;\n    uint32_t index = 0;\n    NodeChildIterator iterator = ts_node_iterate_children(&result);\n    while (ts_node_child_iterator_next(&iterator, &child)) {\n      if (ts_node__is_relevant(child, true)) {\n        if (index == child_index) {\n          if (ts_node_is_extra(child)) {\n            return NULL;\n          }\n          const char *field_name = ts_node__field_name_from_language(result, iterator.structural_child_index - 1);\n          if (field_name) return field_name;\n          return inherited_field_name;\n        }\n        index++;\n      } else {\n        uint32_t grandchild_index = child_index - index;\n        uint32_t grandchild_count = ts_node__relevant_child_count(child, true);\n        if (grandchild_index < grandchild_count) {\n          const char *field_name = ts_node__field_name_from_language(result, iterator.structural_child_index - 1);\n          if (field_name) inherited_field_name = field_name;\n\n          did_descend = true;\n          result = child;\n          child_index = grandchild_index;\n          break;\n        }\n        index += grandchild_count;\n      }\n    }\n  }\n\n  return NULL;\n}\n\nconst char *ts_node_field_name_for_named_child(TSNode self, uint32_t named_child_index) {\n  TSNode result = self;\n  bool did_descend = true;\n  const char *inherited_field_name = NULL;\n\n  while (did_descend) {\n    did_descend = false;\n\n    TSNode child;\n    uint32_t index = 0;\n    NodeChildIterator iterator = ts_node_iterate_children(&result);\n    while (ts_node_child_iterator_next(&iterator, &child)) {\n      if (ts_node__is_relevant(child, false)) {\n        if (index == named_child_index) {\n          if (ts_node_is_extra(child)) {\n            return NULL;\n          }\n          const char *field_name = ts_node__field_name_from_language(result, iterator.structural_child_index - 1);\n          if (field_name) return field_name;\n          return inherited_field_name;\n        }\n        index++;\n      } else {\n        uint32_t named_grandchild_index = named_child_index - index;\n        uint32_t grandchild_count = ts_node__relevant_child_count(child, false);\n        if (named_grandchild_index < grandchild_count) {\n          const char *field_name = ts_node__field_name_from_language(result, iterator.structural_child_index - 1);\n          if (field_name) inherited_field_name = field_name;\n\n          did_descend = true;\n          result = child;\n          named_child_index = named_grandchild_index;\n          break;\n        }\n        index += grandchild_count;\n      }\n    }\n  }\n\n  return NULL;\n}\n\nTSNode ts_node_child_by_field_name(\n  TSNode self,\n  const char *name,\n  uint32_t name_length\n) {\n  TSFieldId field_id = ts_language_field_id_for_name(\n    self.tree->language,\n    name,\n    name_length\n  );\n  return ts_node_child_by_field_id(self, field_id);\n}\n\nuint32_t ts_node_child_count(TSNode self) {\n  Subtree tree = ts_node__subtree(self);\n  if (ts_subtree_child_count(tree) > 0) {\n    return tree.ptr->visible_child_count;\n  } else {\n    return 0;\n  }\n}\n\nuint32_t ts_node_named_child_count(TSNode self) {\n  Subtree tree = ts_node__subtree(self);\n  if (ts_subtree_child_count(tree) > 0) {\n    return tree.ptr->named_child_count;\n  } else {\n    return 0;\n  }\n}\n\nTSNode ts_node_next_sibling(TSNode self) {\n  return ts_node__next_sibling(self, true);\n}\n\nTSNode ts_node_next_named_sibling(TSNode self) {\n  return ts_node__next_sibling(self, false);\n}\n\nTSNode ts_node_prev_sibling(TSNode self) {\n  return ts_node__prev_sibling(self, true);\n}\n\nTSNode ts_node_prev_named_sibling(TSNode self) {\n  return ts_node__prev_sibling(self, false);\n}\n\nTSNode ts_node_first_child_for_byte(TSNode self, uint32_t byte) {\n  return ts_node__first_child_for_byte(self, byte, true);\n}\n\nTSNode ts_node_first_named_child_for_byte(TSNode self, uint32_t byte) {\n  return ts_node__first_child_for_byte(self, byte, false);\n}\n\nTSNode ts_node_descendant_for_byte_range(\n  TSNode self,\n  uint32_t start,\n  uint32_t end\n) {\n  return ts_node__descendant_for_byte_range(self, start, end, true);\n}\n\nTSNode ts_node_named_descendant_for_byte_range(\n  TSNode self,\n  uint32_t start,\n  uint32_t end\n) {\n  return ts_node__descendant_for_byte_range(self, start, end, false);\n}\n\nTSNode ts_node_descendant_for_point_range(\n  TSNode self,\n  TSPoint start,\n  TSPoint end\n) {\n  return ts_node__descendant_for_point_range(self, start, end, true);\n}\n\nTSNode ts_node_named_descendant_for_point_range(\n  TSNode self,\n  TSPoint start,\n  TSPoint end\n) {\n  return ts_node__descendant_for_point_range(self, start, end, false);\n}\n\nvoid ts_node_edit(TSNode *self, const TSInputEdit *edit) {\n  uint32_t start_byte = ts_node_start_byte(*self);\n  TSPoint start_point = ts_node_start_point(*self);\n\n  if (start_byte >= edit->old_end_byte) {\n    start_byte = edit->new_end_byte + (start_byte - edit->old_end_byte);\n    start_point = point_add(edit->new_end_point, point_sub(start_point, edit->old_end_point));\n  } else if (start_byte > edit->start_byte) {\n    start_byte = edit->new_end_byte;\n    start_point = edit->new_end_point;\n  }\n\n  self->context[0] = start_byte;\n  self->context[1] = start_point.row;\n  self->context[2] = start_point.column;\n}\n",
    "#include \"tree_sitter/api.h\"\n#include \"./array.h\"\n#include \"./get_changed_ranges.h\"\n#include \"./length.h\"\n#include \"./subtree.h\"\n#include \"./tree_cursor.h\"\n#include \"./tree.h\"\n\nTSTree *ts_tree_new(\n  Subtree root, const TSLanguage *language,\n  const TSRange *included_ranges, unsigned included_range_count\n) {\n  TSTree *result = ts_malloc(sizeof(TSTree));\n  result->root = root;\n  result->language = ts_language_copy(language);\n  result->included_ranges = ts_calloc(included_range_count, sizeof(TSRange));\n  memcpy(result->included_ranges, included_ranges, included_range_count * sizeof(TSRange));\n  result->included_range_count = included_range_count;\n  return result;\n}\n\nTSTree *ts_tree_copy(const TSTree *self) {\n  ts_subtree_retain(self->root);\n  return ts_tree_new(self->root, self->language, self->included_ranges, self->included_range_count);\n}\n\nvoid ts_tree_delete(TSTree *self) {\n  if (!self) return;\n\n  SubtreePool pool = ts_subtree_pool_new(0);\n  ts_subtree_release(&pool, self->root);\n  ts_subtree_pool_delete(&pool);\n  ts_language_delete(self->language);\n  ts_free(self->included_ranges);\n  ts_free(self);\n}\n\nTSNode ts_tree_root_node(const TSTree *self) {\n  return ts_node_new(self, &self->root, ts_subtree_padding(self->root), 0);\n}\n\nTSNode ts_tree_root_node_with_offset(\n  const TSTree *self,\n  uint32_t offset_bytes,\n  TSPoint offset_extent\n) {\n  Length offset = {offset_bytes, offset_extent};\n  return ts_node_new(self, &self->root, length_add(offset, ts_subtree_padding(self->root)), 0);\n}\n\nconst TSLanguage *ts_tree_language(const TSTree *self) {\n  return self->language;\n}\n\nvoid ts_tree_edit(TSTree *self, const TSInputEdit *edit) {\n  for (unsigned i = 0; i < self->included_range_count; i++) {\n    TSRange *range = &self->included_ranges[i];\n    if (range->end_byte >= edit->old_end_byte) {\n      if (range->end_byte != UINT32_MAX) {\n        range->end_byte = edit->new_end_byte + (range->end_byte - edit->old_end_byte);\n        range->end_point = point_add(\n          edit->new_end_point,\n          point_sub(range->end_point, edit->old_end_point)\n        );\n        if (range->end_byte < edit->new_end_byte) {\n          range->end_byte = UINT32_MAX;\n          range->end_point = POINT_MAX;\n        }\n      }\n    } else if (range->end_byte > edit->start_byte) {\n      range->end_byte = edit->start_byte;\n      range->end_point = edit->start_point;\n    }\n    if (range->start_byte >= edit->old_end_byte) {\n      range->start_byte = edit->new_end_byte + (range->start_byte - edit->old_end_byte);\n      range->start_point = point_add(\n        edit->new_end_point,\n        point_sub(range->start_point, edit->old_end_point)\n      );\n      if (range->start_byte < edit->new_end_byte) {\n        range->start_byte = UINT32_MAX;\n        range->start_point = POINT_MAX;\n      }\n    } else if (range->start_byte > edit->start_byte) {\n      range->start_byte = edit->start_byte;\n      range->start_point = edit->start_point;\n    }\n  }\n\n  SubtreePool pool = ts_subtree_pool_new(0);\n  self->root = ts_subtree_edit(self->root, edit, &pool);\n  ts_subtree_pool_delete(&pool);\n}\n\nTSRange *ts_tree_included_ranges(const TSTree *self, uint32_t *length) {\n  *length = self->included_range_count;\n  TSRange *ranges = ts_calloc(self->included_range_count, sizeof(TSRange));\n  memcpy(ranges, self->included_ranges, self->included_range_count * sizeof(TSRange));\n  return ranges;\n}\n\nTSRange *ts_tree_get_changed_ranges(const TSTree *old_tree, const TSTree *new_tree, uint32_t *length) {\n  TreeCursor cursor1 = {NULL, array_new(), 0};\n  TreeCursor cursor2 = {NULL, array_new(), 0};\n  ts_tree_cursor_init(&cursor1, ts_tree_root_node(old_tree));\n  ts_tree_cursor_init(&cursor2, ts_tree_root_node(new_tree));\n\n  TSRangeArray included_range_differences = array_new();\n  ts_range_array_get_changed_ranges(\n    old_tree->included_ranges, old_tree->included_range_count,\n    new_tree->included_ranges, new_tree->included_range_count,\n    &included_range_differences\n  );\n\n  TSRange *result;\n  *length = ts_subtree_get_changed_ranges(\n    &old_tree->root, &new_tree->root, &cursor1, &cursor2,\n    old_tree->language, &included_range_differences, &result\n  );\n\n  array_delete(&included_range_differences);\n  array_delete(&cursor1.stack);\n  array_delete(&cursor2.stack);\n  return result;\n}\n\n#ifdef _WIN32\n\n#include <io.h>\n#include <windows.h>\n\nint _ts_dup(HANDLE handle) {\n  HANDLE dup_handle;\n  if (!DuplicateHandle(\n    GetCurrentProcess(), handle,\n    GetCurrentProcess(), &dup_handle,\n    0, FALSE, DUPLICATE_SAME_ACCESS\n  )) return -1;\n\n  return _open_osfhandle((intptr_t)dup_handle, 0);\n}\n\nvoid ts_tree_print_dot_graph(const TSTree *self, int fd) {\n  FILE *file = _fdopen(_ts_dup((HANDLE)_get_osfhandle(fd)), \"a\");\n  ts_subtree_print_dot_graph(self->root, self->language, file);\n  fclose(file);\n}\n\n#elif !defined(__wasi__) // WASI doesn't support dup\n\n#include <unistd.h>\n\nint _ts_dup(int file_descriptor) {\n  return dup(file_descriptor);\n}\n\nvoid ts_tree_print_dot_graph(const TSTree *self, int file_descriptor) {\n  FILE *file = fdopen(_ts_dup(file_descriptor), \"a\");\n  ts_subtree_print_dot_graph(self->root, self->language, file);\n  fclose(file);\n}\n\n#else\n\nvoid ts_tree_print_dot_graph(const TSTree *self, int file_descriptor) {\n  (void)self;\n  (void)file_descriptor;\n}\n\n#endif\n",
    "#include <time.h>\n#include <stdio.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <inttypes.h>\n#include \"tree_sitter/api.h\"\n#include \"./alloc.h\"\n#include \"./array.h\"\n#include \"./atomic.h\"\n#include \"./clock.h\"\n#include \"./error_costs.h\"\n#include \"./get_changed_ranges.h\"\n#include \"./language.h\"\n#include \"./length.h\"\n#include \"./lexer.h\"\n#include \"./reduce_action.h\"\n#include \"./reusable_node.h\"\n#include \"./stack.h\"\n#include \"./subtree.h\"\n#include \"./tree.h\"\n#include \"./ts_assert.h\"\n#include \"./wasm_store.h\"\n\n#define LOG(...)                                                                            \\\n  if (self->lexer.logger.log || self->dot_graph_file) {                                     \\\n    snprintf(self->lexer.debug_buffer, TREE_SITTER_SERIALIZATION_BUFFER_SIZE, __VA_ARGS__); \\\n    ts_parser__log(self);                                                                   \\\n  }\n\n#define LOG_LOOKAHEAD(symbol_name, size)                      \\\n  if (self->lexer.logger.log || self->dot_graph_file) {       \\\n    char *buf = self->lexer.debug_buffer;                     \\\n    const char *symbol = symbol_name;                         \\\n    int off = snprintf(                                       \\\n      buf,                                                    \\\n      TREE_SITTER_SERIALIZATION_BUFFER_SIZE,                  \\\n      \"lexed_lookahead sym:\"                                  \\\n    );                                                        \\\n    for (                                                     \\\n      int i = 0;                                              \\\n      symbol[i] != '\\0'                                       \\\n      && off < TREE_SITTER_SERIALIZATION_BUFFER_SIZE;         \\\n      i++                                                     \\\n    ) {                                                       \\\n      switch (symbol[i]) {                                    \\\n      case '\\t': buf[off++] = '\\\\'; buf[off++] = 't'; break;  \\\n      case '\\n': buf[off++] = '\\\\'; buf[off++] = 'n'; break;  \\\n      case '\\v': buf[off++] = '\\\\'; buf[off++] = 'v'; break;  \\\n      case '\\f': buf[off++] = '\\\\'; buf[off++] = 'f'; break;  \\\n      case '\\r': buf[off++] = '\\\\'; buf[off++] = 'r'; break;  \\\n      case '\\\\': buf[off++] = '\\\\'; buf[off++] = '\\\\'; break; \\\n      default:   buf[off++] = symbol[i]; break;               \\\n      }                                                       \\\n    }                                                         \\\n    snprintf(                                                 \\\n      buf + off,                                              \\\n      TREE_SITTER_SERIALIZATION_BUFFER_SIZE - off,            \\\n      \", size:%u\",                                            \\\n      size                                                    \\\n    );                                                        \\\n    ts_parser__log(self);                                     \\\n  }\n\n#define LOG_STACK()                                                              \\\n  if (self->dot_graph_file) {                                                    \\\n    ts_stack_print_dot_graph(self->stack, self->language, self->dot_graph_file); \\\n    fputs(\"\\n\\n\", self->dot_graph_file);                                         \\\n  }\n\n#define LOG_TREE(tree)                                                      \\\n  if (self->dot_graph_file) {                                               \\\n    ts_subtree_print_dot_graph(tree, self->language, self->dot_graph_file); \\\n    fputs(\"\\n\", self->dot_graph_file);                                      \\\n  }\n\n#define SYM_NAME(symbol) ts_language_symbol_name(self->language, symbol)\n\n#define TREE_NAME(tree) SYM_NAME(ts_subtree_symbol(tree))\n\nstatic const unsigned MAX_VERSION_COUNT = 6;\nstatic const unsigned MAX_VERSION_COUNT_OVERFLOW = 4;\nstatic const unsigned MAX_SUMMARY_DEPTH = 16;\nstatic const unsigned MAX_COST_DIFFERENCE = 18 * ERROR_COST_PER_SKIPPED_TREE;\nstatic const unsigned OP_COUNT_PER_PARSER_TIMEOUT_CHECK = 100;\n\ntypedef struct {\n  Subtree token;\n  Subtree last_external_token;\n  uint32_t byte_index;\n} TokenCache;\n\nstruct TSParser {\n  Lexer lexer;\n  Stack *stack;\n  SubtreePool tree_pool;\n  const TSLanguage *language;\n  TSWasmStore *wasm_store;\n  ReduceActionSet reduce_actions;\n  Subtree finished_tree;\n  SubtreeArray trailing_extras;\n  SubtreeArray trailing_extras2;\n  SubtreeArray scratch_trees;\n  TokenCache token_cache;\n  ReusableNode reusable_node;\n  void *external_scanner_payload;\n  FILE *dot_graph_file;\n  TSClock end_clock;\n  TSDuration timeout_duration;\n  unsigned accept_count;\n  unsigned operation_count;\n  const volatile size_t *cancellation_flag;\n  Subtree old_tree;\n  TSRangeArray included_range_differences;\n  TSParseOptions parse_options;\n  TSParseState parse_state;\n  unsigned included_range_difference_index;\n  bool has_scanner_error;\n  bool canceled_balancing;\n  bool has_error;\n};\n\ntypedef struct {\n  unsigned cost;\n  unsigned node_count;\n  int dynamic_precedence;\n  bool is_in_error;\n} ErrorStatus;\n\ntypedef enum {\n  ErrorComparisonTakeLeft,\n  ErrorComparisonPreferLeft,\n  ErrorComparisonNone,\n  ErrorComparisonPreferRight,\n  ErrorComparisonTakeRight,\n} ErrorComparison;\n\ntypedef struct {\n  const char *string;\n  uint32_t length;\n} TSStringInput;\n\n// StringInput\n\nstatic const char *ts_string_input_read(\n  void *_self,\n  uint32_t byte,\n  TSPoint point,\n  uint32_t *length\n) {\n  (void)point;\n  TSStringInput *self = (TSStringInput *)_self;\n  if (byte >= self->length) {\n    *length = 0;\n    return \"\";\n  } else {\n    *length = self->length - byte;\n    return self->string + byte;\n  }\n}\n\n// Parser - Private\n\nstatic void ts_parser__log(TSParser *self) {\n  if (self->lexer.logger.log) {\n    self->lexer.logger.log(\n      self->lexer.logger.payload,\n      TSLogTypeParse,\n      self->lexer.debug_buffer\n    );\n  }\n\n  if (self->dot_graph_file) {\n    fprintf(self->dot_graph_file, \"graph {\\nlabel=\\\"\");\n    for (char *chr = &self->lexer.debug_buffer[0]; *chr != 0; chr++) {\n      if (*chr == '\"' || *chr == '\\\\') fputc('\\\\', self->dot_graph_file);\n      fputc(*chr, self->dot_graph_file);\n    }\n    fprintf(self->dot_graph_file, \"\\\"\\n}\\n\\n\");\n  }\n}\n\nstatic bool ts_parser__breakdown_top_of_stack(\n  TSParser *self,\n  StackVersion version\n) {\n  bool did_break_down = false;\n  bool pending = false;\n\n  do {\n    StackSliceArray pop = ts_stack_pop_pending(self->stack, version);\n    if (!pop.size) break;\n\n    did_break_down = true;\n    pending = false;\n    for (uint32_t i = 0; i < pop.size; i++) {\n      StackSlice slice = *array_get(&pop, i);\n      TSStateId state = ts_stack_state(self->stack, slice.version);\n      Subtree parent = *array_front(&slice.subtrees);\n\n      for (uint32_t j = 0, n = ts_subtree_child_count(parent); j < n; j++) {\n        Subtree child = ts_subtree_children(parent)[j];\n        pending = ts_subtree_child_count(child) > 0;\n\n        if (ts_subtree_is_error(child)) {\n          state = ERROR_STATE;\n        } else if (!ts_subtree_extra(child)) {\n          state = ts_language_next_state(self->language, state, ts_subtree_symbol(child));\n        }\n\n        ts_subtree_retain(child);\n        ts_stack_push(self->stack, slice.version, child, pending, state);\n      }\n\n      for (uint32_t j = 1; j < slice.subtrees.size; j++) {\n        Subtree tree = *array_get(&slice.subtrees, j);\n        ts_stack_push(self->stack, slice.version, tree, false, state);\n      }\n\n      ts_subtree_release(&self->tree_pool, parent);\n      array_delete(&slice.subtrees);\n\n      LOG(\"breakdown_top_of_stack tree:%s\", TREE_NAME(parent));\n      LOG_STACK();\n    }\n  } while (pending);\n\n  return did_break_down;\n}\n\nstatic void ts_parser__breakdown_lookahead(\n  TSParser *self,\n  Subtree *lookahead,\n  TSStateId state,\n  ReusableNode *reusable_node\n) {\n  bool did_descend = false;\n  Subtree tree = reusable_node_tree(reusable_node);\n  while (ts_subtree_child_count(tree) > 0 && ts_subtree_parse_state(tree) != state) {\n    LOG(\"state_mismatch sym:%s\", TREE_NAME(tree));\n    reusable_node_descend(reusable_node);\n    tree = reusable_node_tree(reusable_node);\n    did_descend = true;\n  }\n\n  if (did_descend) {\n    ts_subtree_release(&self->tree_pool, *lookahead);\n    *lookahead = tree;\n    ts_subtree_retain(*lookahead);\n  }\n}\n\nstatic ErrorComparison ts_parser__compare_versions(\n  TSParser *self,\n  ErrorStatus a,\n  ErrorStatus b\n) {\n  (void)self;\n  if (!a.is_in_error && b.is_in_error) {\n    if (a.cost < b.cost) {\n      return ErrorComparisonTakeLeft;\n    } else {\n      return ErrorComparisonPreferLeft;\n    }\n  }\n\n  if (a.is_in_error && !b.is_in_error) {\n    if (b.cost < a.cost) {\n      return ErrorComparisonTakeRight;\n    } else {\n      return ErrorComparisonPreferRight;\n    }\n  }\n\n  if (a.cost < b.cost) {\n    if ((b.cost - a.cost) * (1 + a.node_count) > MAX_COST_DIFFERENCE) {\n      return ErrorComparisonTakeLeft;\n    } else {\n      return ErrorComparisonPreferLeft;\n    }\n  }\n\n  if (b.cost < a.cost) {\n    if ((a.cost - b.cost) * (1 + b.node_count) > MAX_COST_DIFFERENCE) {\n      return ErrorComparisonTakeRight;\n    } else {\n      return ErrorComparisonPreferRight;\n    }\n  }\n\n  if (a.dynamic_precedence > b.dynamic_precedence) return ErrorComparisonPreferLeft;\n  if (b.dynamic_precedence > a.dynamic_precedence) return ErrorComparisonPreferRight;\n  return ErrorComparisonNone;\n}\n\nstatic ErrorStatus ts_parser__version_status(\n  TSParser *self,\n  StackVersion version\n) {\n  unsigned cost = ts_stack_error_cost(self->stack, version);\n  bool is_paused = ts_stack_is_paused(self->stack, version);\n  if (is_paused) cost += ERROR_COST_PER_SKIPPED_TREE;\n  return (ErrorStatus) {\n    .cost = cost,\n    .node_count = ts_stack_node_count_since_error(self->stack, version),\n    .dynamic_precedence = ts_stack_dynamic_precedence(self->stack, version),\n    .is_in_error = is_paused || ts_stack_state(self->stack, version) == ERROR_STATE\n  };\n}\n\nstatic bool ts_parser__better_version_exists(\n  TSParser *self,\n  StackVersion version,\n  bool is_in_error,\n  unsigned cost\n) {\n  if (self->finished_tree.ptr && ts_subtree_error_cost(self->finished_tree) <= cost) {\n    return true;\n  }\n\n  Length position = ts_stack_position(self->stack, version);\n  ErrorStatus status = {\n    .cost = cost,\n    .is_in_error = is_in_error,\n    .dynamic_precedence = ts_stack_dynamic_precedence(self->stack, version),\n    .node_count = ts_stack_node_count_since_error(self->stack, version),\n  };\n\n  for (StackVersion i = 0, n = ts_stack_version_count(self->stack); i < n; i++) {\n    if (i == version ||\n        !ts_stack_is_active(self->stack, i) ||\n        ts_stack_position(self->stack, i).bytes < position.bytes) continue;\n    ErrorStatus status_i = ts_parser__version_status(self, i);\n    switch (ts_parser__compare_versions(self, status, status_i)) {\n      case ErrorComparisonTakeRight:\n        return true;\n      case ErrorComparisonPreferRight:\n        if (ts_stack_can_merge(self->stack, i, version)) return true;\n        break;\n      default:\n        break;\n    }\n  }\n\n  return false;\n}\n\nstatic bool ts_parser__call_main_lex_fn(TSParser *self, TSLexerMode lex_mode) {\n  if (ts_language_is_wasm(self->language)) {\n    return ts_wasm_store_call_lex_main(self->wasm_store, lex_mode.lex_state);\n  } else {\n    return self->language->lex_fn(&self->lexer.data, lex_mode.lex_state);\n  }\n}\n\nstatic bool ts_parser__call_keyword_lex_fn(TSParser *self) {\n  if (ts_language_is_wasm(self->language)) {\n    return ts_wasm_store_call_lex_keyword(self->wasm_store, 0);\n  } else {\n    return self->language->keyword_lex_fn(&self->lexer.data, 0);\n  }\n}\n\nstatic void ts_parser__external_scanner_create(\n  TSParser *self\n) {\n  if (self->language && self->language->external_scanner.states) {\n    if (ts_language_is_wasm(self->language)) {\n      self->external_scanner_payload = (void *)(uintptr_t)ts_wasm_store_call_scanner_create(\n        self->wasm_store\n      );\n      if (ts_wasm_store_has_error(self->wasm_store)) {\n        self->has_scanner_error = true;\n      }\n    } else if (self->language->external_scanner.create) {\n      self->external_scanner_payload = self->language->external_scanner.create();\n    }\n  }\n}\n\nstatic void ts_parser__external_scanner_destroy(\n  TSParser *self\n) {\n  if (\n    self->language &&\n    self->external_scanner_payload &&\n    self->language->external_scanner.destroy &&\n    !ts_language_is_wasm(self->language)\n  ) {\n    self->language->external_scanner.destroy(\n      self->external_scanner_payload\n    );\n  }\n  self->external_scanner_payload = NULL;\n}\n\nstatic unsigned ts_parser__external_scanner_serialize(\n  TSParser *self\n) {\n  if (ts_language_is_wasm(self->language)) {\n    return ts_wasm_store_call_scanner_serialize(\n      self->wasm_store,\n      (uintptr_t)self->external_scanner_payload,\n      self->lexer.debug_buffer\n    );\n  } else {\n    uint32_t length = self->language->external_scanner.serialize(\n      self->external_scanner_payload,\n      self->lexer.debug_buffer\n    );\n    ts_assert(length <= TREE_SITTER_SERIALIZATION_BUFFER_SIZE);\n    return length;\n  }\n}\n\nstatic void ts_parser__external_scanner_deserialize(\n  TSParser *self,\n  Subtree external_token\n) {\n  const char *data = NULL;\n  uint32_t length = 0;\n  if (external_token.ptr) {\n    data = ts_external_scanner_state_data(&external_token.ptr->external_scanner_state);\n    length = external_token.ptr->external_scanner_state.length;\n  }\n\n  if (ts_language_is_wasm(self->language)) {\n    ts_wasm_store_call_scanner_deserialize(\n      self->wasm_store,\n      (uintptr_t)self->external_scanner_payload,\n      data,\n      length\n    );\n    if (ts_wasm_store_has_error(self->wasm_store)) {\n      self->has_scanner_error = true;\n    }\n  } else {\n    self->language->external_scanner.deserialize(\n      self->external_scanner_payload,\n      data,\n      length\n    );\n  }\n}\n\nstatic bool ts_parser__external_scanner_scan(\n  TSParser *self,\n  TSStateId external_lex_state\n) {\n  if (ts_language_is_wasm(self->language)) {\n    bool result = ts_wasm_store_call_scanner_scan(\n      self->wasm_store,\n      (uintptr_t)self->external_scanner_payload,\n      external_lex_state * self->language->external_token_count\n    );\n    if (ts_wasm_store_has_error(self->wasm_store)) {\n      self->has_scanner_error = true;\n    }\n    return result;\n  } else {\n    const bool *valid_external_tokens = ts_language_enabled_external_tokens(\n      self->language,\n      external_lex_state\n    );\n    return self->language->external_scanner.scan(\n      self->external_scanner_payload,\n      &self->lexer.data,\n      valid_external_tokens\n    );\n  }\n}\n\nstatic bool ts_parser__can_reuse_first_leaf(\n  TSParser *self,\n  TSStateId state,\n  Subtree tree,\n  TableEntry *table_entry\n) {\n  TSSymbol leaf_symbol = ts_subtree_leaf_symbol(tree);\n  TSStateId leaf_state = ts_subtree_leaf_parse_state(tree);\n  TSLexerMode current_lex_mode = ts_language_lex_mode_for_state(self->language, state);\n  TSLexerMode leaf_lex_mode = ts_language_lex_mode_for_state(self->language, leaf_state);\n\n  // At the end of a non-terminal extra node, the lexer normally returns\n  // NULL, which indicates that the parser should look for a reduce action\n  // at symbol `0`. Avoid reusing tokens in this situation to ensure that\n  // the same thing happens when incrementally reparsing.\n  if (current_lex_mode.lex_state == (uint16_t)(-1)) return false;\n\n  // If the token was created in a state with the same set of lookaheads, it is reusable.\n  if (\n    table_entry->action_count > 0 &&\n    memcmp(&leaf_lex_mode, &current_lex_mode, sizeof(TSLexerMode)) == 0 &&\n    (\n      leaf_symbol != self->language->keyword_capture_token ||\n      (!ts_subtree_is_keyword(tree) && ts_subtree_parse_state(tree) == state)\n    )\n  ) return true;\n\n  // Empty tokens are not reusable in states with different lookaheads.\n  if (ts_subtree_size(tree).bytes == 0 && leaf_symbol != ts_builtin_sym_end) return false;\n\n  // If the current state allows external tokens or other tokens that conflict with this\n  // token, this token is not reusable.\n  return current_lex_mode.external_lex_state == 0 && table_entry->is_reusable;\n}\n\nstatic Subtree ts_parser__lex(\n  TSParser *self,\n  StackVersion version,\n  TSStateId parse_state\n) {\n  TSLexerMode lex_mode = ts_language_lex_mode_for_state(self->language, parse_state);\n  if (lex_mode.lex_state == (uint16_t)-1) {\n    LOG(\"no_lookahead_after_non_terminal_extra\");\n    return NULL_SUBTREE;\n  }\n\n  const Length start_position = ts_stack_position(self->stack, version);\n  const Subtree external_token = ts_stack_last_external_token(self->stack, version);\n\n  bool found_external_token = false;\n  bool error_mode = parse_state == ERROR_STATE;\n  bool skipped_error = false;\n  bool called_get_column = false;\n  int32_t first_error_character = 0;\n  Length error_start_position = length_zero();\n  Length error_end_position = length_zero();\n  uint32_t lookahead_end_byte = 0;\n  uint32_t external_scanner_state_len = 0;\n  bool external_scanner_state_changed = false;\n  ts_lexer_reset(&self->lexer, start_position);\n\n  for (;;) {\n    bool found_token = false;\n    Length current_position = self->lexer.current_position;\n    ColumnData column_data = self->lexer.column_data;\n\n    if (lex_mode.external_lex_state != 0) {\n      LOG(\n        \"lex_external state:%d, row:%u, column:%u\",\n        lex_mode.external_lex_state,\n        current_position.extent.row,\n        current_position.extent.column\n      );\n      ts_lexer_start(&self->lexer);\n      ts_parser__external_scanner_deserialize(self, external_token);\n      found_token = ts_parser__external_scanner_scan(self, lex_mode.external_lex_state);\n      if (self->has_scanner_error) return NULL_SUBTREE;\n      ts_lexer_finish(&self->lexer, &lookahead_end_byte);\n\n      if (found_token) {\n        external_scanner_state_len = ts_parser__external_scanner_serialize(self);\n        external_scanner_state_changed = !ts_external_scanner_state_eq(\n          ts_subtree_external_scanner_state(external_token),\n          self->lexer.debug_buffer,\n          external_scanner_state_len\n        );\n\n        // Avoid infinite loops caused by the external scanner returning empty tokens.\n        // Empty tokens are needed in some circumstances, e.g. indent/dedent tokens\n        // in Python. Ignore the following classes of empty tokens:\n        //\n        // * Tokens produced during error recovery. When recovering from an error,\n        //   all tokens are allowed, so it's easy to accidentally return unwanted\n        //   empty tokens.\n        // * Tokens that are marked as 'extra' in the grammar. These don't change\n        //   the parse state, so they would definitely cause an infinite loop.\n        if (\n          self->lexer.token_end_position.bytes <= current_position.bytes &&\n          !external_scanner_state_changed\n        ) {\n          TSSymbol symbol = self->language->external_scanner.symbol_map[self->lexer.data.result_symbol];\n          TSStateId next_parse_state = ts_language_next_state(self->language, parse_state, symbol);\n          bool token_is_extra = (next_parse_state == parse_state);\n          if (error_mode || !ts_stack_has_advanced_since_error(self->stack, version) || token_is_extra) {\n            LOG(\n              \"ignore_empty_external_token symbol:%s\",\n              SYM_NAME(self->language->external_scanner.symbol_map[self->lexer.data.result_symbol])\n            );\n            found_token = false;\n          }\n        }\n      }\n\n      if (found_token) {\n        found_external_token = true;\n        called_get_column = self->lexer.did_get_column;\n        break;\n      }\n\n      ts_lexer_reset(&self->lexer, current_position);\n      self->lexer.column_data = column_data;\n    }\n\n    LOG(\n      \"lex_internal state:%d, row:%u, column:%u\",\n      lex_mode.lex_state,\n      current_position.extent.row,\n      current_position.extent.column\n    );\n    ts_lexer_start(&self->lexer);\n    found_token = ts_parser__call_main_lex_fn(self, lex_mode);\n    ts_lexer_finish(&self->lexer, &lookahead_end_byte);\n    if (found_token) break;\n\n    if (!error_mode) {\n      error_mode = true;\n      lex_mode = ts_language_lex_mode_for_state(self->language, ERROR_STATE);\n      ts_lexer_reset(&self->lexer, start_position);\n      continue;\n    }\n\n    if (!skipped_error) {\n      LOG(\"skip_unrecognized_character\");\n      skipped_error = true;\n      error_start_position = self->lexer.token_start_position;\n      error_end_position = self->lexer.token_start_position;\n      first_error_character = self->lexer.data.lookahead;\n    }\n\n    if (self->lexer.current_position.bytes == error_end_position.bytes) {\n      if (self->lexer.data.eof(&self->lexer.data)) {\n        self->lexer.data.result_symbol = ts_builtin_sym_error;\n        break;\n      }\n      self->lexer.data.advance(&self->lexer.data, false);\n    }\n\n    error_end_position = self->lexer.current_position;\n  }\n\n  Subtree result;\n  if (skipped_error) {\n    Length padding = length_sub(error_start_position, start_position);\n    Length size = length_sub(error_end_position, error_start_position);\n    uint32_t lookahead_bytes = lookahead_end_byte - error_end_position.bytes;\n    result = ts_subtree_new_error(\n      &self->tree_pool,\n      first_error_character,\n      padding,\n      size,\n      lookahead_bytes,\n      parse_state,\n      self->language\n    );\n  } else {\n    bool is_keyword = false;\n    TSSymbol symbol = self->lexer.data.result_symbol;\n    Length padding = length_sub(self->lexer.token_start_position, start_position);\n    Length size = length_sub(self->lexer.token_end_position, self->lexer.token_start_position);\n    uint32_t lookahead_bytes = lookahead_end_byte - self->lexer.token_end_position.bytes;\n\n    if (found_external_token) {\n      symbol = self->language->external_scanner.symbol_map[symbol];\n    } else if (symbol == self->language->keyword_capture_token && symbol != 0) {\n      uint32_t end_byte = self->lexer.token_end_position.bytes;\n      ts_lexer_reset(&self->lexer, self->lexer.token_start_position);\n      ts_lexer_start(&self->lexer);\n\n      is_keyword = ts_parser__call_keyword_lex_fn(self);\n\n      if (\n        is_keyword &&\n        self->lexer.token_end_position.bytes == end_byte &&\n        (\n          ts_language_has_actions(self->language, parse_state, self->lexer.data.result_symbol) ||\n          ts_language_is_reserved_word(self->language, parse_state, self->lexer.data.result_symbol)\n        )\n      ) {\n        symbol = self->lexer.data.result_symbol;\n      }\n    }\n\n    result = ts_subtree_new_leaf(\n      &self->tree_pool,\n      symbol,\n      padding,\n      size,\n      lookahead_bytes,\n      parse_state,\n      found_external_token,\n      called_get_column,\n      is_keyword,\n      self->language\n    );\n\n    if (found_external_token) {\n      MutableSubtree mut_result = ts_subtree_to_mut_unsafe(result);\n      ts_external_scanner_state_init(\n        &mut_result.ptr->external_scanner_state,\n        self->lexer.debug_buffer,\n        external_scanner_state_len\n      );\n      mut_result.ptr->has_external_scanner_state_change = external_scanner_state_changed;\n    }\n  }\n\n  LOG_LOOKAHEAD(\n    SYM_NAME(ts_subtree_symbol(result)),\n    ts_subtree_total_size(result).bytes\n  );\n  return result;\n}\n\nstatic Subtree ts_parser__get_cached_token(\n  TSParser *self,\n  TSStateId state,\n  size_t position,\n  Subtree last_external_token,\n  TableEntry *table_entry\n) {\n  TokenCache *cache = &self->token_cache;\n  if (\n    cache->token.ptr && cache->byte_index == position &&\n    ts_subtree_external_scanner_state_eq(cache->last_external_token, last_external_token)\n  ) {\n    ts_language_table_entry(self->language, state, ts_subtree_symbol(cache->token), table_entry);\n    if (ts_parser__can_reuse_first_leaf(self, state, cache->token, table_entry)) {\n      ts_subtree_retain(cache->token);\n      return cache->token;\n    }\n  }\n  return NULL_SUBTREE;\n}\n\nstatic void ts_parser__set_cached_token(\n  TSParser *self,\n  uint32_t byte_index,\n  Subtree last_external_token,\n  Subtree token\n) {\n  TokenCache *cache = &self->token_cache;\n  if (token.ptr) ts_subtree_retain(token);\n  if (last_external_token.ptr) ts_subtree_retain(last_external_token);\n  if (cache->token.ptr) ts_subtree_release(&self->tree_pool, cache->token);\n  if (cache->last_external_token.ptr) ts_subtree_release(&self->tree_pool, cache->last_external_token);\n  cache->token = token;\n  cache->byte_index = byte_index;\n  cache->last_external_token = last_external_token;\n}\n\nstatic bool ts_parser__has_included_range_difference(\n  const TSParser *self,\n  uint32_t start_position,\n  uint32_t end_position\n) {\n  return ts_range_array_intersects(\n    &self->included_range_differences,\n    self->included_range_difference_index,\n    start_position,\n    end_position\n  );\n}\n\nstatic Subtree ts_parser__reuse_node(\n  TSParser *self,\n  StackVersion version,\n  TSStateId *state,\n  uint32_t position,\n  Subtree last_external_token,\n  TableEntry *table_entry\n) {\n  Subtree result;\n  while ((result = reusable_node_tree(&self->reusable_node)).ptr) {\n    uint32_t byte_offset = reusable_node_byte_offset(&self->reusable_node);\n    uint32_t end_byte_offset = byte_offset + ts_subtree_total_bytes(result);\n\n    // Do not reuse an EOF node if the included ranges array has changes\n    // later on in the file.\n    if (ts_subtree_is_eof(result)) end_byte_offset = UINT32_MAX;\n\n    if (byte_offset > position) {\n      LOG(\"before_reusable_node symbol:%s\", TREE_NAME(result));\n      break;\n    }\n\n    if (byte_offset < position) {\n      LOG(\"past_reusable_node symbol:%s\", TREE_NAME(result));\n      if (end_byte_offset <= position || !reusable_node_descend(&self->reusable_node)) {\n        reusable_node_advance(&self->reusable_node);\n      }\n      continue;\n    }\n\n    if (!ts_subtree_external_scanner_state_eq(self->reusable_node.last_external_token, last_external_token)) {\n      LOG(\"reusable_node_has_different_external_scanner_state symbol:%s\", TREE_NAME(result));\n      reusable_node_advance(&self->reusable_node);\n      continue;\n    }\n\n    const char *reason = NULL;\n    if (ts_subtree_has_changes(result)) {\n      reason = \"has_changes\";\n    } else if (ts_subtree_is_error(result)) {\n      reason = \"is_error\";\n    } else if (ts_subtree_missing(result)) {\n      reason = \"is_missing\";\n    } else if (ts_subtree_is_fragile(result)) {\n      reason = \"is_fragile\";\n    } else if (ts_parser__has_included_range_difference(self, byte_offset, end_byte_offset)) {\n      reason = \"contains_different_included_range\";\n    }\n\n    if (reason) {\n      LOG(\"cant_reuse_node_%s tree:%s\", reason, TREE_NAME(result));\n      if (!reusable_node_descend(&self->reusable_node)) {\n        reusable_node_advance(&self->reusable_node);\n        ts_parser__breakdown_top_of_stack(self, version);\n        *state = ts_stack_state(self->stack, version);\n      }\n      continue;\n    }\n\n    TSSymbol leaf_symbol = ts_subtree_leaf_symbol(result);\n    ts_language_table_entry(self->language, *state, leaf_symbol, table_entry);\n    if (!ts_parser__can_reuse_first_leaf(self, *state, result, table_entry)) {\n      LOG(\n        \"cant_reuse_node symbol:%s, first_leaf_symbol:%s\",\n        TREE_NAME(result),\n        SYM_NAME(leaf_symbol)\n      );\n      reusable_node_advance_past_leaf(&self->reusable_node);\n      break;\n    }\n\n    LOG(\"reuse_node symbol:%s\", TREE_NAME(result));\n    ts_subtree_retain(result);\n    return result;\n  }\n\n  return NULL_SUBTREE;\n}\n\n// Determine if a given tree should be replaced by an alternative tree.\n//\n// The decision is based on the trees' error costs (if any), their dynamic precedence,\n// and finally, as a default, by a recursive comparison of the trees' symbols.\nstatic bool ts_parser__select_tree(TSParser *self, Subtree left, Subtree right) {\n  if (!left.ptr) return true;\n  if (!right.ptr) return false;\n\n  if (ts_subtree_error_cost(right) < ts_subtree_error_cost(left)) {\n    LOG(\"select_smaller_error symbol:%s, over_symbol:%s\", TREE_NAME(right), TREE_NAME(left));\n    return true;\n  }\n\n  if (ts_subtree_error_cost(left) < ts_subtree_error_cost(right)) {\n    LOG(\"select_smaller_error symbol:%s, over_symbol:%s\", TREE_NAME(left), TREE_NAME(right));\n    return false;\n  }\n\n  if (ts_subtree_dynamic_precedence(right) > ts_subtree_dynamic_precedence(left)) {\n    LOG(\"select_higher_precedence symbol:%s, prec:%\" PRId32 \", over_symbol:%s, other_prec:%\" PRId32,\n        TREE_NAME(right), ts_subtree_dynamic_precedence(right), TREE_NAME(left),\n        ts_subtree_dynamic_precedence(left));\n    return true;\n  }\n\n  if (ts_subtree_dynamic_precedence(left) > ts_subtree_dynamic_precedence(right)) {\n    LOG(\"select_higher_precedence symbol:%s, prec:%\" PRId32 \", over_symbol:%s, other_prec:%\" PRId32,\n        TREE_NAME(left), ts_subtree_dynamic_precedence(left), TREE_NAME(right),\n        ts_subtree_dynamic_precedence(right));\n    return false;\n  }\n\n  if (ts_subtree_error_cost(left) > 0) return true;\n\n  int comparison = ts_subtree_compare(left, right, &self->tree_pool);\n  switch (comparison) {\n    case -1:\n      LOG(\"select_earlier symbol:%s, over_symbol:%s\", TREE_NAME(left), TREE_NAME(right));\n      return false;\n      break;\n    case 1:\n      LOG(\"select_earlier symbol:%s, over_symbol:%s\", TREE_NAME(right), TREE_NAME(left));\n      return true;\n    default:\n      LOG(\"select_existing symbol:%s, over_symbol:%s\", TREE_NAME(left), TREE_NAME(right));\n      return false;\n  }\n}\n\n// Determine if a given tree's children should be replaced by an alternative\n// array of children.\nstatic bool ts_parser__select_children(\n  TSParser *self,\n  Subtree left,\n  const SubtreeArray *children\n) {\n  array_assign(&self->scratch_trees, children);\n\n  // Create a temporary subtree using the scratch trees array. This node does\n  // not perform any allocation except for possibly growing the array to make\n  // room for its own heap data. The scratch tree is never explicitly released,\n  // so the same 'scratch trees' array can be reused again later.\n  MutableSubtree scratch_tree = ts_subtree_new_node(\n    ts_subtree_symbol(left),\n    &self->scratch_trees,\n    0,\n    self->language\n  );\n\n  return ts_parser__select_tree(\n    self,\n    left,\n    ts_subtree_from_mut(scratch_tree)\n  );\n}\n\nstatic void ts_parser__shift(\n  TSParser *self,\n  StackVersion version,\n  TSStateId state,\n  Subtree lookahead,\n  bool extra\n) {\n  bool is_leaf = ts_subtree_child_count(lookahead) == 0;\n  Subtree subtree_to_push = lookahead;\n  if (extra != ts_subtree_extra(lookahead) && is_leaf) {\n    MutableSubtree result = ts_subtree_make_mut(&self->tree_pool, lookahead);\n    ts_subtree_set_extra(&result, extra);\n    subtree_to_push = ts_subtree_from_mut(result);\n  }\n\n  ts_stack_push(self->stack, version, subtree_to_push, !is_leaf, state);\n  if (ts_subtree_has_external_tokens(subtree_to_push)) {\n    ts_stack_set_last_external_token(\n      self->stack, version, ts_subtree_last_external_token(subtree_to_push)\n    );\n  }\n}\n\nstatic StackVersion ts_parser__reduce(\n  TSParser *self,\n  StackVersion version,\n  TSSymbol symbol,\n  uint32_t count,\n  int dynamic_precedence,\n  uint16_t production_id,\n  bool is_fragile,\n  bool end_of_non_terminal_extra\n) {\n  uint32_t initial_version_count = ts_stack_version_count(self->stack);\n\n  // Pop the given number of nodes from the given version of the parse stack.\n  // If stack versions have previously merged, then there may be more than one\n  // path back through the stack. For each path, create a new parent node to\n  // contain the popped children, and push it onto the stack in place of the\n  // children.\n  StackSliceArray pop = ts_stack_pop_count(self->stack, version, count);\n  uint32_t removed_version_count = 0;\n  uint32_t halted_version_count = ts_stack_halted_version_count(self->stack);\n  for (uint32_t i = 0; i < pop.size; i++) {\n    StackSlice slice = *array_get(&pop, i);\n    StackVersion slice_version = slice.version - removed_version_count;\n\n    // This is where new versions are added to the parse stack. The versions\n    // will all be sorted and truncated at the end of the outer parsing loop.\n    // Allow the maximum version count to be temporarily exceeded, but only\n    // by a limited threshold.\n    if (slice_version > MAX_VERSION_COUNT + MAX_VERSION_COUNT_OVERFLOW + halted_version_count) {\n      ts_stack_remove_version(self->stack, slice_version);\n      ts_subtree_array_delete(&self->tree_pool, &slice.subtrees);\n      removed_version_count++;\n      while (i + 1 < pop.size) {\n        LOG(\"aborting reduce with too many versions\")\n        StackSlice next_slice = *array_get(&pop, i + 1);\n        if (next_slice.version != slice.version) break;\n        ts_subtree_array_delete(&self->tree_pool, &next_slice.subtrees);\n        i++;\n      }\n      continue;\n    }\n\n    // Extra tokens on top of the stack should not be included in this new parent\n    // node. They will be re-pushed onto the stack after the parent node is\n    // created and pushed.\n    SubtreeArray children = slice.subtrees;\n    ts_subtree_array_remove_trailing_extras(&children, &self->trailing_extras);\n\n    MutableSubtree parent = ts_subtree_new_node(\n      symbol, &children, production_id, self->language\n    );\n\n    // This pop operation may have caused multiple stack versions to collapse\n    // into one, because they all diverged from a common state. In that case,\n    // choose one of the arrays of trees to be the parent node's children, and\n    // delete the rest of the tree arrays.\n    while (i + 1 < pop.size) {\n      StackSlice next_slice = *array_get(&pop, i + 1);\n      if (next_slice.version != slice.version) break;\n      i++;\n\n      SubtreeArray next_slice_children = next_slice.subtrees;\n      ts_subtree_array_remove_trailing_extras(&next_slice_children, &self->trailing_extras2);\n\n      if (ts_parser__select_children(\n        self,\n        ts_subtree_from_mut(parent),\n        &next_slice_children\n      )) {\n        ts_subtree_array_clear(&self->tree_pool, &self->trailing_extras);\n        ts_subtree_release(&self->tree_pool, ts_subtree_from_mut(parent));\n        array_swap(&self->trailing_extras, &self->trailing_extras2);\n        parent = ts_subtree_new_node(\n          symbol, &next_slice_children, production_id, self->language\n        );\n      } else {\n        array_clear(&self->trailing_extras2);\n        ts_subtree_array_delete(&self->tree_pool, &next_slice.subtrees);\n      }\n    }\n\n    TSStateId state = ts_stack_state(self->stack, slice_version);\n    TSStateId next_state = ts_language_next_state(self->language, state, symbol);\n    if (end_of_non_terminal_extra && next_state == state) {\n      parent.ptr->extra = true;\n    }\n    if (is_fragile || pop.size > 1 || initial_version_count > 1) {\n      parent.ptr->fragile_left = true;\n      parent.ptr->fragile_right = true;\n      parent.ptr->parse_state = TS_TREE_STATE_NONE;\n    } else {\n      parent.ptr->parse_state = state;\n    }\n    parent.ptr->dynamic_precedence += dynamic_precedence;\n\n    // Push the parent node onto the stack, along with any extra tokens that\n    // were previously on top of the stack.\n    ts_stack_push(self->stack, slice_version, ts_subtree_from_mut(parent), false, next_state);\n    for (uint32_t j = 0; j < self->trailing_extras.size; j++) {\n      ts_stack_push(self->stack, slice_version, *array_get(&self->trailing_extras, j), false, next_state);\n    }\n\n    for (StackVersion j = 0; j < slice_version; j++) {\n      if (j == version) continue;\n      if (ts_stack_merge(self->stack, j, slice_version)) {\n        removed_version_count++;\n        break;\n      }\n    }\n  }\n\n  // Return the first new stack version that was created.\n  return ts_stack_version_count(self->stack) > initial_version_count\n    ? initial_version_count\n    : STACK_VERSION_NONE;\n}\n\nstatic void ts_parser__accept(\n  TSParser *self,\n  StackVersion version,\n  Subtree lookahead\n) {\n  ts_assert(ts_subtree_is_eof(lookahead));\n  ts_stack_push(self->stack, version, lookahead, false, 1);\n\n  StackSliceArray pop = ts_stack_pop_all(self->stack, version);\n  for (uint32_t i = 0; i < pop.size; i++) {\n    SubtreeArray trees = array_get(&pop, i)->subtrees;\n\n    Subtree root = NULL_SUBTREE;\n    for (uint32_t j = trees.size - 1; j + 1 > 0; j--) {\n      Subtree tree = *array_get(&trees, j);\n      if (!ts_subtree_extra(tree)) {\n        ts_assert(!tree.data.is_inline);\n        uint32_t child_count = ts_subtree_child_count(tree);\n        const Subtree *children = ts_subtree_children(tree);\n        for (uint32_t k = 0; k < child_count; k++) {\n          ts_subtree_retain(children[k]);\n        }\n        array_splice(&trees, j, 1, child_count, children);\n        root = ts_subtree_from_mut(ts_subtree_new_node(\n          ts_subtree_symbol(tree),\n          &trees,\n          tree.ptr->production_id,\n          self->language\n        ));\n        ts_subtree_release(&self->tree_pool, tree);\n        break;\n      }\n    }\n\n    ts_assert(root.ptr);\n    self->accept_count++;\n\n    if (self->finished_tree.ptr) {\n      if (ts_parser__select_tree(self, self->finished_tree, root)) {\n        ts_subtree_release(&self->tree_pool, self->finished_tree);\n        self->finished_tree = root;\n      } else {\n        ts_subtree_release(&self->tree_pool, root);\n      }\n    } else {\n      self->finished_tree = root;\n    }\n  }\n\n  ts_stack_remove_version(self->stack, array_get(&pop, 0)->version);\n  ts_stack_halt(self->stack, version);\n}\n\nstatic bool ts_parser__do_all_potential_reductions(\n  TSParser *self,\n  StackVersion starting_version,\n  TSSymbol lookahead_symbol\n) {\n  uint32_t initial_version_count = ts_stack_version_count(self->stack);\n\n  bool can_shift_lookahead_symbol = false;\n  StackVersion version = starting_version;\n  for (unsigned i = 0; true; i++) {\n    uint32_t version_count = ts_stack_version_count(self->stack);\n    if (version >= version_count) break;\n\n    bool merged = false;\n    for (StackVersion j = initial_version_count; j < version; j++) {\n      if (ts_stack_merge(self->stack, j, version)) {\n        merged = true;\n        break;\n      }\n    }\n    if (merged) continue;\n\n    TSStateId state = ts_stack_state(self->stack, version);\n    bool has_shift_action = false;\n    array_clear(&self->reduce_actions);\n\n    TSSymbol first_symbol, end_symbol;\n    if (lookahead_symbol != 0) {\n      first_symbol = lookahead_symbol;\n      end_symbol = lookahead_symbol + 1;\n    } else {\n      first_symbol = 1;\n      end_symbol = self->language->token_count;\n    }\n\n    for (TSSymbol symbol = first_symbol; symbol < end_symbol; symbol++) {\n      TableEntry entry;\n      ts_language_table_entry(self->language, state, symbol, &entry);\n      for (uint32_t j = 0; j < entry.action_count; j++) {\n        TSParseAction action = entry.actions[j];\n        switch (action.type) {\n          case TSParseActionTypeShift:\n          case TSParseActionTypeRecover:\n            if (!action.shift.extra && !action.shift.repetition) has_shift_action = true;\n            break;\n          case TSParseActionTypeReduce:\n            if (action.reduce.child_count > 0)\n              ts_reduce_action_set_add(&self->reduce_actions, (ReduceAction) {\n                .symbol = action.reduce.symbol,\n                .count = action.reduce.child_count,\n                .dynamic_precedence = action.reduce.dynamic_precedence,\n                .production_id = action.reduce.production_id,\n              });\n            break;\n          default:\n            break;\n        }\n      }\n    }\n\n    StackVersion reduction_version = STACK_VERSION_NONE;\n    for (uint32_t j = 0; j < self->reduce_actions.size; j++) {\n      ReduceAction action = *array_get(&self->reduce_actions, j);\n\n      reduction_version = ts_parser__reduce(\n        self, version, action.symbol, action.count,\n        action.dynamic_precedence, action.production_id,\n        true, false\n      );\n    }\n\n    if (has_shift_action) {\n      can_shift_lookahead_symbol = true;\n    } else if (reduction_version != STACK_VERSION_NONE && i < MAX_VERSION_COUNT) {\n      ts_stack_renumber_version(self->stack, reduction_version, version);\n      continue;\n    } else if (lookahead_symbol != 0) {\n      ts_stack_remove_version(self->stack, version);\n    }\n\n    if (version == starting_version) {\n      version = version_count;\n    } else {\n      version++;\n    }\n  }\n\n  return can_shift_lookahead_symbol;\n}\n\nstatic bool ts_parser__recover_to_state(\n  TSParser *self,\n  StackVersion version,\n  unsigned depth,\n  TSStateId goal_state\n) {\n  StackSliceArray pop = ts_stack_pop_count(self->stack, version, depth);\n  StackVersion previous_version = STACK_VERSION_NONE;\n\n  for (unsigned i = 0; i < pop.size; i++) {\n    StackSlice slice = *array_get(&pop, i);\n\n    if (slice.version == previous_version) {\n      ts_subtree_array_delete(&self->tree_pool, &slice.subtrees);\n      array_erase(&pop, i--);\n      continue;\n    }\n\n    if (ts_stack_state(self->stack, slice.version) != goal_state) {\n      ts_stack_halt(self->stack, slice.version);\n      ts_subtree_array_delete(&self->tree_pool, &slice.subtrees);\n      array_erase(&pop, i--);\n      continue;\n    }\n\n    SubtreeArray error_trees = ts_stack_pop_error(self->stack, slice.version);\n    if (error_trees.size > 0) {\n      ts_assert(error_trees.size == 1);\n      Subtree error_tree = *array_get(&error_trees, 0);\n      uint32_t error_child_count = ts_subtree_child_count(error_tree);\n      if (error_child_count > 0) {\n        array_splice(&slice.subtrees, 0, 0, error_child_count, ts_subtree_children(error_tree));\n        for (unsigned j = 0; j < error_child_count; j++) {\n          ts_subtree_retain(*array_get(&slice.subtrees, j));\n        }\n      }\n      ts_subtree_array_delete(&self->tree_pool, &error_trees);\n    }\n\n    ts_subtree_array_remove_trailing_extras(&slice.subtrees, &self->trailing_extras);\n\n    if (slice.subtrees.size > 0) {\n      Subtree error = ts_subtree_new_error_node(&slice.subtrees, true, self->language);\n      ts_stack_push(self->stack, slice.version, error, false, goal_state);\n    } else {\n      array_delete(&slice.subtrees);\n    }\n\n    for (unsigned j = 0; j < self->trailing_extras.size; j++) {\n      Subtree tree = *array_get(&self->trailing_extras, j);\n      ts_stack_push(self->stack, slice.version, tree, false, goal_state);\n    }\n\n    previous_version = slice.version;\n  }\n\n  return previous_version != STACK_VERSION_NONE;\n}\n\nstatic void ts_parser__recover(\n  TSParser *self,\n  StackVersion version,\n  Subtree lookahead\n) {\n  bool did_recover = false;\n  unsigned previous_version_count = ts_stack_version_count(self->stack);\n  Length position = ts_stack_position(self->stack, version);\n  StackSummary *summary = ts_stack_get_summary(self->stack, version);\n  unsigned node_count_since_error = ts_stack_node_count_since_error(self->stack, version);\n  unsigned current_error_cost = ts_stack_error_cost(self->stack, version);\n\n  // When the parser is in the error state, there are two strategies for recovering with a\n  // given lookahead token:\n  // 1. Find a previous state on the stack in which that lookahead token would be valid. Then,\n  //    create a new stack version that is in that state again. This entails popping all of the\n  //    subtrees that have been pushed onto the stack since that previous state, and wrapping\n  //    them in an ERROR node.\n  // 2. Wrap the lookahead token in an ERROR node, push that ERROR node onto the stack, and\n  //    move on to the next lookahead token, remaining in the error state.\n  //\n  // First, try the strategy 1. Upon entering the error state, the parser recorded a summary\n  // of the previous parse states and their depths. Look at each state in the summary, to see\n  // if the current lookahead token would be valid in that state.\n  if (summary && !ts_subtree_is_error(lookahead)) {\n    for (unsigned i = 0; i < summary->size; i++) {\n      StackSummaryEntry entry = *array_get(summary, i);\n\n      if (entry.state == ERROR_STATE) continue;\n      if (entry.position.bytes == position.bytes) continue;\n      unsigned depth = entry.depth;\n      if (node_count_since_error > 0) depth++;\n\n      // Do not recover in ways that create redundant stack versions.\n      bool would_merge = false;\n      for (unsigned j = 0; j < previous_version_count; j++) {\n        if (\n          ts_stack_state(self->stack, j) == entry.state &&\n          ts_stack_position(self->stack, j).bytes == position.bytes\n        ) {\n          would_merge = true;\n          break;\n        }\n      }\n      if (would_merge) continue;\n\n      // Do not recover if the result would clearly be worse than some existing stack version.\n      unsigned new_cost =\n        current_error_cost +\n        entry.depth * ERROR_COST_PER_SKIPPED_TREE +\n        (position.bytes - entry.position.bytes) * ERROR_COST_PER_SKIPPED_CHAR +\n        (position.extent.row - entry.position.extent.row) * ERROR_COST_PER_SKIPPED_LINE;\n      if (ts_parser__better_version_exists(self, version, false, new_cost)) break;\n\n      // If the current lookahead token is valid in some previous state, recover to that state.\n      // Then stop looking for further recoveries.\n      if (ts_language_has_actions(self->language, entry.state, ts_subtree_symbol(lookahead))) {\n        if (ts_parser__recover_to_state(self, version, depth, entry.state)) {\n          did_recover = true;\n          LOG(\"recover_to_previous state:%u, depth:%u\", entry.state, depth);\n          LOG_STACK();\n          break;\n        }\n      }\n    }\n  }\n\n  // In the process of attempting to recover, some stack versions may have been created\n  // and subsequently halted. Remove those versions.\n  for (unsigned i = previous_version_count; i < ts_stack_version_count(self->stack); i++) {\n    if (!ts_stack_is_active(self->stack, i)) {\n      LOG(\"removed paused version:%u\", i);\n      ts_stack_remove_version(self->stack, i--);\n      LOG_STACK();\n    }\n  }\n\n  // If the parser is still in the error state at the end of the file, just wrap everything\n  // in an ERROR node and terminate.\n  if (ts_subtree_is_eof(lookahead)) {\n    LOG(\"recover_eof\");\n    SubtreeArray children = array_new();\n    Subtree parent = ts_subtree_new_error_node(&children, false, self->language);\n    ts_stack_push(self->stack, version, parent, false, 1);\n    ts_parser__accept(self, version, lookahead);\n    return;\n  }\n\n  // If strategy 1 succeeded, a new stack version will have been created which is able to handle\n  // the current lookahead token. Now, in addition, try strategy 2 described above: skip the\n  // current lookahead token by wrapping it in an ERROR node.\n\n  // Don't pursue this additional strategy if there are already too many stack versions.\n  if (did_recover && ts_stack_version_count(self->stack) > MAX_VERSION_COUNT) {\n    ts_stack_halt(self->stack, version);\n    ts_subtree_release(&self->tree_pool, lookahead);\n    return;\n  }\n\n  if (\n    did_recover &&\n    ts_subtree_has_external_scanner_state_change(lookahead)\n  ) {\n    ts_stack_halt(self->stack, version);\n    ts_subtree_release(&self->tree_pool, lookahead);\n    return;\n  }\n\n  // Do not recover if the result would clearly be worse than some existing stack version.\n  unsigned new_cost =\n    current_error_cost + ERROR_COST_PER_SKIPPED_TREE +\n    ts_subtree_total_bytes(lookahead) * ERROR_COST_PER_SKIPPED_CHAR +\n    ts_subtree_total_size(lookahead).extent.row * ERROR_COST_PER_SKIPPED_LINE;\n  if (ts_parser__better_version_exists(self, version, false, new_cost)) {\n    ts_stack_halt(self->stack, version);\n    ts_subtree_release(&self->tree_pool, lookahead);\n    return;\n  }\n\n  // If the current lookahead token is an extra token, mark it as extra. This means it won't\n  // be counted in error cost calculations.\n  unsigned n;\n  const TSParseAction *actions = ts_language_actions(self->language, 1, ts_subtree_symbol(lookahead), &n);\n  if (n > 0 && actions[n - 1].type == TSParseActionTypeShift && actions[n - 1].shift.extra) {\n    MutableSubtree mutable_lookahead = ts_subtree_make_mut(&self->tree_pool, lookahead);\n    ts_subtree_set_extra(&mutable_lookahead, true);\n    lookahead = ts_subtree_from_mut(mutable_lookahead);\n  }\n\n  // Wrap the lookahead token in an ERROR.\n  LOG(\"skip_token symbol:%s\", TREE_NAME(lookahead));\n  SubtreeArray children = array_new();\n  array_reserve(&children, 1);\n  array_push(&children, lookahead);\n  MutableSubtree error_repeat = ts_subtree_new_node(\n    ts_builtin_sym_error_repeat,\n    &children,\n    0,\n    self->language\n  );\n\n  // If other tokens have already been skipped, so there is already an ERROR at the top of the\n  // stack, then pop that ERROR off the stack and wrap the two ERRORs together into one larger\n  // ERROR.\n  if (node_count_since_error > 0) {\n    StackSliceArray pop = ts_stack_pop_count(self->stack, version, 1);\n\n    // TODO: Figure out how to make this condition occur.\n    // See https://github.com/atom/atom/issues/18450#issuecomment-439579778\n    // If multiple stack versions have merged at this point, just pick one of the errors\n    // arbitrarily and discard the rest.\n    if (pop.size > 1) {\n      for (unsigned i = 1; i < pop.size; i++) {\n        ts_subtree_array_delete(&self->tree_pool, &array_get(&pop, i)->subtrees);\n      }\n      while (ts_stack_version_count(self->stack) > array_get(&pop, 0)->version + 1) {\n        ts_stack_remove_version(self->stack, array_get(&pop, 0)->version + 1);\n      }\n    }\n\n    ts_stack_renumber_version(self->stack, array_get(&pop, 0)->version, version);\n    array_push(&array_get(&pop, 0)->subtrees, ts_subtree_from_mut(error_repeat));\n    error_repeat = ts_subtree_new_node(\n      ts_builtin_sym_error_repeat,\n      &array_get(&pop, 0)->subtrees,\n      0,\n      self->language\n    );\n  }\n\n  // Push the new ERROR onto the stack.\n  ts_stack_push(self->stack, version, ts_subtree_from_mut(error_repeat), false, ERROR_STATE);\n  if (ts_subtree_has_external_tokens(lookahead)) {\n    ts_stack_set_last_external_token(\n      self->stack, version, ts_subtree_last_external_token(lookahead)\n    );\n  }\n\n  bool has_error = true;\n  for (unsigned i = 0; i < ts_stack_version_count(self->stack); i++) {\n    ErrorStatus status = ts_parser__version_status(self, i);\n    if (!status.is_in_error) {\n      has_error = false;\n      break;\n    }\n  }\n  self->has_error = has_error;\n}\n\nstatic void ts_parser__handle_error(\n  TSParser *self,\n  StackVersion version,\n  Subtree lookahead\n) {\n  uint32_t previous_version_count = ts_stack_version_count(self->stack);\n\n  // Perform any reductions that can happen in this state, regardless of the lookahead. After\n  // skipping one or more invalid tokens, the parser might find a token that would have allowed\n  // a reduction to take place.\n  ts_parser__do_all_potential_reductions(self, version, 0);\n  uint32_t version_count = ts_stack_version_count(self->stack);\n  Length position = ts_stack_position(self->stack, version);\n\n  // Push a discontinuity onto the stack. Merge all of the stack versions that\n  // were created in the previous step.\n  bool did_insert_missing_token = false;\n  for (StackVersion v = version; v < version_count;) {\n    if (!did_insert_missing_token) {\n      TSStateId state = ts_stack_state(self->stack, v);\n      for (\n        TSSymbol missing_symbol = 1;\n        missing_symbol < (uint16_t)self->language->token_count;\n        missing_symbol++\n      ) {\n        TSStateId state_after_missing_symbol = ts_language_next_state(\n          self->language, state, missing_symbol\n        );\n        if (state_after_missing_symbol == 0 || state_after_missing_symbol == state) {\n          continue;\n        }\n\n        if (ts_language_has_reduce_action(\n          self->language,\n          state_after_missing_symbol,\n          ts_subtree_leaf_symbol(lookahead)\n        )) {\n          // In case the parser is currently outside of any included range, the lexer will\n          // snap to the beginning of the next included range. The missing token's padding\n          // must be assigned to position it within the next included range.\n          ts_lexer_reset(&self->lexer, position);\n          ts_lexer_mark_end(&self->lexer);\n          Length padding = length_sub(self->lexer.token_end_position, position);\n          uint32_t lookahead_bytes = ts_subtree_total_bytes(lookahead) + ts_subtree_lookahead_bytes(lookahead);\n\n          StackVersion version_with_missing_tree = ts_stack_copy_version(self->stack, v);\n          Subtree missing_tree = ts_subtree_new_missing_leaf(\n            &self->tree_pool, missing_symbol,\n            padding, lookahead_bytes,\n            self->language\n          );\n          ts_stack_push(\n            self->stack, version_with_missing_tree,\n            missing_tree, false,\n            state_after_missing_symbol\n          );\n\n          if (ts_parser__do_all_potential_reductions(\n            self, version_with_missing_tree,\n            ts_subtree_leaf_symbol(lookahead)\n          )) {\n            LOG(\n              \"recover_with_missing symbol:%s, state:%u\",\n              SYM_NAME(missing_symbol),\n              ts_stack_state(self->stack, version_with_missing_tree)\n            );\n            did_insert_missing_token = true;\n            break;\n          }\n        }\n      }\n    }\n\n    ts_stack_push(self->stack, v, NULL_SUBTREE, false, ERROR_STATE);\n    v = (v == version) ? previous_version_count : v + 1;\n  }\n\n  for (unsigned i = previous_version_count; i < version_count; i++) {\n    bool did_merge = ts_stack_merge(self->stack, version, previous_version_count);\n    ts_assert(did_merge);\n  }\n\n  ts_stack_record_summary(self->stack, version, MAX_SUMMARY_DEPTH);\n\n  // Begin recovery with the current lookahead node, rather than waiting for the\n  // next turn of the parse loop. This ensures that the tree accounts for the\n  // current lookahead token's \"lookahead bytes\" value, which describes how far\n  // the lexer needed to look ahead beyond the content of the token in order to\n  // recognize it.\n  if (ts_subtree_child_count(lookahead) > 0) {\n    ts_parser__breakdown_lookahead(self, &lookahead, ERROR_STATE, &self->reusable_node);\n  }\n  ts_parser__recover(self, version, lookahead);\n\n  LOG_STACK();\n}\n\nstatic bool ts_parser__check_progress(TSParser *self, Subtree *lookahead, const uint32_t *position, unsigned operations) {\n  self->operation_count += operations;\n  if (self->operation_count >= OP_COUNT_PER_PARSER_TIMEOUT_CHECK) {\n    self->operation_count = 0;\n  }\n  if (position != NULL) {\n    self->parse_state.current_byte_offset = *position;\n    self->parse_state.has_error = self->has_error;\n  }\n  if (\n    self->operation_count == 0 &&\n    (\n      // TODO(amaanq): remove cancellation flag & clock checks before 0.26\n      (self->cancellation_flag && atomic_load(self->cancellation_flag)) ||\n      (!clock_is_null(self->end_clock) && clock_is_gt(clock_now(), self->end_clock)) ||\n      (self->parse_options.progress_callback && self->parse_options.progress_callback(&self->parse_state))\n    )\n  ) {\n    if (lookahead && lookahead->ptr) {\n      ts_subtree_release(&self->tree_pool, *lookahead);\n    }\n    return false;\n  }\n  return true;\n}\n\nstatic bool ts_parser__advance(\n  TSParser *self,\n  StackVersion version,\n  bool allow_node_reuse\n) {\n  TSStateId state = ts_stack_state(self->stack, version);\n  uint32_t position = ts_stack_position(self->stack, version).bytes;\n  Subtree last_external_token = ts_stack_last_external_token(self->stack, version);\n\n  bool did_reuse = true;\n  Subtree lookahead = NULL_SUBTREE;\n  TableEntry table_entry = {.action_count = 0};\n\n  // If possible, reuse a node from the previous syntax tree.\n  if (allow_node_reuse) {\n    lookahead = ts_parser__reuse_node(\n      self, version, &state, position, last_external_token, &table_entry\n    );\n  }\n\n  // If no node from the previous syntax tree could be reused, then try to\n  // reuse the token previously returned by the lexer.\n  if (!lookahead.ptr) {\n    did_reuse = false;\n    lookahead = ts_parser__get_cached_token(\n      self, state, position, last_external_token, &table_entry\n    );\n  }\n\n  bool needs_lex = !lookahead.ptr;\n  for (;;) {\n    // Otherwise, re-run the lexer.\n    if (needs_lex) {\n      needs_lex = false;\n      lookahead = ts_parser__lex(self, version, state);\n      if (self->has_scanner_error) return false;\n\n      if (lookahead.ptr) {\n        ts_parser__set_cached_token(self, position, last_external_token, lookahead);\n        ts_language_table_entry(self->language, state, ts_subtree_symbol(lookahead), &table_entry);\n      }\n\n      // When parsing a non-terminal extra, a null lookahead indicates the\n      // end of the rule. The reduction is stored in the EOF table entry.\n      // After the reduction, the lexer needs to be run again.\n      else {\n        ts_language_table_entry(self->language, state, ts_builtin_sym_end, &table_entry);\n      }\n    }\n\n    // If a cancellation flag, timeout, or progress callback was provided, then check every\n    // time a fixed number of parse actions has been processed.\n    if (!ts_parser__check_progress(self, &lookahead, &position, 1)) {\n      return false;\n    }\n\n    // Process each parse action for the current lookahead token in\n    // the current state. If there are multiple actions, then this is\n    // an ambiguous state. REDUCE actions always create a new stack\n    // version, whereas SHIFT actions update the existing stack version\n    // and terminate this loop.\n    bool did_reduce = false;\n    StackVersion last_reduction_version = STACK_VERSION_NONE;\n    for (uint32_t i = 0; i < table_entry.action_count; i++) {\n      TSParseAction action = table_entry.actions[i];\n\n      switch (action.type) {\n        case TSParseActionTypeShift: {\n          if (action.shift.repetition) break;\n          TSStateId next_state;\n          if (action.shift.extra) {\n            next_state = state;\n            LOG(\"shift_extra\");\n          } else {\n            next_state = action.shift.state;\n            LOG(\"shift state:%u\", next_state);\n          }\n\n          if (ts_subtree_child_count(lookahead) > 0) {\n            ts_parser__breakdown_lookahead(self, &lookahead, state, &self->reusable_node);\n            next_state = ts_language_next_state(self->language, state, ts_subtree_symbol(lookahead));\n          }\n\n          ts_parser__shift(self, version, next_state, lookahead, action.shift.extra);\n          if (did_reuse) reusable_node_advance(&self->reusable_node);\n          return true;\n        }\n\n        case TSParseActionTypeReduce: {\n          bool is_fragile = table_entry.action_count > 1;\n          bool end_of_non_terminal_extra = lookahead.ptr == NULL;\n          LOG(\"reduce sym:%s, child_count:%u\", SYM_NAME(action.reduce.symbol), action.reduce.child_count);\n          StackVersion reduction_version = ts_parser__reduce(\n            self, version, action.reduce.symbol, action.reduce.child_count,\n            action.reduce.dynamic_precedence, action.reduce.production_id,\n            is_fragile, end_of_non_terminal_extra\n          );\n          did_reduce = true;\n          if (reduction_version != STACK_VERSION_NONE) {\n            last_reduction_version = reduction_version;\n          }\n          break;\n        }\n\n        case TSParseActionTypeAccept: {\n          LOG(\"accept\");\n          ts_parser__accept(self, version, lookahead);\n          return true;\n        }\n\n        case TSParseActionTypeRecover: {\n          if (ts_subtree_child_count(lookahead) > 0) {\n            ts_parser__breakdown_lookahead(self, &lookahead, ERROR_STATE, &self->reusable_node);\n          }\n\n          ts_parser__recover(self, version, lookahead);\n          if (did_reuse) reusable_node_advance(&self->reusable_node);\n          return true;\n        }\n      }\n    }\n\n    // If a reduction was performed, then replace the current stack version\n    // with one of the stack versions created by a reduction, and continue\n    // processing this version of the stack with the same lookahead symbol.\n    if (last_reduction_version != STACK_VERSION_NONE) {\n      ts_stack_renumber_version(self->stack, last_reduction_version, version);\n      LOG_STACK();\n      state = ts_stack_state(self->stack, version);\n\n      // At the end of a non-terminal extra rule, the lexer will return a\n      // null subtree, because the parser needs to perform a fixed reduction\n      // regardless of the lookahead node. After performing that reduction,\n      // (and completing the non-terminal extra rule) run the lexer again based\n      // on the current parse state.\n      if (!lookahead.ptr) {\n        needs_lex = true;\n      } else {\n        ts_language_table_entry(\n          self->language,\n          state,\n          ts_subtree_leaf_symbol(lookahead),\n          &table_entry\n        );\n      }\n\n      continue;\n    }\n\n    // A reduction was performed, but was merged into an existing stack version.\n    // This version can be discarded.\n    if (did_reduce) {\n      if (lookahead.ptr) {\n        ts_subtree_release(&self->tree_pool, lookahead);\n      }\n      ts_stack_halt(self->stack, version);\n      return true;\n    }\n\n    // If the current lookahead token is a keyword that is not valid, but the\n    // default word token *is* valid, then treat the lookahead token as the word\n    // token instead.\n    if (\n      ts_subtree_is_keyword(lookahead) &&\n      ts_subtree_symbol(lookahead) != self->language->keyword_capture_token &&\n      !ts_language_is_reserved_word(self->language, state, ts_subtree_symbol(lookahead))\n    ) {\n      ts_language_table_entry(\n        self->language,\n        state,\n        self->language->keyword_capture_token,\n        &table_entry\n      );\n      if (table_entry.action_count > 0) {\n        LOG(\n          \"switch from_keyword:%s, to_word_token:%s\",\n          TREE_NAME(lookahead),\n          SYM_NAME(self->language->keyword_capture_token)\n        );\n\n        MutableSubtree mutable_lookahead = ts_subtree_make_mut(&self->tree_pool, lookahead);\n        ts_subtree_set_symbol(&mutable_lookahead, self->language->keyword_capture_token, self->language);\n        lookahead = ts_subtree_from_mut(mutable_lookahead);\n        continue;\n      }\n    }\n\n    // If the current lookahead token is not valid and the previous subtree on\n    // the stack was reused from an old tree, then it wasn't actually valid to\n    // reuse that previous subtree. Remove it from the stack, and in its place,\n    // push each of its children. Then try again to process the current lookahead.\n    if (ts_parser__breakdown_top_of_stack(self, version)) {\n      state = ts_stack_state(self->stack, version);\n      ts_subtree_release(&self->tree_pool, lookahead);\n      needs_lex = true;\n      continue;\n    }\n\n    // Otherwise, there is definitely an error in this version of the parse stack.\n    // Mark this version as paused and continue processing any other stack\n    // versions that exist. If some other version advances successfully, then\n    // this version can simply be removed. But if all versions end up paused,\n    // then error recovery is needed.\n    LOG(\"detect_error lookahead:%s\", TREE_NAME(lookahead));\n    ts_stack_pause(self->stack, version, lookahead);\n    return true;\n  }\n}\n\nstatic unsigned ts_parser__condense_stack(TSParser *self) {\n  bool made_changes = false;\n  unsigned min_error_cost = UINT_MAX;\n  for (StackVersion i = 0; i < ts_stack_version_count(self->stack); i++) {\n    // Prune any versions that have been marked for removal.\n    if (ts_stack_is_halted(self->stack, i)) {\n      ts_stack_remove_version(self->stack, i);\n      i--;\n      continue;\n    }\n\n    // Keep track of the minimum error cost of any stack version so\n    // that it can be returned.\n    ErrorStatus status_i = ts_parser__version_status(self, i);\n    if (!status_i.is_in_error && status_i.cost < min_error_cost) {\n      min_error_cost = status_i.cost;\n    }\n\n    // Examine each pair of stack versions, removing any versions that\n    // are clearly worse than another version. Ensure that the versions\n    // are ordered from most promising to least promising.\n    for (StackVersion j = 0; j < i; j++) {\n      ErrorStatus status_j = ts_parser__version_status(self, j);\n\n      switch (ts_parser__compare_versions(self, status_j, status_i)) {\n        case ErrorComparisonTakeLeft:\n          made_changes = true;\n          ts_stack_remove_version(self->stack, i);\n          i--;\n          j = i;\n          break;\n\n        case ErrorComparisonPreferLeft:\n        case ErrorComparisonNone:\n          if (ts_stack_merge(self->stack, j, i)) {\n            made_changes = true;\n            i--;\n            j = i;\n          }\n          break;\n\n        case ErrorComparisonPreferRight:\n          made_changes = true;\n          if (ts_stack_merge(self->stack, j, i)) {\n            i--;\n            j = i;\n          } else {\n            ts_stack_swap_versions(self->stack, i, j);\n          }\n          break;\n\n        case ErrorComparisonTakeRight:\n          made_changes = true;\n          ts_stack_remove_version(self->stack, j);\n          i--;\n          j--;\n          break;\n      }\n    }\n  }\n\n  // Enforce a hard upper bound on the number of stack versions by\n  // discarding the least promising versions.\n  while (ts_stack_version_count(self->stack) > MAX_VERSION_COUNT) {\n    ts_stack_remove_version(self->stack, MAX_VERSION_COUNT);\n    made_changes = true;\n  }\n\n  // If the best-performing stack version is currently paused, or all\n  // versions are paused, then resume the best paused version and begin\n  // the error recovery process. Otherwise, remove the paused versions.\n  if (ts_stack_version_count(self->stack) > 0) {\n    bool has_unpaused_version = false;\n    for (StackVersion i = 0, n = ts_stack_version_count(self->stack); i < n; i++) {\n      if (ts_stack_is_paused(self->stack, i)) {\n        if (!has_unpaused_version && self->accept_count < MAX_VERSION_COUNT) {\n          LOG(\"resume version:%u\", i);\n          min_error_cost = ts_stack_error_cost(self->stack, i);\n          Subtree lookahead = ts_stack_resume(self->stack, i);\n          ts_parser__handle_error(self, i, lookahead);\n          has_unpaused_version = true;\n        } else {\n          ts_stack_remove_version(self->stack, i);\n          made_changes = true;\n          i--;\n          n--;\n        }\n      } else {\n        has_unpaused_version = true;\n      }\n    }\n  }\n\n  if (made_changes) {\n    LOG(\"condense\");\n    LOG_STACK();\n  }\n\n  return min_error_cost;\n}\n\nstatic bool ts_parser__balance_subtree(TSParser *self) {\n  Subtree finished_tree = self->finished_tree;\n\n  // If we haven't canceled balancing in progress before, then we want to clear the tree stack and\n  // push the initial finished tree onto it. Otherwise, if we're resuming balancing after a\n  // cancellation, we don't want to clear the tree stack.\n  if (!self->canceled_balancing) {\n    array_clear(&self->tree_pool.tree_stack);\n    if (ts_subtree_child_count(finished_tree) > 0 && finished_tree.ptr->ref_count == 1) {\n      array_push(&self->tree_pool.tree_stack, ts_subtree_to_mut_unsafe(finished_tree));\n    }\n  }\n\n  while (self->tree_pool.tree_stack.size > 0) {\n    if (!ts_parser__check_progress(self, NULL, NULL, 1)) {\n      return false;\n    }\n\n    MutableSubtree tree = *array_get(&self->tree_pool.tree_stack, \n      self->tree_pool.tree_stack.size - 1\n    );\n\n    if (tree.ptr->repeat_depth > 0) {\n      Subtree child1 = ts_subtree_children(tree)[0];\n      Subtree child2 = ts_subtree_children(tree)[tree.ptr->child_count - 1];\n      long repeat_delta = (long)ts_subtree_repeat_depth(child1) - (long)ts_subtree_repeat_depth(child2);\n      if (repeat_delta > 0) {\n        unsigned n = (unsigned)repeat_delta;\n\n        for (unsigned i = n / 2; i > 0; i /= 2) {\n          ts_subtree_compress(tree, i, self->language, &self->tree_pool.tree_stack);\n          n -= i;\n\n          // We scale the operation count increment in `ts_parser__check_progress` proportionately to the compression\n          // size since larger values of i take longer to process. Shifting by 4 empirically provides good check\n          // intervals (e.g. 193 operations when i=3100) to prevent blocking during large compressions.\n          uint8_t operations = i >> 4 > 0 ? i >> 4 : 1;\n          if (!ts_parser__check_progress(self, NULL, NULL, operations)) {\n            return false;\n          }\n        }\n      }\n    }\n\n    (void)array_pop(&self->tree_pool.tree_stack);\n\n    for (uint32_t i = 0; i < tree.ptr->child_count; i++) {\n      Subtree child = ts_subtree_children(tree)[i];\n      if (ts_subtree_child_count(child) > 0 && child.ptr->ref_count == 1) {\n        array_push(&self->tree_pool.tree_stack, ts_subtree_to_mut_unsafe(child));\n      }\n    }\n  }\n\n  return true;\n}\n\nstatic bool ts_parser_has_outstanding_parse(TSParser *self) {\n  return (\n    self->canceled_balancing ||\n    self->external_scanner_payload ||\n    ts_stack_state(self->stack, 0) != 1 ||\n    ts_stack_node_count_since_error(self->stack, 0) != 0\n  );\n}\n\n// Parser - Public\n\nTSParser *ts_parser_new(void) {\n  TSParser *self = ts_calloc(1, sizeof(TSParser));\n  ts_lexer_init(&self->lexer);\n  array_init(&self->reduce_actions);\n  array_reserve(&self->reduce_actions, 4);\n  self->tree_pool = ts_subtree_pool_new(32);\n  self->stack = ts_stack_new(&self->tree_pool);\n  self->finished_tree = NULL_SUBTREE;\n  self->reusable_node = reusable_node_new();\n  self->dot_graph_file = NULL;\n  self->cancellation_flag = NULL;\n  self->timeout_duration = 0;\n  self->language = NULL;\n  self->has_scanner_error = false;\n  self->has_error = false;\n  self->canceled_balancing = false;\n  self->external_scanner_payload = NULL;\n  self->end_clock = clock_null();\n  self->operation_count = 0;\n  self->old_tree = NULL_SUBTREE;\n  self->included_range_differences = (TSRangeArray) array_new();\n  self->included_range_difference_index = 0;\n  ts_parser__set_cached_token(self, 0, NULL_SUBTREE, NULL_SUBTREE);\n  return self;\n}\n\nvoid ts_parser_delete(TSParser *self) {\n  if (!self) return;\n\n  ts_parser_set_language(self, NULL);\n  ts_stack_delete(self->stack);\n  if (self->reduce_actions.contents) {\n    array_delete(&self->reduce_actions);\n  }\n  if (self->included_range_differences.contents) {\n    array_delete(&self->included_range_differences);\n  }\n  if (self->old_tree.ptr) {\n    ts_subtree_release(&self->tree_pool, self->old_tree);\n    self->old_tree = NULL_SUBTREE;\n  }\n  ts_wasm_store_delete(self->wasm_store);\n  ts_lexer_delete(&self->lexer);\n  ts_parser__set_cached_token(self, 0, NULL_SUBTREE, NULL_SUBTREE);\n  ts_subtree_pool_delete(&self->tree_pool);\n  reusable_node_delete(&self->reusable_node);\n  array_delete(&self->trailing_extras);\n  array_delete(&self->trailing_extras2);\n  array_delete(&self->scratch_trees);\n  ts_free(self);\n}\n\nconst TSLanguage *ts_parser_language(const TSParser *self) {\n  return self->language;\n}\n\nbool ts_parser_set_language(TSParser *self, const TSLanguage *language) {\n  ts_parser_reset(self);\n  ts_language_delete(self->language);\n  self->language = NULL;\n\n  if (language) {\n    if (\n      language->abi_version > TREE_SITTER_LANGUAGE_VERSION ||\n      language->abi_version < TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION\n    ) return false;\n\n    if (ts_language_is_wasm(language)) {\n      if (\n        !self->wasm_store ||\n        !ts_wasm_store_start(self->wasm_store, &self->lexer.data, language)\n      ) return false;\n    }\n  }\n\n  self->language = ts_language_copy(language);\n  return true;\n}\n\nTSLogger ts_parser_logger(const TSParser *self) {\n  return self->lexer.logger;\n}\n\nvoid ts_parser_set_logger(TSParser *self, TSLogger logger) {\n  self->lexer.logger = logger;\n}\n\nvoid ts_parser_print_dot_graphs(TSParser *self, int fd) {\n  if (self->dot_graph_file) {\n    fclose(self->dot_graph_file);\n  }\n\n  if (fd >= 0) {\n    #ifdef _WIN32\n    self->dot_graph_file = _fdopen(fd, \"a\");\n    #else\n    self->dot_graph_file = fdopen(fd, \"a\");\n    #endif\n  } else {\n    self->dot_graph_file = NULL;\n  }\n}\n\nconst size_t *ts_parser_cancellation_flag(const TSParser *self) {\n  return (const size_t *)self->cancellation_flag;\n}\n\nvoid ts_parser_set_cancellation_flag(TSParser *self, const size_t *flag) {\n  self->cancellation_flag = (const volatile size_t *)flag;\n}\n\nuint64_t ts_parser_timeout_micros(const TSParser *self) {\n  return duration_to_micros(self->timeout_duration);\n}\n\nvoid ts_parser_set_timeout_micros(TSParser *self, uint64_t timeout_micros) {\n  self->timeout_duration = duration_from_micros(timeout_micros);\n}\n\nbool ts_parser_set_included_ranges(\n  TSParser *self,\n  const TSRange *ranges,\n  uint32_t count\n) {\n  return ts_lexer_set_included_ranges(&self->lexer, ranges, count);\n}\n\nconst TSRange *ts_parser_included_ranges(const TSParser *self, uint32_t *count) {\n  return ts_lexer_included_ranges(&self->lexer, count);\n}\n\nvoid ts_parser_reset(TSParser *self) {\n  ts_parser__external_scanner_destroy(self);\n  if (self->wasm_store) {\n    ts_wasm_store_reset(self->wasm_store);\n  }\n\n  if (self->old_tree.ptr) {\n    ts_subtree_release(&self->tree_pool, self->old_tree);\n    self->old_tree = NULL_SUBTREE;\n  }\n\n  reusable_node_clear(&self->reusable_node);\n  ts_lexer_reset(&self->lexer, length_zero());\n  ts_stack_clear(self->stack);\n  ts_parser__set_cached_token(self, 0, NULL_SUBTREE, NULL_SUBTREE);\n  if (self->finished_tree.ptr) {\n    ts_subtree_release(&self->tree_pool, self->finished_tree);\n    self->finished_tree = NULL_SUBTREE;\n  }\n  self->accept_count = 0;\n  self->has_scanner_error = false;\n  self->has_error = false;\n  self->canceled_balancing = false;\n  self->parse_options = (TSParseOptions) {0};\n  self->parse_state = (TSParseState) {0};\n}\n\nTSTree *ts_parser_parse(\n  TSParser *self,\n  const TSTree *old_tree,\n  TSInput input\n) {\n  TSTree *result = NULL;\n  if (!self->language || !input.read) return NULL;\n\n  if (ts_language_is_wasm(self->language)) {\n    if (!self->wasm_store) return NULL;\n    ts_wasm_store_start(self->wasm_store, &self->lexer.data, self->language);\n  }\n\n  ts_lexer_set_input(&self->lexer, input);\n  array_clear(&self->included_range_differences);\n  self->included_range_difference_index = 0;\n\n  self->operation_count = 0;\n  if (self->timeout_duration) {\n    self->end_clock = clock_after(clock_now(), self->timeout_duration);\n  } else {\n    self->end_clock = clock_null();\n  }\n\n  if (ts_parser_has_outstanding_parse(self)) {\n    LOG(\"resume_parsing\");\n    if (self->canceled_balancing) goto balance;\n  } else {\n    ts_parser__external_scanner_create(self);\n    if (self->has_scanner_error) goto exit;\n\n    if (old_tree) {\n      ts_subtree_retain(old_tree->root);\n      self->old_tree = old_tree->root;\n      ts_range_array_get_changed_ranges(\n        old_tree->included_ranges, old_tree->included_range_count,\n        self->lexer.included_ranges, self->lexer.included_range_count,\n        &self->included_range_differences\n      );\n      reusable_node_reset(&self->reusable_node, old_tree->root);\n      LOG(\"parse_after_edit\");\n      LOG_TREE(self->old_tree);\n      for (unsigned i = 0; i < self->included_range_differences.size; i++) {\n        TSRange *range = array_get(&self->included_range_differences, i);\n        LOG(\"different_included_range %u - %u\", range->start_byte, range->end_byte);\n      }\n    } else {\n      reusable_node_clear(&self->reusable_node);\n      LOG(\"new_parse\");\n    }\n  }\n\n  uint32_t position = 0, last_position = 0, version_count = 0;\n  do {\n    for (\n      StackVersion version = 0;\n      version_count = ts_stack_version_count(self->stack),\n      version < version_count;\n      version++\n    ) {\n      bool allow_node_reuse = version_count == 1;\n      while (ts_stack_is_active(self->stack, version)) {\n        LOG(\n          \"process version:%u, version_count:%u, state:%d, row:%u, col:%u\",\n          version,\n          ts_stack_version_count(self->stack),\n          ts_stack_state(self->stack, version),\n          ts_stack_position(self->stack, version).extent.row,\n          ts_stack_position(self->stack, version).extent.column\n        );\n\n        if (!ts_parser__advance(self, version, allow_node_reuse)) {\n          if (self->has_scanner_error) goto exit;\n          return NULL;\n        }\n\n        LOG_STACK();\n\n        position = ts_stack_position(self->stack, version).bytes;\n        if (position > last_position || (version > 0 && position == last_position)) {\n          last_position = position;\n          break;\n        }\n      }\n    }\n\n    // After advancing each version of the stack, re-sort the versions by their cost,\n    // removing any versions that are no longer worth pursuing.\n    unsigned min_error_cost = ts_parser__condense_stack(self);\n\n    // If there's already a finished parse tree that's better than any in-progress version,\n    // then terminate parsing. Clear the parse stack to remove any extra references to subtrees\n    // within the finished tree, ensuring that these subtrees can be safely mutated in-place\n    // for rebalancing.\n    if (self->finished_tree.ptr && ts_subtree_error_cost(self->finished_tree) < min_error_cost) {\n      ts_stack_clear(self->stack);\n      break;\n    }\n\n    while (self->included_range_difference_index < self->included_range_differences.size) {\n      TSRange *range = array_get(&self->included_range_differences, self->included_range_difference_index);\n      if (range->end_byte <= position) {\n        self->included_range_difference_index++;\n      } else {\n        break;\n      }\n    }\n  } while (version_count != 0);\n\nbalance:\n  ts_assert(self->finished_tree.ptr);\n  if (!ts_parser__balance_subtree(self)) {\n    self->canceled_balancing = true;\n    return false;\n  }\n  self->canceled_balancing = false;\n  LOG(\"done\");\n  LOG_TREE(self->finished_tree);\n\n  result = ts_tree_new(\n    self->finished_tree,\n    self->language,\n    self->lexer.included_ranges,\n    self->lexer.included_range_count\n  );\n  self->finished_tree = NULL_SUBTREE;\n\nexit:\n  ts_parser_reset(self);\n  return result;\n}\n\nTSTree *ts_parser_parse_with_options(\n  TSParser *self,\n  const TSTree *old_tree,\n  TSInput input,\n  TSParseOptions parse_options\n) {\n  self->parse_options = parse_options;\n  self->parse_state.payload = parse_options.payload;\n  TSTree *result = ts_parser_parse(self, old_tree, input);\n  // Reset parser options before further parse calls.\n  self->parse_options = (TSParseOptions) {0};\n  return result;\n}\n\nTSTree *ts_parser_parse_string(\n  TSParser *self,\n  const TSTree *old_tree,\n  const char *string,\n  uint32_t length\n) {\n  return ts_parser_parse_string_encoding(self, old_tree, string, length, TSInputEncodingUTF8);\n}\n\nTSTree *ts_parser_parse_string_encoding(\n  TSParser *self,\n  const TSTree *old_tree,\n  const char *string,\n  uint32_t length,\n  TSInputEncoding encoding\n) {\n  TSStringInput input = {string, length};\n  return ts_parser_parse(self, old_tree, (TSInput) {\n    &input,\n    ts_string_input_read,\n    encoding,\n    NULL,\n  });\n}\n\nvoid ts_parser_set_wasm_store(TSParser *self, TSWasmStore *store) {\n  if (self->language && ts_language_is_wasm(self->language)) {\n    // Copy the assigned language into the new store.\n    const TSLanguage *copy = ts_language_copy(self->language);\n    ts_parser_set_language(self, copy);\n    ts_language_delete(copy);\n  }\n\n  ts_wasm_store_delete(self->wasm_store);\n  self->wasm_store = store;\n}\n\nTSWasmStore *ts_parser_take_wasm_store(TSParser *self) {\n  if (self->language && ts_language_is_wasm(self->language)) {\n    ts_parser_set_language(self, NULL);\n  }\n\n  TSWasmStore *result = self->wasm_store;\n  self->wasm_store = NULL;\n  return result;\n}\n\n#undef LOG\n",
    "#include \"./alloc.h\"\n#include \"./language.h\"\n#include \"./subtree.h\"\n#include \"./array.h\"\n#include \"./stack.h\"\n#include \"./length.h\"\n#include <assert.h>\n#include <inttypes.h>\n#include <stdio.h>\n\n#define MAX_LINK_COUNT 8\n#define MAX_NODE_POOL_SIZE 50\n#define MAX_ITERATOR_COUNT 64\n\n#if defined _WIN32 && !defined __GNUC__\n#define forceinline __forceinline\n#else\n#define forceinline static inline __attribute__((always_inline))\n#endif\n\ntypedef struct StackNode StackNode;\n\ntypedef struct {\n  StackNode *node;\n  Subtree subtree;\n  bool is_pending;\n} StackLink;\n\nstruct StackNode {\n  TSStateId state;\n  Length position;\n  StackLink links[MAX_LINK_COUNT];\n  short unsigned int link_count;\n  uint32_t ref_count;\n  unsigned error_cost;\n  unsigned node_count;\n  int dynamic_precedence;\n};\n\ntypedef struct {\n  StackNode *node;\n  SubtreeArray subtrees;\n  uint32_t subtree_count;\n  bool is_pending;\n} StackIterator;\n\ntypedef Array(StackNode *) StackNodeArray;\n\ntypedef enum {\n  StackStatusActive,\n  StackStatusPaused,\n  StackStatusHalted,\n} StackStatus;\n\ntypedef struct {\n  StackNode *node;\n  StackSummary *summary;\n  unsigned node_count_at_last_error;\n  Subtree last_external_token;\n  Subtree lookahead_when_paused;\n  StackStatus status;\n} StackHead;\n\nstruct Stack {\n  Array(StackHead) heads;\n  StackSliceArray slices;\n  Array(StackIterator) iterators;\n  StackNodeArray node_pool;\n  StackNode *base_node;\n  SubtreePool *subtree_pool;\n};\n\ntypedef unsigned StackAction;\nenum {\n  StackActionNone,\n  StackActionStop = 1,\n  StackActionPop = 2,\n};\n\ntypedef StackAction (*StackCallback)(void *, const StackIterator *);\n\nstatic void stack_node_retain(StackNode *self) {\n  if (!self)\n    return;\n  ts_assert(self->ref_count > 0);\n  self->ref_count++;\n  ts_assert(self->ref_count != 0);\n}\n\nstatic void stack_node_release(\n  StackNode *self,\n  StackNodeArray *pool,\n  SubtreePool *subtree_pool\n) {\nrecur:\n  ts_assert(self->ref_count != 0);\n  self->ref_count--;\n  if (self->ref_count > 0) return;\n\n  StackNode *first_predecessor = NULL;\n  if (self->link_count > 0) {\n    for (unsigned i = self->link_count - 1; i > 0; i--) {\n      StackLink link = self->links[i];\n      if (link.subtree.ptr) ts_subtree_release(subtree_pool, link.subtree);\n      stack_node_release(link.node, pool, subtree_pool);\n    }\n    StackLink link = self->links[0];\n    if (link.subtree.ptr) ts_subtree_release(subtree_pool, link.subtree);\n    first_predecessor = self->links[0].node;\n  }\n\n  if (pool->size < MAX_NODE_POOL_SIZE) {\n    array_push(pool, self);\n  } else {\n    ts_free(self);\n  }\n\n  if (first_predecessor) {\n    self = first_predecessor;\n    goto recur;\n  }\n}\n\n/// Get the number of nodes in the subtree, for the purpose of measuring\n/// how much progress has been made by a given version of the stack.\nstatic uint32_t stack__subtree_node_count(Subtree subtree) {\n  uint32_t count = ts_subtree_visible_descendant_count(subtree);\n  if (ts_subtree_visible(subtree)) count++;\n\n  // Count intermediate error nodes even though they are not visible,\n  // because a stack version's node count is used to check whether it\n  // has made any progress since the last time it encountered an error.\n  if (ts_subtree_symbol(subtree) == ts_builtin_sym_error_repeat) count++;\n\n  return count;\n}\n\nstatic StackNode *stack_node_new(\n  StackNode *previous_node,\n  Subtree subtree,\n  bool is_pending,\n  TSStateId state,\n  StackNodeArray *pool\n) {\n  StackNode *node = pool->size > 0\n    ? array_pop(pool)\n    : ts_malloc(sizeof(StackNode));\n  *node = (StackNode) {\n    .ref_count = 1,\n    .link_count = 0,\n    .state = state\n  };\n\n  if (previous_node) {\n    node->link_count = 1;\n    node->links[0] = (StackLink) {\n      .node = previous_node,\n      .subtree = subtree,\n      .is_pending = is_pending,\n    };\n\n    node->position = previous_node->position;\n    node->error_cost = previous_node->error_cost;\n    node->dynamic_precedence = previous_node->dynamic_precedence;\n    node->node_count = previous_node->node_count;\n\n    if (subtree.ptr) {\n      node->error_cost += ts_subtree_error_cost(subtree);\n      node->position = length_add(node->position, ts_subtree_total_size(subtree));\n      node->node_count += stack__subtree_node_count(subtree);\n      node->dynamic_precedence += ts_subtree_dynamic_precedence(subtree);\n    }\n  } else {\n    node->position = length_zero();\n    node->error_cost = 0;\n  }\n\n  return node;\n}\n\nstatic bool stack__subtree_is_equivalent(Subtree left, Subtree right) {\n  if (left.ptr == right.ptr) return true;\n  if (!left.ptr || !right.ptr) return false;\n\n  // Symbols must match\n  if (ts_subtree_symbol(left) != ts_subtree_symbol(right)) return false;\n\n  // If both have errors, don't bother keeping both.\n  if (ts_subtree_error_cost(left) > 0 && ts_subtree_error_cost(right) > 0) return true;\n\n  return (\n    ts_subtree_padding(left).bytes == ts_subtree_padding(right).bytes &&\n    ts_subtree_size(left).bytes == ts_subtree_size(right).bytes &&\n    ts_subtree_child_count(left) == ts_subtree_child_count(right) &&\n    ts_subtree_extra(left) == ts_subtree_extra(right) &&\n    ts_subtree_external_scanner_state_eq(left, right)\n  );\n}\n\nstatic void stack_node_add_link(\n  StackNode *self,\n  StackLink link,\n  SubtreePool *subtree_pool\n) {\n  if (link.node == self) return;\n\n  for (int i = 0; i < self->link_count; i++) {\n    StackLink *existing_link = &self->links[i];\n    if (stack__subtree_is_equivalent(existing_link->subtree, link.subtree)) {\n      // In general, we preserve ambiguities until they are removed from the stack\n      // during a pop operation where multiple paths lead to the same node. But in\n      // the special case where two links directly connect the same pair of nodes,\n      // we can safely remove the ambiguity ahead of time without changing behavior.\n      if (existing_link->node == link.node) {\n        if (\n          ts_subtree_dynamic_precedence(link.subtree) >\n          ts_subtree_dynamic_precedence(existing_link->subtree)\n        ) {\n          ts_subtree_retain(link.subtree);\n          ts_subtree_release(subtree_pool, existing_link->subtree);\n          existing_link->subtree = link.subtree;\n          self->dynamic_precedence =\n            link.node->dynamic_precedence + ts_subtree_dynamic_precedence(link.subtree);\n        }\n        return;\n      }\n\n      // If the previous nodes are mergeable, merge them recursively.\n      if (\n        existing_link->node->state == link.node->state &&\n        existing_link->node->position.bytes == link.node->position.bytes &&\n        existing_link->node->error_cost == link.node->error_cost\n      ) {\n        for (int j = 0; j < link.node->link_count; j++) {\n          stack_node_add_link(existing_link->node, link.node->links[j], subtree_pool);\n        }\n        int32_t dynamic_precedence = link.node->dynamic_precedence;\n        if (link.subtree.ptr) {\n          dynamic_precedence += ts_subtree_dynamic_precedence(link.subtree);\n        }\n        if (dynamic_precedence > self->dynamic_precedence) {\n          self->dynamic_precedence = dynamic_precedence;\n        }\n        return;\n      }\n    }\n  }\n\n  if (self->link_count == MAX_LINK_COUNT) return;\n\n  stack_node_retain(link.node);\n  unsigned node_count = link.node->node_count;\n  int dynamic_precedence = link.node->dynamic_precedence;\n  self->links[self->link_count++] = link;\n\n  if (link.subtree.ptr) {\n    ts_subtree_retain(link.subtree);\n    node_count += stack__subtree_node_count(link.subtree);\n    dynamic_precedence += ts_subtree_dynamic_precedence(link.subtree);\n  }\n\n  if (node_count > self->node_count) self->node_count = node_count;\n  if (dynamic_precedence > self->dynamic_precedence) self->dynamic_precedence = dynamic_precedence;\n}\n\nstatic void stack_head_delete(\n  StackHead *self,\n  StackNodeArray *pool,\n  SubtreePool *subtree_pool\n) {\n  if (self->node) {\n    if (self->last_external_token.ptr) {\n      ts_subtree_release(subtree_pool, self->last_external_token);\n    }\n    if (self->lookahead_when_paused.ptr) {\n      ts_subtree_release(subtree_pool, self->lookahead_when_paused);\n    }\n    if (self->summary) {\n      array_delete(self->summary);\n      ts_free(self->summary);\n    }\n    stack_node_release(self->node, pool, subtree_pool);\n  }\n}\n\nstatic StackVersion ts_stack__add_version(\n  Stack *self,\n  StackVersion original_version,\n  StackNode *node\n) {\n  StackHead head = {\n    .node = node,\n    .node_count_at_last_error = array_get(&self->heads, original_version)->node_count_at_last_error,\n    .last_external_token = array_get(&self->heads, original_version)->last_external_token,\n    .status = StackStatusActive,\n    .lookahead_when_paused = NULL_SUBTREE,\n  };\n  array_push(&self->heads, head);\n  stack_node_retain(node);\n  if (head.last_external_token.ptr) ts_subtree_retain(head.last_external_token);\n  return (StackVersion)(self->heads.size - 1);\n}\n\nstatic void ts_stack__add_slice(\n  Stack *self,\n  StackVersion original_version,\n  StackNode *node,\n  SubtreeArray *subtrees\n) {\n  for (uint32_t i = self->slices.size - 1; i + 1 > 0; i--) {\n    StackVersion version = array_get(&self->slices, i)->version;\n    if (array_get(&self->heads, version)->node == node) {\n      StackSlice slice = {*subtrees, version};\n      array_insert(&self->slices, i + 1, slice);\n      return;\n    }\n  }\n\n  StackVersion version = ts_stack__add_version(self, original_version, node);\n  StackSlice slice = { *subtrees, version };\n  array_push(&self->slices, slice);\n}\n\nstatic StackSliceArray stack__iter(\n  Stack *self,\n  StackVersion version,\n  StackCallback callback,\n  void *payload,\n  int goal_subtree_count\n) {\n  array_clear(&self->slices);\n  array_clear(&self->iterators);\n\n  StackHead *head = array_get(&self->heads, version);\n  StackIterator new_iterator = {\n    .node = head->node,\n    .subtrees = array_new(),\n    .subtree_count = 0,\n    .is_pending = true,\n  };\n\n  bool include_subtrees = false;\n  if (goal_subtree_count >= 0) {\n    include_subtrees = true;\n    array_reserve(&new_iterator.subtrees, (uint32_t)ts_subtree_alloc_size(goal_subtree_count) / sizeof(Subtree));\n  }\n\n  array_push(&self->iterators, new_iterator);\n\n  while (self->iterators.size > 0) {\n    for (uint32_t i = 0, size = self->iterators.size; i < size; i++) {\n      StackIterator *iterator = array_get(&self->iterators, i);\n      StackNode *node = iterator->node;\n\n      StackAction action = callback(payload, iterator);\n      bool should_pop = action & StackActionPop;\n      bool should_stop = action & StackActionStop || node->link_count == 0;\n\n      if (should_pop) {\n        SubtreeArray subtrees = iterator->subtrees;\n        if (!should_stop) {\n          ts_subtree_array_copy(subtrees, &subtrees);\n        }\n        ts_subtree_array_reverse(&subtrees);\n        ts_stack__add_slice(\n          self,\n          version,\n          node,\n          &subtrees\n        );\n      }\n\n      if (should_stop) {\n        if (!should_pop) {\n          ts_subtree_array_delete(self->subtree_pool, &iterator->subtrees);\n        }\n        array_erase(&self->iterators, i);\n        i--, size--;\n        continue;\n      }\n\n      for (uint32_t j = 1; j <= node->link_count; j++) {\n        StackIterator *next_iterator;\n        StackLink link;\n        if (j == node->link_count) {\n          link = node->links[0];\n          next_iterator = array_get(&self->iterators, i);\n        } else {\n          if (self->iterators.size >= MAX_ITERATOR_COUNT) continue;\n          link = node->links[j];\n          StackIterator current_iterator = *array_get(&self->iterators, i);\n          array_push(&self->iterators, current_iterator);\n          next_iterator = array_back(&self->iterators);\n          ts_subtree_array_copy(next_iterator->subtrees, &next_iterator->subtrees);\n        }\n\n        next_iterator->node = link.node;\n        if (link.subtree.ptr) {\n          if (include_subtrees) {\n            array_push(&next_iterator->subtrees, link.subtree);\n            ts_subtree_retain(link.subtree);\n          }\n\n          if (!ts_subtree_extra(link.subtree)) {\n            next_iterator->subtree_count++;\n            if (!link.is_pending) {\n              next_iterator->is_pending = false;\n            }\n          }\n        } else {\n          next_iterator->subtree_count++;\n          next_iterator->is_pending = false;\n        }\n      }\n    }\n  }\n\n  return self->slices;\n}\n\nStack *ts_stack_new(SubtreePool *subtree_pool) {\n  Stack *self = ts_calloc(1, sizeof(Stack));\n\n  array_init(&self->heads);\n  array_init(&self->slices);\n  array_init(&self->iterators);\n  array_init(&self->node_pool);\n  array_reserve(&self->heads, 4);\n  array_reserve(&self->slices, 4);\n  array_reserve(&self->iterators, 4);\n  array_reserve(&self->node_pool, MAX_NODE_POOL_SIZE);\n\n  self->subtree_pool = subtree_pool;\n  self->base_node = stack_node_new(NULL, NULL_SUBTREE, false, 1, &self->node_pool);\n  ts_stack_clear(self);\n\n  return self;\n}\n\nvoid ts_stack_delete(Stack *self) {\n  if (self->slices.contents)\n    array_delete(&self->slices);\n  if (self->iterators.contents)\n    array_delete(&self->iterators);\n  stack_node_release(self->base_node, &self->node_pool, self->subtree_pool);\n  for (uint32_t i = 0; i < self->heads.size; i++) {\n    stack_head_delete(array_get(&self->heads, i), &self->node_pool, self->subtree_pool);\n  }\n  array_clear(&self->heads);\n  if (self->node_pool.contents) {\n    for (uint32_t i = 0; i < self->node_pool.size; i++)\n      ts_free(*array_get(&self->node_pool, i));\n    array_delete(&self->node_pool);\n  }\n  array_delete(&self->heads);\n  ts_free(self);\n}\n\nuint32_t ts_stack_version_count(const Stack *self) {\n  return self->heads.size;\n}\n\nuint32_t ts_stack_halted_version_count(Stack *self) {\n  uint32_t count = 0;\n  for (uint32_t i = 0; i < self->heads.size; i++) {\n    StackHead *head = array_get(&self->heads, i);\n    if (head->status == StackStatusHalted) {\n      count++;\n    }\n  }\n  return count;\n}\n\nTSStateId ts_stack_state(const Stack *self, StackVersion version) {\n  return array_get(&self->heads, version)->node->state;\n}\n\nLength ts_stack_position(const Stack *self, StackVersion version) {\n  return array_get(&self->heads, version)->node->position;\n}\n\nSubtree ts_stack_last_external_token(const Stack *self, StackVersion version) {\n  return array_get(&self->heads, version)->last_external_token;\n}\n\nvoid ts_stack_set_last_external_token(Stack *self, StackVersion version, Subtree token) {\n  StackHead *head = array_get(&self->heads, version);\n  if (token.ptr) ts_subtree_retain(token);\n  if (head->last_external_token.ptr) ts_subtree_release(self->subtree_pool, head->last_external_token);\n  head->last_external_token = token;\n}\n\nunsigned ts_stack_error_cost(const Stack *self, StackVersion version) {\n  StackHead *head = array_get(&self->heads, version);\n  unsigned result = head->node->error_cost;\n  if (\n    head->status == StackStatusPaused ||\n    (head->node->state == ERROR_STATE && !head->node->links[0].subtree.ptr)) {\n    result += ERROR_COST_PER_RECOVERY;\n  }\n  return result;\n}\n\nunsigned ts_stack_node_count_since_error(const Stack *self, StackVersion version) {\n  StackHead *head = array_get(&self->heads, version);\n  if (head->node->node_count < head->node_count_at_last_error) {\n    head->node_count_at_last_error = head->node->node_count;\n  }\n  return head->node->node_count - head->node_count_at_last_error;\n}\n\nvoid ts_stack_push(\n  Stack *self,\n  StackVersion version,\n  Subtree subtree,\n  bool pending,\n  TSStateId state\n) {\n  StackHead *head = array_get(&self->heads, version);\n  StackNode *new_node = stack_node_new(head->node, subtree, pending, state, &self->node_pool);\n  if (!subtree.ptr) head->node_count_at_last_error = new_node->node_count;\n  head->node = new_node;\n}\n\nforceinline StackAction pop_count_callback(void *payload, const StackIterator *iterator) {\n  unsigned *goal_subtree_count = payload;\n  if (iterator->subtree_count == *goal_subtree_count) {\n    return StackActionPop | StackActionStop;\n  } else {\n    return StackActionNone;\n  }\n}\n\nStackSliceArray ts_stack_pop_count(Stack *self, StackVersion version, uint32_t count) {\n  return stack__iter(self, version, pop_count_callback, &count, (int)count);\n}\n\n\nforceinline StackAction pop_pending_callback(void *payload, const StackIterator *iterator) {\n  (void)payload;\n  if (iterator->subtree_count >= 1) {\n    if (iterator->is_pending) {\n      return StackActionPop | StackActionStop;\n    } else {\n      return StackActionStop;\n    }\n  } else {\n    return StackActionNone;\n  }\n}\n\nStackSliceArray ts_stack_pop_pending(Stack *self, StackVersion version) {\n  StackSliceArray pop = stack__iter(self, version, pop_pending_callback, NULL, 0);\n  if (pop.size > 0) {\n    ts_stack_renumber_version(self, array_get(&pop, 0)->version, version);\n    array_get(&pop, 0)->version = version;\n  }\n  return pop;\n}\n\nforceinline StackAction pop_error_callback(void *payload, const StackIterator *iterator) {\n  if (iterator->subtrees.size > 0) {\n    bool *found_error = payload;\n    if (!*found_error && ts_subtree_is_error(*array_get(&iterator->subtrees, 0))) {\n      *found_error = true;\n      return StackActionPop | StackActionStop;\n    } else {\n      return StackActionStop;\n    }\n  } else {\n    return StackActionNone;\n  }\n}\n\nSubtreeArray ts_stack_pop_error(Stack *self, StackVersion version) {\n  StackNode *node = array_get(&self->heads, version)->node;\n  for (unsigned i = 0; i < node->link_count; i++) {\n    if (node->links[i].subtree.ptr && ts_subtree_is_error(node->links[i].subtree)) {\n      bool found_error = false;\n      StackSliceArray pop = stack__iter(self, version, pop_error_callback, &found_error, 1);\n      if (pop.size > 0) {\n        ts_assert(pop.size == 1);\n        ts_stack_renumber_version(self, array_get(&pop, 0)->version, version);\n        return array_get(&pop, 0)->subtrees;\n      }\n      break;\n    }\n  }\n  return (SubtreeArray) {.size = 0};\n}\n\nforceinline StackAction pop_all_callback(void *payload, const StackIterator *iterator) {\n  (void)payload;\n  return iterator->node->link_count == 0 ? StackActionPop : StackActionNone;\n}\n\nStackSliceArray ts_stack_pop_all(Stack *self, StackVersion version) {\n  return stack__iter(self, version, pop_all_callback, NULL, 0);\n}\n\ntypedef struct {\n  StackSummary *summary;\n  unsigned max_depth;\n} SummarizeStackSession;\n\nforceinline StackAction summarize_stack_callback(void *payload, const StackIterator *iterator) {\n  SummarizeStackSession *session = payload;\n  TSStateId state = iterator->node->state;\n  unsigned depth = iterator->subtree_count;\n  if (depth > session->max_depth) return StackActionStop;\n  for (unsigned i = session->summary->size - 1; i + 1 > 0; i--) {\n    StackSummaryEntry entry = *array_get(session->summary, i);\n    if (entry.depth < depth) break;\n    if (entry.depth == depth && entry.state == state) return StackActionNone;\n  }\n  array_push(session->summary, ((StackSummaryEntry) {\n    .position = iterator->node->position,\n    .depth = depth,\n    .state = state,\n  }));\n  return StackActionNone;\n}\n\nvoid ts_stack_record_summary(Stack *self, StackVersion version, unsigned max_depth) {\n  SummarizeStackSession session = {\n    .summary = ts_malloc(sizeof(StackSummary)),\n    .max_depth = max_depth\n  };\n  array_init(session.summary);\n  stack__iter(self, version, summarize_stack_callback, &session, -1);\n  StackHead *head = array_get(&self->heads, version);\n  if (head->summary) {\n    array_delete(head->summary);\n    ts_free(head->summary);\n  }\n  head->summary = session.summary;\n}\n\nStackSummary *ts_stack_get_summary(Stack *self, StackVersion version) {\n  return array_get(&self->heads, version)->summary;\n}\n\nint ts_stack_dynamic_precedence(Stack *self, StackVersion version) {\n  return array_get(&self->heads, version)->node->dynamic_precedence;\n}\n\nbool ts_stack_has_advanced_since_error(const Stack *self, StackVersion version) {\n  const StackHead *head = array_get(&self->heads, version);\n  const StackNode *node = head->node;\n  if (node->error_cost == 0) return true;\n  while (node) {\n    if (node->link_count > 0) {\n      Subtree subtree = node->links[0].subtree;\n      if (subtree.ptr) {\n        if (ts_subtree_total_bytes(subtree) > 0) {\n          return true;\n        } else if (\n          node->node_count > head->node_count_at_last_error &&\n          ts_subtree_error_cost(subtree) == 0\n        ) {\n          node = node->links[0].node;\n          continue;\n        }\n      }\n    }\n    break;\n  }\n  return false;\n}\n\nvoid ts_stack_remove_version(Stack *self, StackVersion version) {\n  stack_head_delete(array_get(&self->heads, version), &self->node_pool, self->subtree_pool);\n  array_erase(&self->heads, version);\n}\n\nvoid ts_stack_renumber_version(Stack *self, StackVersion v1, StackVersion v2) {\n  if (v1 == v2) return;\n  ts_assert(v2 < v1);\n  ts_assert((uint32_t)v1 < self->heads.size);\n  StackHead *source_head = array_get(&self->heads, v1);\n  StackHead *target_head = array_get(&self->heads, v2);\n  if (target_head->summary && !source_head->summary) {\n    source_head->summary = target_head->summary;\n    target_head->summary = NULL;\n  }\n  stack_head_delete(target_head, &self->node_pool, self->subtree_pool);\n  *target_head = *source_head;\n  array_erase(&self->heads, v1);\n}\n\nvoid ts_stack_swap_versions(Stack *self, StackVersion v1, StackVersion v2) {\n  StackHead temporary_head = *array_get(&self->heads, v1);\n  *array_get(&self->heads, v1) = *array_get(&self->heads, v2);\n  *array_get(&self->heads, v2) = temporary_head;\n}\n\nStackVersion ts_stack_copy_version(Stack *self, StackVersion version) {\n  ts_assert(version < self->heads.size);\n  StackHead version_head = *array_get(&self->heads, version);\n  array_push(&self->heads, version_head);\n  StackHead *head = array_back(&self->heads);\n  stack_node_retain(head->node);\n  if (head->last_external_token.ptr) ts_subtree_retain(head->last_external_token);\n  head->summary = NULL;\n  return self->heads.size - 1;\n}\n\nbool ts_stack_merge(Stack *self, StackVersion version1, StackVersion version2) {\n  if (!ts_stack_can_merge(self, version1, version2)) return false;\n  StackHead *head1 = array_get(&self->heads, version1);\n  StackHead *head2 = array_get(&self->heads, version2);\n  for (uint32_t i = 0; i < head2->node->link_count; i++) {\n    stack_node_add_link(head1->node, head2->node->links[i], self->subtree_pool);\n  }\n  if (head1->node->state == ERROR_STATE) {\n    head1->node_count_at_last_error = head1->node->node_count;\n  }\n  ts_stack_remove_version(self, version2);\n  return true;\n}\n\nbool ts_stack_can_merge(Stack *self, StackVersion version1, StackVersion version2) {\n  StackHead *head1 = array_get(&self->heads, version1);\n  StackHead *head2 = array_get(&self->heads, version2);\n  return\n    head1->status == StackStatusActive &&\n    head2->status == StackStatusActive &&\n    head1->node->state == head2->node->state &&\n    head1->node->position.bytes == head2->node->position.bytes &&\n    head1->node->error_cost == head2->node->error_cost &&\n    ts_subtree_external_scanner_state_eq(head1->last_external_token, head2->last_external_token);\n}\n\nvoid ts_stack_halt(Stack *self, StackVersion version) {\n  array_get(&self->heads, version)->status = StackStatusHalted;\n}\n\nvoid ts_stack_pause(Stack *self, StackVersion version, Subtree lookahead) {\n  StackHead *head = array_get(&self->heads, version);\n  head->status = StackStatusPaused;\n  head->lookahead_when_paused = lookahead;\n  head->node_count_at_last_error = head->node->node_count;\n}\n\nbool ts_stack_is_active(const Stack *self, StackVersion version) {\n  return array_get(&self->heads, version)->status == StackStatusActive;\n}\n\nbool ts_stack_is_halted(const Stack *self, StackVersion version) {\n  return array_get(&self->heads, version)->status == StackStatusHalted;\n}\n\nbool ts_stack_is_paused(const Stack *self, StackVersion version) {\n  return array_get(&self->heads, version)->status == StackStatusPaused;\n}\n\nSubtree ts_stack_resume(Stack *self, StackVersion version) {\n  StackHead *head = array_get(&self->heads, version);\n  ts_assert(head->status == StackStatusPaused);\n  Subtree result = head->lookahead_when_paused;\n  head->status = StackStatusActive;\n  head->lookahead_when_paused = NULL_SUBTREE;\n  return result;\n}\n\nvoid ts_stack_clear(Stack *self) {\n  stack_node_retain(self->base_node);\n  for (uint32_t i = 0; i < self->heads.size; i++) {\n    stack_head_delete(array_get(&self->heads, i), &self->node_pool, self->subtree_pool);\n  }\n  array_clear(&self->heads);\n  array_push(&self->heads, ((StackHead) {\n    .node = self->base_node,\n    .status = StackStatusActive,\n    .last_external_token = NULL_SUBTREE,\n    .lookahead_when_paused = NULL_SUBTREE,\n  }));\n}\n\nbool ts_stack_print_dot_graph(Stack *self, const TSLanguage *language, FILE *f) {\n  array_reserve(&self->iterators, 32);\n  if (!f) f = stderr;\n\n  fprintf(f, \"digraph stack {\\n\");\n  fprintf(f, \"rankdir=\\\"RL\\\";\\n\");\n  fprintf(f, \"edge [arrowhead=none]\\n\");\n\n  Array(StackNode *) visited_nodes = array_new();\n\n  array_clear(&self->iterators);\n  for (uint32_t i = 0; i < self->heads.size; i++) {\n    StackHead *head = array_get(&self->heads, i);\n    if (head->status == StackStatusHalted) continue;\n\n    fprintf(f, \"node_head_%u [shape=none, label=\\\"\\\"]\\n\", i);\n    fprintf(f, \"node_head_%u -> node_%p [\", i, (void *)head->node);\n\n    if (head->status == StackStatusPaused) {\n      fprintf(f, \"color=red \");\n    }\n    fprintf(f,\n      \"label=%u, fontcolor=blue, weight=10000, labeltooltip=\\\"node_count: %u\\nerror_cost: %u\",\n      i,\n      ts_stack_node_count_since_error(self, i),\n      ts_stack_error_cost(self, i)\n    );\n\n    if (head->summary) {\n      fprintf(f, \"\\nsummary:\");\n      for (uint32_t j = 0; j < head->summary->size; j++) fprintf(f, \" %u\", array_get(head->summary, j)->state);\n    }\n\n    if (head->last_external_token.ptr) {\n      const ExternalScannerState *state = &head->last_external_token.ptr->external_scanner_state;\n      const char *data = ts_external_scanner_state_data(state);\n      fprintf(f, \"\\nexternal_scanner_state:\");\n      for (uint32_t j = 0; j < state->length; j++) fprintf(f, \" %2X\", data[j]);\n    }\n\n    fprintf(f, \"\\\"]\\n\");\n    array_push(&self->iterators, ((StackIterator) {\n      .node = head->node\n    }));\n  }\n\n  bool all_iterators_done = false;\n  while (!all_iterators_done) {\n    all_iterators_done = true;\n\n    for (uint32_t i = 0; i < self->iterators.size; i++) {\n      StackIterator iterator = *array_get(&self->iterators, i);\n      StackNode *node = iterator.node;\n\n      for (uint32_t j = 0; j < visited_nodes.size; j++) {\n        if (*array_get(&visited_nodes, j) == node) {\n          node = NULL;\n          break;\n        }\n      }\n\n      if (!node) continue;\n      all_iterators_done = false;\n\n      fprintf(f, \"node_%p [\", (void *)node);\n      if (node->state == ERROR_STATE) {\n        fprintf(f, \"label=\\\"?\\\"\");\n      } else if (\n        node->link_count == 1 &&\n        node->links[0].subtree.ptr &&\n        ts_subtree_extra(node->links[0].subtree)\n      ) {\n        fprintf(f, \"shape=point margin=0 label=\\\"\\\"\");\n      } else {\n        fprintf(f, \"label=\\\"%d\\\"\", node->state);\n      }\n\n      fprintf(\n        f,\n        \" tooltip=\\\"position: %u,%u\\nnode_count:%u\\nerror_cost: %u\\ndynamic_precedence: %d\\\"];\\n\",\n        node->position.extent.row + 1,\n        node->position.extent.column,\n        node->node_count,\n        node->error_cost,\n        node->dynamic_precedence\n      );\n\n      for (int j = 0; j < node->link_count; j++) {\n        StackLink link = node->links[j];\n        fprintf(f, \"node_%p -> node_%p [\", (void *)node, (void *)link.node);\n        if (link.is_pending) fprintf(f, \"style=dashed \");\n        if (link.subtree.ptr && ts_subtree_extra(link.subtree)) fprintf(f, \"fontcolor=gray \");\n\n        if (!link.subtree.ptr) {\n          fprintf(f, \"color=red\");\n        } else {\n          fprintf(f, \"label=\\\"\");\n          bool quoted = ts_subtree_visible(link.subtree) && !ts_subtree_named(link.subtree);\n          if (quoted) fprintf(f, \"'\");\n          ts_language_write_symbol_as_dot_string(language, f, ts_subtree_symbol(link.subtree));\n          if (quoted) fprintf(f, \"'\");\n          fprintf(f, \"\\\"\");\n          fprintf(\n            f,\n            \"labeltooltip=\\\"error_cost: %u\\ndynamic_precedence: %\" PRId32 \"\\\"\",\n            ts_subtree_error_cost(link.subtree),\n            ts_subtree_dynamic_precedence(link.subtree)\n          );\n        }\n\n        fprintf(f, \"];\\n\");\n\n        StackIterator *next_iterator;\n        if (j == 0) {\n          next_iterator = array_get(&self->iterators, i);\n        } else {\n          array_push(&self->iterators, iterator);\n          next_iterator = array_back(&self->iterators);\n        }\n        next_iterator->node = link.node;\n      }\n\n      array_push(&visited_nodes, node);\n    }\n  }\n\n  fprintf(f, \"}\\n\");\n\n  array_delete(&visited_nodes);\n  return true;\n}\n\n#undef forceinline\n",
    "#ifndef TREE_SITTER_ATOMIC_H_\n#define TREE_SITTER_ATOMIC_H_\n\n#include <stddef.h>\n#include <stdint.h>\n#include <stdlib.h>\n\n#ifdef __TINYC__\n\nstatic inline size_t atomic_load(const volatile size_t *p) {\n  return *p;\n}\n\nstatic inline uint32_t atomic_inc(volatile uint32_t *p) {\n  *p += 1;\n  return *p;\n}\n\nstatic inline uint32_t atomic_dec(volatile uint32_t *p) {\n  *p-= 1;\n  return *p;\n}\n\n#elif defined(_WIN32)\n\n#include <windows.h>\n\nstatic inline size_t atomic_load(const volatile size_t *p) {\n  return *p;\n}\n\nstatic inline uint32_t atomic_inc(volatile uint32_t *p) {\n  return InterlockedIncrement((long volatile *)p);\n}\n\nstatic inline uint32_t atomic_dec(volatile uint32_t *p) {\n  return InterlockedDecrement((long volatile *)p);\n}\n\n#else\n\nstatic inline size_t atomic_load(const volatile size_t *p) {\n#ifdef __ATOMIC_RELAXED\n  return __atomic_load_n(p, __ATOMIC_RELAXED);\n#else\n  return __sync_fetch_and_add((volatile size_t *)p, 0);\n#endif\n}\n\nstatic inline uint32_t atomic_inc(volatile uint32_t *p) {\n  #ifdef __ATOMIC_RELAXED\n    return __atomic_add_fetch(p, 1U, __ATOMIC_SEQ_CST);\n  #else\n    return __sync_add_and_fetch(p, 1U);\n  #endif\n}\n\nstatic inline uint32_t atomic_dec(volatile uint32_t *p) {\n  #ifdef __ATOMIC_RELAXED\n    return __atomic_sub_fetch(p, 1U, __ATOMIC_SEQ_CST);\n  #else\n    return __sync_sub_and_fetch(p, 1U);\n  #endif\n}\n\n#endif\n\n#endif  // TREE_SITTER_ATOMIC_H_\n",
    "#include \"./subtree.h\"\n\ntypedef struct {\n  Subtree tree;\n  uint32_t child_index;\n  uint32_t byte_offset;\n} StackEntry;\n\ntypedef struct {\n  Array(StackEntry) stack;\n  Subtree last_external_token;\n} ReusableNode;\n\nstatic inline ReusableNode reusable_node_new(void) {\n  return (ReusableNode) {array_new(), NULL_SUBTREE};\n}\n\nstatic inline void reusable_node_clear(ReusableNode *self) {\n  array_clear(&self->stack);\n  self->last_external_token = NULL_SUBTREE;\n}\n\nstatic inline Subtree reusable_node_tree(ReusableNode *self) {\n  return self->stack.size > 0\n    ? self->stack.contents[self->stack.size - 1].tree\n    : NULL_SUBTREE;\n}\n\nstatic inline uint32_t reusable_node_byte_offset(ReusableNode *self) {\n  return self->stack.size > 0\n    ? self->stack.contents[self->stack.size - 1].byte_offset\n    : UINT32_MAX;\n}\n\nstatic inline void reusable_node_delete(ReusableNode *self) {\n  array_delete(&self->stack);\n}\n\nstatic inline void reusable_node_advance(ReusableNode *self) {\n  StackEntry last_entry = *array_back(&self->stack);\n  uint32_t byte_offset = last_entry.byte_offset + ts_subtree_total_bytes(last_entry.tree);\n  if (ts_subtree_has_external_tokens(last_entry.tree)) {\n    self->last_external_token = ts_subtree_last_external_token(last_entry.tree);\n  }\n\n  Subtree tree;\n  uint32_t next_index;\n  do {\n    StackEntry popped_entry = array_pop(&self->stack);\n    next_index = popped_entry.child_index + 1;\n    if (self->stack.size == 0) return;\n    tree = array_back(&self->stack)->tree;\n  } while (ts_subtree_child_count(tree) <= next_index);\n\n  array_push(&self->stack, ((StackEntry) {\n    .tree = ts_subtree_children(tree)[next_index],\n    .child_index = next_index,\n    .byte_offset = byte_offset,\n  }));\n}\n\nstatic inline bool reusable_node_descend(ReusableNode *self) {\n  StackEntry last_entry = *array_back(&self->stack);\n  if (ts_subtree_child_count(last_entry.tree) > 0) {\n    array_push(&self->stack, ((StackEntry) {\n      .tree = ts_subtree_children(last_entry.tree)[0],\n      .child_index = 0,\n      .byte_offset = last_entry.byte_offset,\n    }));\n    return true;\n  } else {\n    return false;\n  }\n}\n\nstatic inline void reusable_node_advance_past_leaf(ReusableNode *self) {\n  while (reusable_node_descend(self)) {}\n  reusable_node_advance(self);\n}\n\nstatic inline void reusable_node_reset(ReusableNode *self, Subtree tree) {\n  reusable_node_clear(self);\n  array_push(&self->stack, ((StackEntry) {\n    .tree = tree,\n    .child_index = 0,\n    .byte_offset = 0,\n  }));\n\n  // Never reuse the root node, because it has a non-standard internal structure\n  // due to transformations that are applied when it is accepted: adding the EOF\n  // child and any extra children.\n  if (!reusable_node_descend(self)) {\n    reusable_node_clear(self);\n  }\n}\n",
    "#ifndef TREE_SITTER_CLOCK_H_\n#define TREE_SITTER_CLOCK_H_\n\n#include <stdbool.h>\n#include <stdint.h>\n\ntypedef uint64_t TSDuration;\n\n#ifdef _WIN32\n\n// Windows:\n// * Represent a time as a performance counter value.\n// * Represent a duration as a number of performance counter ticks.\n\n#include <windows.h>\ntypedef uint64_t TSClock;\n\nstatic inline TSDuration duration_from_micros(uint64_t micros) {\n  LARGE_INTEGER frequency;\n  QueryPerformanceFrequency(&frequency);\n  return micros * (uint64_t)frequency.QuadPart / 1000000;\n}\n\nstatic inline uint64_t duration_to_micros(TSDuration self) {\n  LARGE_INTEGER frequency;\n  QueryPerformanceFrequency(&frequency);\n  return self * 1000000 / (uint64_t)frequency.QuadPart;\n}\n\nstatic inline TSClock clock_null(void) {\n  return 0;\n}\n\nstatic inline TSClock clock_now(void) {\n  LARGE_INTEGER result;\n  QueryPerformanceCounter(&result);\n  return (uint64_t)result.QuadPart;\n}\n\nstatic inline TSClock clock_after(TSClock base, TSDuration duration) {\n  return base + duration;\n}\n\nstatic inline bool clock_is_null(TSClock self) {\n  return !self;\n}\n\nstatic inline bool clock_is_gt(TSClock self, TSClock other) {\n  return self > other;\n}\n\n#elif defined(CLOCK_MONOTONIC)\n\n// POSIX with monotonic clock support (Linux, macOS)\n// * Represent a time as a monotonic (seconds, nanoseconds) pair.\n// * Represent a duration as a number of microseconds.\n//\n// On these platforms, parse timeouts will correspond accurately to\n// real time, regardless of what other processes are running.\n\n#include <time.h>\ntypedef struct timespec TSClock;\n\nstatic inline TSDuration duration_from_micros(uint64_t micros) {\n  return micros;\n}\n\nstatic inline uint64_t duration_to_micros(TSDuration self) {\n  return self;\n}\n\nstatic inline TSClock clock_now(void) {\n  TSClock result;\n  clock_gettime(CLOCK_MONOTONIC, &result);\n  return result;\n}\n\nstatic inline TSClock clock_null(void) {\n  return (TSClock) {0, 0};\n}\n\nstatic inline TSClock clock_after(TSClock base, TSDuration duration) {\n  TSClock result = base;\n  result.tv_sec += duration / 1000000;\n  result.tv_nsec += (duration % 1000000) * 1000;\n  if (result.tv_nsec >= 1000000000) {\n    result.tv_nsec -= 1000000000;\n    ++(result.tv_sec);\n  }\n  return result;\n}\n\nstatic inline bool clock_is_null(TSClock self) {\n  return !self.tv_sec && !self.tv_nsec;\n}\n\nstatic inline bool clock_is_gt(TSClock self, TSClock other) {\n  if (self.tv_sec > other.tv_sec) return true;\n  if (self.tv_sec < other.tv_sec) return false;\n  return self.tv_nsec > other.tv_nsec;\n}\n\n#else\n\n// POSIX without monotonic clock support\n// * Represent a time as a process clock value.\n// * Represent a duration as a number of process clock ticks.\n//\n// On these platforms, parse timeouts may be affected by other processes,\n// which is not ideal, but is better than using a non-monotonic time API\n// like `gettimeofday`.\n\n#include <time.h>\ntypedef uint64_t TSClock;\n\nstatic inline TSDuration duration_from_micros(uint64_t micros) {\n  return micros * (uint64_t)CLOCKS_PER_SEC / 1000000;\n}\n\nstatic inline uint64_t duration_to_micros(TSDuration self) {\n  return self * 1000000 / (uint64_t)CLOCKS_PER_SEC;\n}\n\nstatic inline TSClock clock_null(void) {\n  return 0;\n}\n\nstatic inline TSClock clock_now(void) {\n  return (uint64_t)clock();\n}\n\nstatic inline TSClock clock_after(TSClock base, TSDuration duration) {\n  return base + duration;\n}\n\nstatic inline bool clock_is_null(TSClock self) {\n  return !self;\n}\n\nstatic inline bool clock_is_gt(TSClock self, TSClock other) {\n  return self > other;\n}\n\n#endif\n\n#endif  // TREE_SITTER_CLOCK_H_\n",
    "#ifndef TREE_SITTER_REDUCE_ACTION_H_\n#define TREE_SITTER_REDUCE_ACTION_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"./array.h\"\n#include \"tree_sitter/api.h\"\n\ntypedef struct {\n  uint32_t count;\n  TSSymbol symbol;\n  int dynamic_precedence;\n  unsigned short production_id;\n} ReduceAction;\n\ntypedef Array(ReduceAction) ReduceActionSet;\n\nstatic inline void ts_reduce_action_set_add(ReduceActionSet *self,\n                                            ReduceAction new_action) {\n  for (uint32_t i = 0; i < self->size; i++) {\n    ReduceAction action = self->contents[i];\n    if (action.symbol == new_action.symbol && action.count == new_action.count)\n      return;\n  }\n  array_push(self, new_action);\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  // TREE_SITTER_REDUCE_ACTION_H_\n",
    "/*\n * On NetBSD, defining standard requirements like this removes symbols\n * from the namespace; however, we need non-standard symbols for\n * endian.h.\n */\n#if defined(__NetBSD__) && defined(_POSIX_C_SOURCE)\n#undef _POSIX_C_SOURCE\n#endif\n\n#include \"tree_sitter/api.h\"\n#include \"./alloc.h\"\n#include \"./array.h\"\n#include \"./clock.h\"\n#include \"./language.h\"\n#include \"./point.h\"\n#include \"./tree_cursor.h\"\n#include \"./unicode.h\"\n#include <wctype.h>\n\n// #define DEBUG_ANALYZE_QUERY\n// #define DEBUG_EXECUTE_QUERY\n\n#define MAX_STEP_CAPTURE_COUNT 3\n#define MAX_NEGATED_FIELD_COUNT 8\n#define MAX_STATE_PREDECESSOR_COUNT 256\n#define MAX_ANALYSIS_STATE_DEPTH 8\n#define MAX_ANALYSIS_ITERATION_COUNT 256\n\n/*\n * Stream - A sequence of unicode characters derived from a UTF8 string.\n * This struct is used in parsing queries from S-expressions.\n */\ntypedef struct {\n  const char *input;\n  const char *start;\n  const char *end;\n  int32_t next;\n  uint8_t next_size;\n} Stream;\n\n/*\n * QueryStep - A step in the process of matching a query. Each node within\n * a query S-expression corresponds to one of these steps. An entire pattern\n * is represented as a sequence of these steps. The basic properties of a\n * node are represented by these fields:\n * - `symbol` - The grammar symbol to match. A zero value represents the\n *    wildcard symbol, '_'.\n * - `field` - The field name to match. A zero value means that a field name\n *    was not specified.\n * - `capture_ids` - An array of integers representing the names of captures\n *    associated with this node in the pattern, terminated by a `NONE` value.\n * - `depth` - The depth where this node occurs in the pattern. The root node\n *    of the pattern has depth zero.\n * - `negated_field_list_id` - An id representing a set of fields that must\n *    not be present on a node matching this step.\n *\n * Steps have some additional fields in order to handle the `.` (or \"anchor\") operator,\n * which forbids additional child nodes:\n * - `is_immediate` - Indicates that the node matching this step cannot be preceded\n *   by other sibling nodes that weren't specified in the pattern.\n * - `is_last_child` - Indicates that the node matching this step cannot have any\n *   subsequent named siblings.\n *\n * For simple patterns, steps are matched in sequential order. But in order to\n * handle alternative/repeated/optional sub-patterns, query steps are not always\n * structured as a linear sequence; they sometimes need to split and merge. This\n * is done using the following fields:\n *  - `alternative_index` - The index of a different query step that serves as\n *    an alternative to this step. A `NONE` value represents no alternative.\n *    When a query state reaches a step with an alternative index, the state\n *    is duplicated, with one copy remaining at the original step, and one copy\n *    moving to the alternative step. The alternative may have its own alternative\n *    step, so this splitting is an iterative process.\n * - `is_dead_end` - Indicates that this state cannot be passed directly, and\n *    exists only in order to redirect to an alternative index, with no splitting.\n * - `is_pass_through` - Indicates that state has no matching logic of its own,\n *    and exists only to split a state. One copy of the state advances immediately\n *    to the next step, and one moves to the alternative step.\n * - `alternative_is_immediate` - Indicates that this step's alternative step\n *    should be treated as if `is_immediate` is true.\n *\n * Steps also store some derived state that summarizes how they relate to other\n * steps within the same pattern. This is used to optimize the matching process:\n *  - `contains_captures` - Indicates that this step or one of its child steps\n *     has a non-empty `capture_ids` list.\n *  - `parent_pattern_guaranteed` - Indicates that if this step is reached, then\n *     it and all of its subsequent sibling steps within the same parent pattern\n *     are guaranteed to match.\n *  - `root_pattern_guaranteed` - Similar to `parent_pattern_guaranteed`, but\n *     for the entire top-level pattern. When iterating through a query's\n *     captures using `ts_query_cursor_next_capture`, this field is used to\n *     detect that a capture can safely be returned from a match that has not\n *     even completed yet.\n */\ntypedef struct {\n  TSSymbol symbol;\n  TSSymbol supertype_symbol;\n  TSFieldId field;\n  uint16_t capture_ids[MAX_STEP_CAPTURE_COUNT];\n  uint16_t depth;\n  uint16_t alternative_index;\n  uint16_t negated_field_list_id;\n  bool is_named: 1;\n  bool is_immediate: 1;\n  bool is_last_child: 1;\n  bool is_pass_through: 1;\n  bool is_dead_end: 1;\n  bool alternative_is_immediate: 1;\n  bool contains_captures: 1;\n  bool root_pattern_guaranteed: 1;\n  bool parent_pattern_guaranteed: 1;\n  bool is_missing: 1;\n} QueryStep;\n\n/*\n * Slice - A slice of an external array. Within a query, capture names,\n * literal string values, and predicate step information are stored in three\n * contiguous arrays. Individual captures, string values, and predicates are\n * represented as slices of these three arrays.\n */\ntypedef struct {\n  uint32_t offset;\n  uint32_t length;\n} Slice;\n\n/*\n * SymbolTable - a two-way mapping of strings to ids.\n */\ntypedef struct {\n  Array(char) characters;\n  Array(Slice) slices;\n} SymbolTable;\n\n/**\n * CaptureQuantifiers - a data structure holding the quantifiers of pattern captures.\n */\ntypedef Array(uint8_t) CaptureQuantifiers;\n\n/*\n * PatternEntry - Information about the starting point for matching a particular\n * pattern. These entries are stored in a 'pattern map' - a sorted array that\n * makes it possible to efficiently lookup patterns based on the symbol for their\n * first step. The entry consists of the following fields:\n * - `pattern_index` - the index of the pattern within the query\n * - `step_index` - the index of the pattern's first step in the shared `steps` array\n * - `is_rooted` - whether or not the pattern has a single root node. This property\n *   affects decisions about whether or not to start the pattern for nodes outside\n *   of a QueryCursor's range restriction.\n */\ntypedef struct {\n  uint16_t step_index;\n  uint16_t pattern_index;\n  bool is_rooted;\n} PatternEntry;\n\ntypedef struct {\n  Slice steps;\n  Slice predicate_steps;\n  uint32_t start_byte;\n  uint32_t end_byte;\n  bool is_non_local;\n} QueryPattern;\n\ntypedef struct {\n  uint32_t byte_offset;\n  uint16_t step_index;\n} StepOffset;\n\n/*\n * QueryState - The state of an in-progress match of a particular pattern\n * in a query. While executing, a `TSQueryCursor` must keep track of a number\n * of possible in-progress matches. Each of those possible matches is\n * represented as one of these states. Fields:\n * - `id` - A numeric id that is exposed to the public API. This allows the\n *    caller to remove a given match, preventing any more of its captures\n *    from being returned.\n * - `start_depth` - The depth in the tree where the first step of the state's\n *    pattern was matched.\n * - `pattern_index` - The pattern that the state is matching.\n * - `consumed_capture_count` - The number of captures from this match that\n *    have already been returned.\n * - `capture_list_id` - A numeric id that can be used to retrieve the state's\n *    list of captures from the `CaptureListPool`.\n * - `seeking_immediate_match` - A flag that indicates that the state's next\n *    step must be matched by the very next sibling. This is used when\n *    processing repetitions, or when processing a wildcard node followed by\n *    an anchor.\n * - `has_in_progress_alternatives` - A flag that indicates that there is are\n *    other states that have the same captures as this state, but are at\n *    different steps in their pattern. This means that in order to obey the\n *    'longest-match' rule, this state should not be returned as a match until\n *    it is clear that there can be no other alternative match with more captures.\n */\ntypedef struct {\n  uint32_t id;\n  uint32_t capture_list_id;\n  uint16_t start_depth;\n  uint16_t step_index;\n  uint16_t pattern_index;\n  uint16_t consumed_capture_count: 12;\n  bool seeking_immediate_match: 1;\n  bool has_in_progress_alternatives: 1;\n  bool dead: 1;\n  bool needs_parent: 1;\n} QueryState;\n\ntypedef Array(TSQueryCapture) CaptureList;\n\n/*\n * CaptureListPool - A collection of *lists* of captures. Each query state needs\n * to maintain its own list of captures. To avoid repeated allocations, this struct\n * maintains a fixed set of capture lists, and keeps track of which ones are\n * currently in use by a query state.\n */\ntypedef struct {\n  Array(CaptureList) list;\n  CaptureList empty_list;\n  // The maximum number of capture lists that we are allowed to allocate. We\n  // never allow `list` to allocate more entries than this, dropping pending\n  // matches if needed to stay under the limit.\n  uint32_t max_capture_list_count;\n  // The number of capture lists allocated in `list` that are not currently in\n  // use. We reuse those existing-but-unused capture lists before trying to\n  // allocate any new ones. We use an invalid value (UINT32_MAX) for a capture\n  // list's length to indicate that it's not in use.\n  uint32_t free_capture_list_count;\n} CaptureListPool;\n\n/*\n * AnalysisState - The state needed for walking the parse table when analyzing\n * a query pattern, to determine at which steps the pattern might fail to match.\n */\ntypedef struct {\n  TSStateId parse_state;\n  TSSymbol parent_symbol;\n  uint16_t child_index;\n  TSFieldId field_id: 15;\n  bool done: 1;\n} AnalysisStateEntry;\n\ntypedef struct {\n  AnalysisStateEntry stack[MAX_ANALYSIS_STATE_DEPTH];\n  uint16_t depth;\n  uint16_t step_index;\n  TSSymbol root_symbol;\n} AnalysisState;\n\ntypedef Array(AnalysisState *) AnalysisStateSet;\n\ntypedef struct {\n  AnalysisStateSet states;\n  AnalysisStateSet next_states;\n  AnalysisStateSet deeper_states;\n  AnalysisStateSet state_pool;\n  Array(uint16_t) final_step_indices;\n  Array(TSSymbol) finished_parent_symbols;\n  bool did_abort;\n} QueryAnalysis;\n\n/*\n * AnalysisSubgraph - A subset of the states in the parse table that are used\n * in constructing nodes with a certain symbol. Each state is accompanied by\n * some information about the possible node that could be produced in\n * downstream states.\n */\ntypedef struct {\n  TSStateId state;\n  uint16_t production_id;\n  uint8_t child_index: 7;\n  bool done: 1;\n} AnalysisSubgraphNode;\n\ntypedef struct {\n  TSSymbol symbol;\n  Array(TSStateId) start_states;\n  Array(AnalysisSubgraphNode) nodes;\n} AnalysisSubgraph;\n\ntypedef Array(AnalysisSubgraph) AnalysisSubgraphArray;\n\n/*\n * StatePredecessorMap - A map that stores the predecessors of each parse state.\n * This is used during query analysis to determine which parse states can lead\n * to which reduce actions.\n */\ntypedef struct {\n  TSStateId *contents;\n} StatePredecessorMap;\n\n/*\n * TSQuery - A tree query, compiled from a string of S-expressions. The query\n * itself is immutable. The mutable state used in the process of executing the\n * query is stored in a `TSQueryCursor`.\n */\nstruct TSQuery {\n  SymbolTable captures;\n  SymbolTable predicate_values;\n  Array(CaptureQuantifiers) capture_quantifiers;\n  Array(QueryStep) steps;\n  Array(PatternEntry) pattern_map;\n  Array(TSQueryPredicateStep) predicate_steps;\n  Array(QueryPattern) patterns;\n  Array(StepOffset) step_offsets;\n  Array(TSFieldId) negated_fields;\n  Array(char) string_buffer;\n  Array(TSSymbol) repeat_symbols_with_rootless_patterns;\n  const TSLanguage *language;\n  uint16_t wildcard_root_pattern_count;\n};\n\n/*\n * TSQueryCursor - A stateful struct used to execute a query on a tree.\n */\nstruct TSQueryCursor {\n  const TSQuery *query;\n  TSTreeCursor cursor;\n  Array(QueryState) states;\n  Array(QueryState) finished_states;\n  CaptureListPool capture_list_pool;\n  uint32_t depth;\n  uint32_t max_start_depth;\n  uint32_t start_byte;\n  uint32_t end_byte;\n  TSPoint start_point;\n  TSPoint end_point;\n  uint32_t next_state_id;\n  TSClock end_clock;\n  TSDuration timeout_duration;\n  const TSQueryCursorOptions *query_options;\n  TSQueryCursorState query_state;\n  unsigned operation_count;\n  bool on_visible_node;\n  bool ascending;\n  bool halted;\n  bool did_exceed_match_limit;\n};\n\nstatic const TSQueryError PARENT_DONE = -1;\nstatic const uint16_t PATTERN_DONE_MARKER = UINT16_MAX;\nstatic const uint16_t NONE = UINT16_MAX;\nstatic const TSSymbol WILDCARD_SYMBOL = 0;\nstatic const unsigned OP_COUNT_PER_QUERY_TIMEOUT_CHECK = 100;\n\n/**********\n * Stream\n **********/\n\n// Advance to the next unicode code point in the stream.\nstatic bool stream_advance(Stream *self) {\n  self->input += self->next_size;\n  if (self->input < self->end) {\n    uint32_t size = ts_decode_utf8(\n      (const uint8_t *)self->input,\n      (uint32_t)(self->end - self->input),\n      &self->next\n    );\n    if (size > 0) {\n      self->next_size = size;\n      return true;\n    }\n  } else {\n    self->next_size = 0;\n    self->next = '\\0';\n  }\n  return false;\n}\n\n// Reset the stream to the given input position, represented as a pointer\n// into the input string.\nstatic void stream_reset(Stream *self, const char *input) {\n  self->input = input;\n  self->next_size = 0;\n  stream_advance(self);\n}\n\nstatic Stream stream_new(const char *string, uint32_t length) {\n  Stream self = {\n    .next = 0,\n    .input = string,\n    .start = string,\n    .end = string + length,\n  };\n  stream_advance(&self);\n  return self;\n}\n\nstatic void stream_skip_whitespace(Stream *self) {\n  for (;;) {\n    if (iswspace(self->next)) {\n      stream_advance(self);\n    } else if (self->next == ';') {\n      // skip over comments\n      stream_advance(self);\n      while (self->next && self->next != '\\n') {\n        if (!stream_advance(self)) break;\n      }\n    } else {\n      break;\n    }\n  }\n}\n\nstatic bool stream_is_ident_start(Stream *self) {\n  return iswalnum(self->next) || self->next == '_' || self->next == '-';\n}\n\nstatic void stream_scan_identifier(Stream *stream) {\n  do {\n    stream_advance(stream);\n  } while (\n    iswalnum(stream->next) ||\n    stream->next == '_' ||\n    stream->next == '-' ||\n    stream->next == '.'\n  );\n}\n\nstatic uint32_t stream_offset(Stream *self) {\n  return (uint32_t)(self->input - self->start);\n}\n\n/******************\n * CaptureListPool\n ******************/\n\nstatic CaptureListPool capture_list_pool_new(void) {\n  return (CaptureListPool) {\n    .list = array_new(),\n    .empty_list = array_new(),\n    .max_capture_list_count = UINT32_MAX,\n    .free_capture_list_count = 0,\n  };\n}\n\nstatic void capture_list_pool_reset(CaptureListPool *self) {\n  for (uint16_t i = 0; i < (uint16_t)self->list.size; i++) {\n    // This invalid size means that the list is not in use.\n    array_get(&self->list, i)->size = UINT32_MAX;\n  }\n  self->free_capture_list_count = self->list.size;\n}\n\nstatic void capture_list_pool_delete(CaptureListPool *self) {\n  for (uint16_t i = 0; i < (uint16_t)self->list.size; i++) {\n    array_delete(array_get(&self->list, i));\n  }\n  array_delete(&self->list);\n}\n\nstatic const CaptureList *capture_list_pool_get(const CaptureListPool *self, uint16_t id) {\n  if (id >= self->list.size) return &self->empty_list;\n  return array_get(&self->list, id);\n}\n\nstatic CaptureList *capture_list_pool_get_mut(CaptureListPool *self, uint16_t id) {\n  ts_assert(id < self->list.size);\n  return array_get(&self->list, id);\n}\n\nstatic bool capture_list_pool_is_empty(const CaptureListPool *self) {\n  // The capture list pool is empty if all allocated lists are in use, and we\n  // have reached the maximum allowed number of allocated lists.\n  return self->free_capture_list_count == 0 && self->list.size >= self->max_capture_list_count;\n}\n\nstatic uint16_t capture_list_pool_acquire(CaptureListPool *self) {\n  // First see if any already allocated capture list is currently unused.\n  if (self->free_capture_list_count > 0) {\n    for (uint16_t i = 0; i < (uint16_t)self->list.size; i++) {\n      if (array_get(&self->list, i)->size == UINT32_MAX) {\n        array_clear(array_get(&self->list, i));\n        self->free_capture_list_count--;\n        return i;\n      }\n    }\n  }\n\n  // Otherwise allocate and initialize a new capture list, as long as that\n  // doesn't put us over the requested maximum.\n  uint32_t i = self->list.size;\n  if (i >= self->max_capture_list_count) {\n    return NONE;\n  }\n  CaptureList list;\n  array_init(&list);\n  array_push(&self->list, list);\n  return i;\n}\n\nstatic void capture_list_pool_release(CaptureListPool *self, uint16_t id) {\n  if (id >= self->list.size) return;\n  array_get(&self->list, id)->size = UINT32_MAX;\n  self->free_capture_list_count++;\n}\n\n/**************\n * Quantifiers\n **************/\n\nstatic TSQuantifier quantifier_mul(\n  TSQuantifier left,\n  TSQuantifier right\n) {\n  switch (left)\n  {\n    case TSQuantifierZero:\n      return TSQuantifierZero;\n    case TSQuantifierZeroOrOne:\n      switch (right) {\n        case TSQuantifierZero:\n          return TSQuantifierZero;\n        case TSQuantifierZeroOrOne:\n        case TSQuantifierOne:\n          return TSQuantifierZeroOrOne;\n        case TSQuantifierZeroOrMore:\n        case TSQuantifierOneOrMore:\n          return TSQuantifierZeroOrMore;\n      };\n      break;\n    case TSQuantifierZeroOrMore:\n      switch (right) {\n        case TSQuantifierZero:\n          return TSQuantifierZero;\n        case TSQuantifierZeroOrOne:\n        case TSQuantifierZeroOrMore:\n        case TSQuantifierOne:\n        case TSQuantifierOneOrMore:\n          return TSQuantifierZeroOrMore;\n      };\n      break;\n    case TSQuantifierOne:\n      return right;\n    case TSQuantifierOneOrMore:\n      switch (right) {\n        case TSQuantifierZero:\n          return TSQuantifierZero;\n        case TSQuantifierZeroOrOne:\n        case TSQuantifierZeroOrMore:\n          return TSQuantifierZeroOrMore;\n        case TSQuantifierOne:\n        case TSQuantifierOneOrMore:\n          return TSQuantifierOneOrMore;\n      };\n      break;\n  }\n  return TSQuantifierZero; // to make compiler happy, but all cases should be covered above!\n}\n\nstatic TSQuantifier quantifier_join(\n  TSQuantifier left,\n  TSQuantifier right\n) {\n  switch (left)\n  {\n    case TSQuantifierZero:\n      switch (right) {\n        case TSQuantifierZero:\n          return TSQuantifierZero;\n        case TSQuantifierZeroOrOne:\n        case TSQuantifierOne:\n          return TSQuantifierZeroOrOne;\n        case TSQuantifierZeroOrMore:\n        case TSQuantifierOneOrMore:\n          return TSQuantifierZeroOrMore;\n      };\n      break;\n    case TSQuantifierZeroOrOne:\n      switch (right) {\n        case TSQuantifierZero:\n        case TSQuantifierZeroOrOne:\n        case TSQuantifierOne:\n          return TSQuantifierZeroOrOne;\n          break;\n        case TSQuantifierZeroOrMore:\n        case TSQuantifierOneOrMore:\n          return TSQuantifierZeroOrMore;\n          break;\n      };\n      break;\n    case TSQuantifierZeroOrMore:\n      return TSQuantifierZeroOrMore;\n    case TSQuantifierOne:\n      switch (right) {\n        case TSQuantifierZero:\n        case TSQuantifierZeroOrOne:\n          return TSQuantifierZeroOrOne;\n        case TSQuantifierZeroOrMore:\n          return TSQuantifierZeroOrMore;\n        case TSQuantifierOne:\n          return TSQuantifierOne;\n        case TSQuantifierOneOrMore:\n          return TSQuantifierOneOrMore;\n      };\n      break;\n    case TSQuantifierOneOrMore:\n      switch (right) {\n        case TSQuantifierZero:\n        case TSQuantifierZeroOrOne:\n        case TSQuantifierZeroOrMore:\n          return TSQuantifierZeroOrMore;\n        case TSQuantifierOne:\n        case TSQuantifierOneOrMore:\n          return TSQuantifierOneOrMore;\n      };\n      break;\n  }\n  return TSQuantifierZero; // to make compiler happy, but all cases should be covered above!\n}\n\nstatic TSQuantifier quantifier_add(\n  TSQuantifier left,\n  TSQuantifier right\n) {\n  switch (left)\n  {\n    case TSQuantifierZero:\n      return right;\n    case TSQuantifierZeroOrOne:\n      switch (right) {\n        case TSQuantifierZero:\n          return TSQuantifierZeroOrOne;\n        case TSQuantifierZeroOrOne:\n        case TSQuantifierZeroOrMore:\n          return TSQuantifierZeroOrMore;\n        case TSQuantifierOne:\n        case TSQuantifierOneOrMore:\n          return TSQuantifierOneOrMore;\n      };\n      break;\n    case TSQuantifierZeroOrMore:\n      switch (right) {\n        case TSQuantifierZero:\n          return TSQuantifierZeroOrMore;\n        case TSQuantifierZeroOrOne:\n        case TSQuantifierZeroOrMore:\n          return TSQuantifierZeroOrMore;\n        case TSQuantifierOne:\n        case TSQuantifierOneOrMore:\n          return TSQuantifierOneOrMore;\n      };\n      break;\n    case TSQuantifierOne:\n      switch (right) {\n        case TSQuantifierZero:\n          return TSQuantifierOne;\n        case TSQuantifierZeroOrOne:\n        case TSQuantifierZeroOrMore:\n        case TSQuantifierOne:\n        case TSQuantifierOneOrMore:\n          return TSQuantifierOneOrMore;\n      };\n      break;\n    case TSQuantifierOneOrMore:\n      return TSQuantifierOneOrMore;\n  }\n  return TSQuantifierZero; // to make compiler happy, but all cases should be covered above!\n}\n\n// Create new capture quantifiers structure\nstatic CaptureQuantifiers capture_quantifiers_new(void) {\n  return (CaptureQuantifiers) array_new();\n}\n\n// Delete capture quantifiers structure\nstatic void capture_quantifiers_delete(\n  CaptureQuantifiers *self\n) {\n  array_delete(self);\n}\n\n// Clear capture quantifiers structure\nstatic void capture_quantifiers_clear(\n  CaptureQuantifiers *self\n) {\n  array_clear(self);\n}\n\n// Replace capture quantifiers with the given quantifiers\nstatic void capture_quantifiers_replace(\n  CaptureQuantifiers *self,\n  CaptureQuantifiers *quantifiers\n) {\n  array_clear(self);\n  array_push_all(self, quantifiers);\n}\n\n// Return capture quantifier for the given capture id\nstatic TSQuantifier capture_quantifier_for_id(\n  const CaptureQuantifiers *self,\n  uint16_t id\n) {\n  return (self->size <= id) ? TSQuantifierZero : (TSQuantifier) *array_get(self, id);\n}\n\n// Add the given quantifier to the current value for id\nstatic void capture_quantifiers_add_for_id(\n  CaptureQuantifiers *self,\n  uint16_t id,\n  TSQuantifier quantifier\n) {\n  if (self->size <= id) {\n    array_grow_by(self, id + 1 - self->size);\n  }\n  uint8_t *own_quantifier = array_get(self, id);\n  *own_quantifier = (uint8_t) quantifier_add((TSQuantifier) *own_quantifier, quantifier);\n}\n\n// Point-wise add the given quantifiers to the current values\nstatic void capture_quantifiers_add_all(\n  CaptureQuantifiers *self,\n  CaptureQuantifiers *quantifiers\n) {\n  if (self->size < quantifiers->size) {\n    array_grow_by(self, quantifiers->size - self->size);\n  }\n  for (uint16_t id = 0; id < (uint16_t)quantifiers->size; id++) {\n    uint8_t *quantifier = array_get(quantifiers, id);\n    uint8_t *own_quantifier = array_get(self, id);\n    *own_quantifier = (uint8_t) quantifier_add((TSQuantifier) *own_quantifier, (TSQuantifier) *quantifier);\n  }\n}\n\n// Join the given quantifier with the current values\nstatic void capture_quantifiers_mul(\n  CaptureQuantifiers *self,\n  TSQuantifier quantifier\n) {\n  for (uint16_t id = 0; id < (uint16_t)self->size; id++) {\n    uint8_t *own_quantifier = array_get(self, id);\n    *own_quantifier = (uint8_t) quantifier_mul((TSQuantifier) *own_quantifier, quantifier);\n  }\n}\n\n// Point-wise join the quantifiers from a list of alternatives with the current values\nstatic void capture_quantifiers_join_all(\n  CaptureQuantifiers *self,\n  CaptureQuantifiers *quantifiers\n) {\n  if (self->size < quantifiers->size) {\n    array_grow_by(self, quantifiers->size - self->size);\n  }\n  for (uint32_t id = 0; id < quantifiers->size; id++) {\n    uint8_t *quantifier = array_get(quantifiers, id);\n    uint8_t *own_quantifier = array_get(self, id);\n    *own_quantifier = (uint8_t) quantifier_join((TSQuantifier) *own_quantifier, (TSQuantifier) *quantifier);\n  }\n  for (uint32_t id = quantifiers->size; id < self->size; id++) {\n    uint8_t *own_quantifier = array_get(self, id);\n    *own_quantifier = (uint8_t) quantifier_join((TSQuantifier) *own_quantifier, TSQuantifierZero);\n  }\n}\n\n/**************\n * SymbolTable\n **************/\n\nstatic SymbolTable symbol_table_new(void) {\n  return (SymbolTable) {\n    .characters = array_new(),\n    .slices = array_new(),\n  };\n}\n\nstatic void symbol_table_delete(SymbolTable *self) {\n  array_delete(&self->characters);\n  array_delete(&self->slices);\n}\n\nstatic int symbol_table_id_for_name(\n  const SymbolTable *self,\n  const char *name,\n  uint32_t length\n) {\n  for (unsigned i = 0; i < self->slices.size; i++) {\n    Slice slice = *array_get(&self->slices, i);\n    if (\n      slice.length == length &&\n      !strncmp(array_get(&self->characters, slice.offset), name, length)\n    ) return i;\n  }\n  return -1;\n}\n\nstatic const char *symbol_table_name_for_id(\n  const SymbolTable *self,\n  uint16_t id,\n  uint32_t *length\n) {\n  Slice slice = *(array_get(&self->slices,id));\n  *length = slice.length;\n  return array_get(&self->characters, slice.offset);\n}\n\nstatic uint16_t symbol_table_insert_name(\n  SymbolTable *self,\n  const char *name,\n  uint32_t length\n) {\n  int id = symbol_table_id_for_name(self, name, length);\n  if (id >= 0) return (uint16_t)id;\n  Slice slice = {\n    .offset = self->characters.size,\n    .length = length,\n  };\n  array_grow_by(&self->characters, length + 1);\n  memcpy(array_get(&self->characters, slice.offset), name, length);\n  *array_get(&self->characters, self->characters.size - 1) = 0;\n  array_push(&self->slices, slice);\n  return self->slices.size - 1;\n}\n\n/************\n * QueryStep\n ************/\n\nstatic QueryStep query_step__new(\n  TSSymbol symbol,\n  uint16_t depth,\n  bool is_immediate\n) {\n  QueryStep step = {\n    .symbol = symbol,\n    .depth = depth,\n    .field = 0,\n    .alternative_index = NONE,\n    .negated_field_list_id = 0,\n    .contains_captures = false,\n    .is_last_child = false,\n    .is_named = false,\n    .is_pass_through = false,\n    .is_dead_end = false,\n    .root_pattern_guaranteed = false,\n    .is_immediate = is_immediate,\n    .alternative_is_immediate = false,\n  };\n  for (unsigned i = 0; i < MAX_STEP_CAPTURE_COUNT; i++) {\n    step.capture_ids[i] = NONE;\n  }\n  return step;\n}\n\nstatic void query_step__add_capture(QueryStep *self, uint16_t capture_id) {\n  for (unsigned i = 0; i < MAX_STEP_CAPTURE_COUNT; i++) {\n    if (self->capture_ids[i] == NONE) {\n      self->capture_ids[i] = capture_id;\n      break;\n    }\n  }\n}\n\nstatic void query_step__remove_capture(QueryStep *self, uint16_t capture_id) {\n  for (unsigned i = 0; i < MAX_STEP_CAPTURE_COUNT; i++) {\n    if (self->capture_ids[i] == capture_id) {\n      self->capture_ids[i] = NONE;\n      while (i + 1 < MAX_STEP_CAPTURE_COUNT) {\n        if (self->capture_ids[i + 1] == NONE) break;\n        self->capture_ids[i] = self->capture_ids[i + 1];\n        self->capture_ids[i + 1] = NONE;\n        i++;\n      }\n      break;\n    }\n  }\n}\n\n/**********************\n * StatePredecessorMap\n **********************/\n\nstatic inline StatePredecessorMap state_predecessor_map_new(\n  const TSLanguage *language\n) {\n  return (StatePredecessorMap) {\n    .contents = ts_calloc(\n      (size_t)language->state_count * (MAX_STATE_PREDECESSOR_COUNT + 1),\n      sizeof(TSStateId)\n    ),\n  };\n}\n\nstatic inline void state_predecessor_map_delete(StatePredecessorMap *self) {\n  ts_free(self->contents);\n}\n\nstatic inline void state_predecessor_map_add(\n  StatePredecessorMap *self,\n  TSStateId state,\n  TSStateId predecessor\n) {\n  size_t index = (size_t)state * (MAX_STATE_PREDECESSOR_COUNT + 1);\n  TSStateId *count = &self->contents[index];\n  if (\n    *count == 0 ||\n    (*count < MAX_STATE_PREDECESSOR_COUNT && self->contents[index + *count] != predecessor)\n  ) {\n    (*count)++;\n    self->contents[index + *count] = predecessor;\n  }\n}\n\nstatic inline const TSStateId *state_predecessor_map_get(\n  const StatePredecessorMap *self,\n  TSStateId state,\n  unsigned *count\n) {\n  size_t index = (size_t)state * (MAX_STATE_PREDECESSOR_COUNT + 1);\n  *count = self->contents[index];\n  return &self->contents[index + 1];\n}\n\n/****************\n * AnalysisState\n ****************/\n\nstatic unsigned analysis_state__recursion_depth(const AnalysisState *self) {\n  unsigned result = 0;\n  for (unsigned i = 0; i < self->depth; i++) {\n    TSSymbol symbol = self->stack[i].parent_symbol;\n    for (unsigned j = 0; j < i; j++) {\n      if (self->stack[j].parent_symbol == symbol) {\n        result++;\n        break;\n      }\n    }\n  }\n  return result;\n}\n\nstatic inline int analysis_state__compare(\n  AnalysisState *const *self,\n  AnalysisState *const *other\n) {\n  if ((*self)->depth < (*other)->depth) return 1;\n  for (unsigned i = 0; i < (*self)->depth; i++) {\n    if (i >= (*other)->depth) return -1;\n    AnalysisStateEntry s1 = (*self)->stack[i];\n    AnalysisStateEntry s2 = (*other)->stack[i];\n    if (s1.child_index < s2.child_index) return -1;\n    if (s1.child_index > s2.child_index) return 1;\n    if (s1.parent_symbol < s2.parent_symbol) return -1;\n    if (s1.parent_symbol > s2.parent_symbol) return 1;\n    if (s1.parse_state < s2.parse_state) return -1;\n    if (s1.parse_state > s2.parse_state) return 1;\n    if (s1.field_id < s2.field_id) return -1;\n    if (s1.field_id > s2.field_id) return 1;\n  }\n  if ((*self)->step_index < (*other)->step_index) return -1;\n  if ((*self)->step_index > (*other)->step_index) return 1;\n  return 0;\n}\n\nstatic inline AnalysisStateEntry *analysis_state__top(AnalysisState *self) {\n  if (self->depth == 0) {\n    return &self->stack[0];\n  }\n  return &self->stack[self->depth - 1];\n}\n\nstatic inline bool analysis_state__has_supertype(AnalysisState *self, TSSymbol symbol) {\n  for (unsigned i = 0; i < self->depth; i++) {\n    if (self->stack[i].parent_symbol == symbol) return true;\n  }\n  return false;\n}\n\n/******************\n * AnalysisStateSet\n ******************/\n\n// Obtains an `AnalysisState` instance, either by consuming one from this set's object pool, or by\n// cloning one from scratch.\nstatic inline AnalysisState *analysis_state_pool__clone_or_reuse(\n  AnalysisStateSet *self,\n  AnalysisState *borrowed_item\n) {\n  AnalysisState *new_item;\n  if (self->size) {\n    new_item = array_pop(self);\n  } else {\n    new_item = ts_malloc(sizeof(AnalysisState));\n  }\n  *new_item = *borrowed_item;\n  return new_item;\n}\n\n// Inserts a clone of the passed-in item at the appropriate position to maintain ordering in this\n// set. The set does not contain duplicates, so if the item is already present, it will not be\n// inserted, and no clone will be made.\n//\n// The caller retains ownership of the passed-in memory. However, the clone that is created by this\n// function will be managed by the state set.\nstatic inline void analysis_state_set__insert_sorted(\n  AnalysisStateSet *self,\n  AnalysisStateSet *pool,\n  AnalysisState *borrowed_item\n) {\n  unsigned index, exists;\n  array_search_sorted_with(self, analysis_state__compare, &borrowed_item, &index, &exists);\n  if (!exists) {\n    AnalysisState *new_item = analysis_state_pool__clone_or_reuse(pool, borrowed_item);\n    array_insert(self, index, new_item);\n  }\n}\n\n// Inserts a clone of the passed-in item at the end position of this list.\n//\n// IMPORTANT: The caller MUST ENSURE that this item is larger (by the comparison function\n// `analysis_state__compare`) than largest item already in this set. If items are inserted in the\n// wrong order, the set will not function properly for future use.\n//\n// The caller retains ownership of the passed-in memory. However, the clone that is created by this\n// function will be managed by the state set.\nstatic inline void analysis_state_set__push(\n  AnalysisStateSet *self,\n  AnalysisStateSet *pool,\n  AnalysisState *borrowed_item\n) {\n  AnalysisState *new_item = analysis_state_pool__clone_or_reuse(pool, borrowed_item);\n  array_push(self, new_item);\n}\n\n// Removes all items from this set, returning it to an empty state.\nstatic inline void analysis_state_set__clear(AnalysisStateSet *self, AnalysisStateSet *pool) {\n  array_push_all(pool, self);\n  array_clear(self);\n}\n\n// Releases all memory that is managed with this state set, including any items currently present.\n// After calling this function, the set is no longer suitable for use.\nstatic inline void analysis_state_set__delete(AnalysisStateSet *self) {\n  for (unsigned i = 0; i < self->size; i++) {\n    ts_free(self->contents[i]);\n  }\n  array_delete(self);\n}\n\n/****************\n * QueryAnalyzer\n ****************/\n\nstatic inline QueryAnalysis query_analysis__new(void) {\n  return (QueryAnalysis) {\n    .states = array_new(),\n    .next_states = array_new(),\n    .deeper_states = array_new(),\n    .state_pool = array_new(),\n    .final_step_indices = array_new(),\n    .finished_parent_symbols = array_new(),\n    .did_abort = false,\n  };\n}\n\nstatic inline void query_analysis__delete(QueryAnalysis *self) {\n  analysis_state_set__delete(&self->states);\n  analysis_state_set__delete(&self->next_states);\n  analysis_state_set__delete(&self->deeper_states);\n  analysis_state_set__delete(&self->state_pool);\n  array_delete(&self->final_step_indices);\n  array_delete(&self->finished_parent_symbols);\n}\n\n/***********************\n * AnalysisSubgraphNode\n ***********************/\n\nstatic inline int analysis_subgraph_node__compare(const AnalysisSubgraphNode *self, const AnalysisSubgraphNode *other) {\n  if (self->state < other->state) return -1;\n  if (self->state > other->state) return 1;\n  if (self->child_index < other->child_index) return -1;\n  if (self->child_index > other->child_index) return 1;\n  if (self->done < other->done) return -1;\n  if (self->done > other->done) return 1;\n  if (self->production_id < other->production_id) return -1;\n  if (self->production_id > other->production_id) return 1;\n  return 0;\n}\n\n/*********\n * Query\n *********/\n\n// The `pattern_map` contains a mapping from TSSymbol values to indices in the\n// `steps` array. For a given syntax node, the `pattern_map` makes it possible\n// to quickly find the starting steps of all of the patterns whose root matches\n// that node. Each entry has two fields: a `pattern_index`, which identifies one\n// of the patterns in the query, and a `step_index`, which indicates the start\n// offset of that pattern's steps within the `steps` array.\n//\n// The entries are sorted by the patterns' root symbols, and lookups use a\n// binary search. This ensures that the cost of this initial lookup step\n// scales logarithmically with the number of patterns in the query.\n//\n// This returns `true` if the symbol is present and `false` otherwise.\n// If the symbol is not present `*result` is set to the index where the\n// symbol should be inserted.\nstatic inline bool ts_query__pattern_map_search(\n  const TSQuery *self,\n  TSSymbol needle,\n  uint32_t *result\n) {\n  uint32_t base_index = self->wildcard_root_pattern_count;\n  uint32_t size = self->pattern_map.size - base_index;\n  if (size == 0) {\n    *result = base_index;\n    return false;\n  }\n  while (size > 1) {\n    uint32_t half_size = size / 2;\n    uint32_t mid_index = base_index + half_size;\n    TSSymbol mid_symbol = array_get(&self->steps,\n      array_get(&self->pattern_map, mid_index)->step_index\n    )->symbol;\n    if (needle > mid_symbol) base_index = mid_index;\n    size -= half_size;\n  }\n\n  TSSymbol symbol = array_get(&self->steps,\n    array_get(&self->pattern_map, base_index)->step_index\n  )->symbol;\n\n  if (needle > symbol) {\n    base_index++;\n    if (base_index < self->pattern_map.size) {\n      symbol = array_get(&self->steps,\n        array_get(&self->pattern_map, base_index)->step_index\n      )->symbol;\n    }\n  }\n\n  *result = base_index;\n  return needle == symbol;\n}\n\n// Insert a new pattern's start index into the pattern map, maintaining\n// the pattern map's ordering invariant.\nstatic inline void ts_query__pattern_map_insert(\n  TSQuery *self,\n  TSSymbol symbol,\n  PatternEntry new_entry\n) {\n  uint32_t index;\n  ts_query__pattern_map_search(self, symbol, &index);\n\n  // Ensure that the entries are sorted not only by symbol, but also\n  // by pattern_index. This way, states for earlier patterns will be\n  // initiated first, which allows the ordering of the states array\n  // to be maintained more efficiently.\n  while (index < self->pattern_map.size) {\n    PatternEntry *entry = array_get(&self->pattern_map, index);\n    if (\n      array_get(&self->steps, entry->step_index)->symbol == symbol &&\n      entry->pattern_index < new_entry.pattern_index\n    ) {\n      index++;\n    } else {\n      break;\n    }\n  }\n\n  array_insert(&self->pattern_map, index, new_entry);\n}\n\n// Walk the subgraph for this non-terminal, tracking all of the possible\n// sequences of progress within the pattern.\nstatic void ts_query__perform_analysis(\n  TSQuery *self,\n  const AnalysisSubgraphArray *subgraphs,\n  QueryAnalysis *analysis\n) {\n  unsigned recursion_depth_limit = 0;\n  unsigned prev_final_step_count = 0;\n  array_clear(&analysis->final_step_indices);\n  array_clear(&analysis->finished_parent_symbols);\n\n  for (unsigned iteration = 0;; iteration++) {\n    if (iteration == MAX_ANALYSIS_ITERATION_COUNT) {\n      analysis->did_abort = true;\n      break;\n    }\n\n    #ifdef DEBUG_ANALYZE_QUERY\n      printf(\"Iteration: %u. Final step indices:\", iteration);\n      for (unsigned j = 0; j < analysis->final_step_indices.size; j++) {\n        printf(\" %4u\", *array_get(&analysis->final_step_indices, j));\n      }\n      printf(\"\\n\");\n      for (unsigned j = 0; j < analysis->states.size; j++) {\n        AnalysisState *state = *array_get(&analysis->states, j);\n        printf(\"  %3u: step: %u, stack: [\", j, state->step_index);\n        for (unsigned k = 0; k < state->depth; k++) {\n          printf(\n            \" {%s, child: %u, state: %4u\",\n            self->language->symbol_names[state->stack[k].parent_symbol],\n            state->stack[k].child_index,\n            state->stack[k].parse_state\n          );\n          if (state->stack[k].field_id) printf(\", field: %s\", self->language->field_names[state->stack[k].field_id]);\n          if (state->stack[k].done) printf(\", DONE\");\n          printf(\"}\");\n        }\n        printf(\" ]\\n\");\n      }\n    #endif\n\n    // If no further progress can be made within the current recursion depth limit, then\n    // bump the depth limit by one, and continue to process the states the exceeded the\n    // limit. But only allow this if progress has been made since the last time the depth\n    // limit was increased.\n    if (analysis->states.size == 0) {\n      if (\n        analysis->deeper_states.size > 0 &&\n        analysis->final_step_indices.size > prev_final_step_count\n      ) {\n        #ifdef DEBUG_ANALYZE_QUERY\n          printf(\"Increase recursion depth limit to %u\\n\", recursion_depth_limit + 1);\n        #endif\n\n        prev_final_step_count = analysis->final_step_indices.size;\n        recursion_depth_limit++;\n        AnalysisStateSet _states = analysis->states;\n        analysis->states = analysis->deeper_states;\n        analysis->deeper_states = _states;\n        continue;\n      }\n\n      break;\n    }\n\n    analysis_state_set__clear(&analysis->next_states, &analysis->state_pool);\n    for (unsigned j = 0; j < analysis->states.size; j++) {\n      AnalysisState * const state = *array_get(&analysis->states, j);\n\n      // For efficiency, it's important to avoid processing the same analysis state more\n      // than once. To achieve this, keep the states in order of ascending position within\n      // their hypothetical syntax trees. In each iteration of this loop, start by advancing\n      // the states that have made the least progress. Avoid advancing states that have already\n      // made more progress.\n      if (analysis->next_states.size > 0) {\n        int comparison = analysis_state__compare(\n          &state,\n          array_back(&analysis->next_states)\n        );\n        if (comparison == 0) {\n          analysis_state_set__insert_sorted(&analysis->next_states, &analysis->state_pool, state);\n          continue;\n        } else if (comparison > 0) {\n          #ifdef DEBUG_ANALYZE_QUERY\n            printf(\"Terminate iteration at state %u\\n\", j);\n          #endif\n          while (j < analysis->states.size) {\n            analysis_state_set__push(\n              &analysis->next_states,\n              &analysis->state_pool,\n              *array_get(&analysis->states, j)\n            );\n            j++;\n          }\n          break;\n        }\n      }\n\n      const TSStateId parse_state = analysis_state__top(state)->parse_state;\n      const TSSymbol parent_symbol = analysis_state__top(state)->parent_symbol;\n      const TSFieldId parent_field_id = analysis_state__top(state)->field_id;\n      const unsigned child_index = analysis_state__top(state)->child_index;\n      const QueryStep * const step = array_get(&self->steps, state->step_index);\n\n      unsigned subgraph_index, exists;\n      array_search_sorted_by(subgraphs, .symbol, parent_symbol, &subgraph_index, &exists);\n      if (!exists) continue;\n      const AnalysisSubgraph *subgraph = array_get(subgraphs, subgraph_index);\n\n      // Follow every possible path in the parse table, but only visit states that\n      // are part of the subgraph for the current symbol.\n      LookaheadIterator lookahead_iterator = ts_language_lookaheads(self->language, parse_state);\n      while (ts_lookahead_iterator__next(&lookahead_iterator)) {\n        TSSymbol sym = lookahead_iterator.symbol;\n\n        AnalysisSubgraphNode successor = {\n          .state = parse_state,\n          .child_index = child_index,\n        };\n        if (lookahead_iterator.action_count) {\n          const TSParseAction *action = &lookahead_iterator.actions[lookahead_iterator.action_count - 1];\n          if (action->type == TSParseActionTypeShift) {\n            if (!action->shift.extra) {\n              successor.state = action->shift.state;\n              successor.child_index++;\n            }\n          } else {\n            continue;\n          }\n        } else if (lookahead_iterator.next_state != 0) {\n          successor.state = lookahead_iterator.next_state;\n          successor.child_index++;\n        } else {\n          continue;\n        }\n\n        unsigned node_index;\n        array_search_sorted_with(\n          &subgraph->nodes,\n          analysis_subgraph_node__compare, &successor,\n          &node_index, &exists\n        );\n        while (node_index < subgraph->nodes.size) {\n          AnalysisSubgraphNode *node = array_get(&subgraph->nodes, node_index);\n          node_index++;\n          if (node->state != successor.state || node->child_index != successor.child_index) break;\n\n          // Use the subgraph to determine what alias and field will eventually be applied\n          // to this child node.\n          TSSymbol alias = ts_language_alias_at(self->language, node->production_id, child_index);\n          TSSymbol visible_symbol = alias\n            ? alias\n            : self->language->symbol_metadata[sym].visible\n              ? self->language->public_symbol_map[sym]\n              : 0;\n          TSFieldId field_id = parent_field_id;\n          if (!field_id) {\n            const TSFieldMapEntry *field_map, *field_map_end;\n            ts_language_field_map(self->language, node->production_id, &field_map, &field_map_end);\n            for (; field_map != field_map_end; field_map++) {\n              if (!field_map->inherited && field_map->child_index == child_index) {\n                field_id = field_map->field_id;\n                break;\n              }\n            }\n          }\n\n          // Create a new state that has advanced past this hypothetical subtree.\n          AnalysisState next_state = *state;\n          AnalysisStateEntry *next_state_top = analysis_state__top(&next_state);\n          next_state_top->child_index = successor.child_index;\n          next_state_top->parse_state = successor.state;\n          if (node->done) next_state_top->done = true;\n\n          // Determine if this hypothetical child node would match the current step\n          // of the query pattern.\n          bool does_match = false;\n\n          // ERROR nodes can appear anywhere, so if the step is \n          // looking for an ERROR node, consider it potentially matchable.\n          if (step->symbol == ts_builtin_sym_error) {\n            does_match = true;\n          } else if (visible_symbol) {\n            does_match = true;\n            if (step->symbol == WILDCARD_SYMBOL) {\n              if (\n                step->is_named &&\n                !self->language->symbol_metadata[visible_symbol].named\n              ) does_match = false;\n            } else if (step->symbol != visible_symbol) {\n              does_match = false;\n            }\n            if (step->field && step->field != field_id) {\n              does_match = false;\n            }\n            if (\n              step->supertype_symbol &&\n              !analysis_state__has_supertype(state, step->supertype_symbol)\n            ) does_match = false;\n          }\n\n          // If this child is hidden, then descend into it and walk through its children.\n          // If the top entry of the stack is at the end of its rule, then that entry can\n          // be replaced. Otherwise, push a new entry onto the stack.\n          else if (sym >= self->language->token_count) {\n            if (!next_state_top->done) {\n              if (next_state.depth + 1 >= MAX_ANALYSIS_STATE_DEPTH) {\n                #ifdef DEBUG_ANALYZE_QUERY\n                  printf(\"Exceeded depth limit for state %u\\n\", j);\n                #endif\n\n                analysis->did_abort = true;\n                continue;\n              }\n\n              next_state.depth++;\n              next_state_top = analysis_state__top(&next_state);\n            }\n\n            *next_state_top = (AnalysisStateEntry) {\n              .parse_state = parse_state,\n              .parent_symbol = sym,\n              .child_index = 0,\n              .field_id = field_id,\n              .done = false,\n            };\n\n            if (analysis_state__recursion_depth(&next_state) > recursion_depth_limit) {\n              analysis_state_set__insert_sorted(\n                &analysis->deeper_states,\n                &analysis->state_pool,\n                &next_state\n              );\n              continue;\n            }\n          }\n\n          // Pop from the stack when this state reached the end of its current syntax node.\n          while (next_state.depth > 0 && next_state_top->done) {\n            next_state.depth--;\n            next_state_top = analysis_state__top(&next_state);\n          }\n\n          // If this hypothetical child did match the current step of the query pattern,\n          // then advance to the next step at the current depth. This involves skipping\n          // over any descendant steps of the current child.\n          const QueryStep *next_step = step;\n          if (does_match) {\n            for (;;) {\n              next_state.step_index++;\n              next_step = array_get(&self->steps, next_state.step_index);\n              if (\n                next_step->depth == PATTERN_DONE_MARKER ||\n                next_step->depth <= step->depth\n              ) break;\n            }\n          } else if (successor.state == parse_state) {\n            continue;\n          }\n\n          for (;;) {\n            // Skip pass-through states. Although these states have alternatives, they are only\n            // used to implement repetitions, and query analysis does not need to process\n            // repetitions in order to determine whether steps are possible and definite.\n            if (next_step->is_pass_through) {\n              next_state.step_index++;\n              next_step++;\n              continue;\n            }\n\n            // If the pattern is finished or hypothetical parent node is complete, then\n            // record that matching can terminate at this step of the pattern. Otherwise,\n            // add this state to the list of states to process on the next iteration.\n            if (!next_step->is_dead_end) {\n              bool did_finish_pattern = array_get(&self->steps, next_state.step_index)->depth != step->depth;\n              if (did_finish_pattern) {\n                array_insert_sorted_by(&analysis->finished_parent_symbols, , state->root_symbol);\n              } else if (next_state.depth == 0) {\n                array_insert_sorted_by(&analysis->final_step_indices, , next_state.step_index);\n              } else {\n                analysis_state_set__insert_sorted(&analysis->next_states, &analysis->state_pool, &next_state);\n              }\n            }\n\n            // If the state has advanced to a step with an alternative step, then add another state\n            // at that alternative step. This process is simpler than the process of actually matching a\n            // pattern during query execution, because for the purposes of query analysis, there is no\n            // need to process repetitions.\n            if (\n              does_match &&\n              next_step->alternative_index != NONE &&\n              next_step->alternative_index > next_state.step_index\n            ) {\n              next_state.step_index = next_step->alternative_index;\n              next_step = array_get(&self->steps, next_state.step_index);\n            } else {\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    AnalysisStateSet _states = analysis->states;\n    analysis->states = analysis->next_states;\n    analysis->next_states = _states;\n  }\n}\n\nstatic bool ts_query__analyze_patterns(TSQuery *self, unsigned *error_offset) {\n  Array(uint16_t) non_rooted_pattern_start_steps = array_new();\n  for (unsigned i = 0; i < self->pattern_map.size; i++) {\n    PatternEntry *pattern = array_get(&self->pattern_map, i);\n    if (!pattern->is_rooted) {\n      QueryStep *step = array_get(&self->steps, pattern->step_index);\n      if (step->symbol != WILDCARD_SYMBOL) {\n        array_push(&non_rooted_pattern_start_steps, i);\n      }\n    }\n  }\n\n  // Walk forward through all of the steps in the query, computing some\n  // basic information about each step. Mark all of the steps that contain\n  // captures, and record the indices of all of the steps that have child steps.\n  Array(uint32_t) parent_step_indices = array_new();\n  for (unsigned i = 0; i < self->steps.size; i++) {\n    QueryStep *step = array_get(&self->steps, i);\n    if (step->depth == PATTERN_DONE_MARKER) {\n      step->parent_pattern_guaranteed = true;\n      step->root_pattern_guaranteed = true;\n      continue;\n    }\n\n    bool has_children = false;\n    bool is_wildcard = step->symbol == WILDCARD_SYMBOL;\n    step->contains_captures = step->capture_ids[0] != NONE;\n    for (unsigned j = i + 1; j < self->steps.size; j++) {\n      QueryStep *next_step = array_get(&self->steps, j);\n      if (\n        next_step->depth == PATTERN_DONE_MARKER ||\n        next_step->depth <= step->depth\n      ) break;\n      if (next_step->capture_ids[0] != NONE) {\n        step->contains_captures = true;\n      }\n      if (!is_wildcard) {\n        next_step->root_pattern_guaranteed = true;\n        next_step->parent_pattern_guaranteed = true;\n      }\n      has_children = true;\n    }\n\n    if (has_children && !is_wildcard) {\n      array_push(&parent_step_indices, i);\n    }\n  }\n\n  // For every parent symbol in the query, initialize an 'analysis subgraph'.\n  // This subgraph lists all of the states in the parse table that are directly\n  // involved in building subtrees for this symbol.\n  //\n  // In addition to the parent symbols in the query, construct subgraphs for all\n  // of the hidden symbols in the grammar, because these might occur within\n  // one of the parent nodes, such that their children appear to belong to the\n  // parent.\n  AnalysisSubgraphArray subgraphs = array_new();\n  for (unsigned i = 0; i < parent_step_indices.size; i++) {\n    uint32_t parent_step_index = *array_get(&parent_step_indices, i);\n    TSSymbol parent_symbol = array_get(&self->steps, parent_step_index)->symbol;\n    AnalysisSubgraph subgraph = { .symbol = parent_symbol };\n    array_insert_sorted_by(&subgraphs, .symbol, subgraph);\n  }\n  for (TSSymbol sym = (uint16_t)self->language->token_count; sym < (uint16_t)self->language->symbol_count; sym++) {\n    if (!ts_language_symbol_metadata(self->language, sym).visible) {\n      AnalysisSubgraph subgraph = { .symbol = sym };\n      array_insert_sorted_by(&subgraphs, .symbol, subgraph);\n    }\n  }\n\n  // Scan the parse table to find the data needed to populate these subgraphs.\n  // Collect three things during this scan:\n  //   1) All of the parse states where one of these symbols can start.\n  //   2) All of the parse states where one of these symbols can end, along\n  //      with information about the node that would be created.\n  //   3) A list of predecessor states for each state.\n  StatePredecessorMap predecessor_map = state_predecessor_map_new(self->language);\n  for (TSStateId state = 1; state < (uint16_t)self->language->state_count; state++) {\n    unsigned subgraph_index, exists;\n    LookaheadIterator lookahead_iterator = ts_language_lookaheads(self->language, state);\n    while (ts_lookahead_iterator__next(&lookahead_iterator)) {\n      if (lookahead_iterator.action_count) {\n        for (unsigned i = 0; i < lookahead_iterator.action_count; i++) {\n          const TSParseAction *action = &lookahead_iterator.actions[i];\n          if (action->type == TSParseActionTypeReduce) {\n            const TSSymbol *aliases, *aliases_end;\n            ts_language_aliases_for_symbol(\n              self->language,\n              action->reduce.symbol,\n              &aliases,\n              &aliases_end\n            );\n            for (const TSSymbol *symbol = aliases; symbol < aliases_end; symbol++) {\n              array_search_sorted_by(\n                &subgraphs,\n                .symbol,\n                *symbol,\n                &subgraph_index,\n                &exists\n              );\n              if (exists) {\n                AnalysisSubgraph *subgraph = array_get(&subgraphs, subgraph_index);\n                if (subgraph->nodes.size == 0 || array_back(&subgraph->nodes)->state != state) {\n                  array_push(&subgraph->nodes, ((AnalysisSubgraphNode) {\n                    .state = state,\n                    .production_id = action->reduce.production_id,\n                    .child_index = action->reduce.child_count,\n                    .done = true,\n                  }));\n                }\n              }\n            }\n          } else if (action->type == TSParseActionTypeShift && !action->shift.extra) {\n            TSStateId next_state = action->shift.state;\n            state_predecessor_map_add(&predecessor_map, next_state, state);\n          }\n        }\n      } else if (lookahead_iterator.next_state != 0) {\n        if (lookahead_iterator.next_state != state) {\n          state_predecessor_map_add(&predecessor_map, lookahead_iterator.next_state, state);\n        }\n        if (ts_language_state_is_primary(self->language, state)) {\n          const TSSymbol *aliases, *aliases_end;\n          ts_language_aliases_for_symbol(\n            self->language,\n            lookahead_iterator.symbol,\n            &aliases,\n            &aliases_end\n          );\n          for (const TSSymbol *symbol = aliases; symbol < aliases_end; symbol++) {\n            array_search_sorted_by(\n              &subgraphs,\n              .symbol,\n              *symbol,\n              &subgraph_index,\n              &exists\n            );\n            if (exists) {\n              AnalysisSubgraph *subgraph = array_get(&subgraphs, subgraph_index);\n              if (\n                subgraph->start_states.size == 0 ||\n                *array_back(&subgraph->start_states) != state\n              )\n              array_push(&subgraph->start_states, state);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // For each subgraph, compute the preceding states by walking backward\n  // from the end states using the predecessor map.\n  Array(AnalysisSubgraphNode) next_nodes = array_new();\n  for (unsigned i = 0; i < subgraphs.size; i++) {\n    AnalysisSubgraph *subgraph = array_get(&subgraphs, i);\n    if (subgraph->nodes.size == 0) {\n      array_delete(&subgraph->start_states);\n      array_erase(&subgraphs, i);\n      i--;\n      continue;\n    }\n    array_assign(&next_nodes, &subgraph->nodes);\n    while (next_nodes.size > 0) {\n      AnalysisSubgraphNode node = array_pop(&next_nodes);\n      if (node.child_index > 1) {\n        unsigned predecessor_count;\n        const TSStateId *predecessors = state_predecessor_map_get(\n          &predecessor_map,\n          node.state,\n          &predecessor_count\n        );\n        for (unsigned j = 0; j < predecessor_count; j++) {\n          AnalysisSubgraphNode predecessor_node = {\n            .state = predecessors[j],\n            .child_index = node.child_index - 1,\n            .production_id = node.production_id,\n            .done = false,\n          };\n          unsigned index, exists;\n          array_search_sorted_with(\n            &subgraph->nodes, analysis_subgraph_node__compare, &predecessor_node,\n            &index, &exists\n          );\n          if (!exists) {\n            array_insert(&subgraph->nodes, index, predecessor_node);\n            array_push(&next_nodes, predecessor_node);\n          }\n        }\n      }\n    }\n  }\n\n  #ifdef DEBUG_ANALYZE_QUERY\n    printf(\"\\nSubgraphs:\\n\");\n    for (unsigned i = 0; i < subgraphs.size; i++) {\n      AnalysisSubgraph *subgraph = array_get(&subgraphs, i);\n      printf(\"  %u, %s:\\n\", subgraph->symbol, ts_language_symbol_name(self->language, subgraph->symbol));\n      for (unsigned j = 0; j < subgraph->start_states.size; j++) {\n        printf(\n          \"    {state: %u}\\n\",\n          *array_get(&subgraph->start_states, j)\n        );\n      }\n      for (unsigned j = 0; j < subgraph->nodes.size; j++) {\n        AnalysisSubgraphNode *node = array_get(&subgraph->nodes, j);\n        printf(\n          \"    {state: %u, child_index: %u, production_id: %u, done: %d}\\n\",\n          node->state, node->child_index, node->production_id, node->done\n        );\n      }\n      printf(\"\\n\");\n    }\n  #endif\n\n  // For each non-terminal pattern, determine if the pattern can successfully match,\n  // and identify all of the possible children within the pattern where matching could fail.\n  bool all_patterns_are_valid = true;\n  QueryAnalysis analysis = query_analysis__new();\n  for (unsigned i = 0; i < parent_step_indices.size; i++) {\n    uint16_t parent_step_index = *array_get(&parent_step_indices, i);\n    uint16_t parent_depth = array_get(&self->steps, parent_step_index)->depth;\n    TSSymbol parent_symbol = array_get(&self->steps, parent_step_index)->symbol;\n    if (parent_symbol == ts_builtin_sym_error) continue;\n\n    // Find the subgraph that corresponds to this pattern's root symbol. If the pattern's\n    // root symbol is a terminal, then return an error.\n    unsigned subgraph_index, exists;\n    array_search_sorted_by(&subgraphs, .symbol, parent_symbol, &subgraph_index, &exists);\n    if (!exists) {\n      unsigned first_child_step_index = parent_step_index + 1;\n      uint32_t j, child_exists;\n      array_search_sorted_by(&self->step_offsets, .step_index, first_child_step_index, &j, &child_exists);\n      ts_assert(child_exists);\n      *error_offset = array_get(&self->step_offsets, j)->byte_offset;\n      all_patterns_are_valid = false;\n      break;\n    }\n\n    // Initialize an analysis state at every parse state in the table where\n    // this parent symbol can occur.\n    AnalysisSubgraph *subgraph = array_get(&subgraphs, subgraph_index);\n    analysis_state_set__clear(&analysis.states, &analysis.state_pool);\n    analysis_state_set__clear(&analysis.deeper_states, &analysis.state_pool);\n    for (unsigned j = 0; j < subgraph->start_states.size; j++) {\n      TSStateId parse_state = *array_get(&subgraph->start_states, j);\n      analysis_state_set__push(&analysis.states, &analysis.state_pool, &((AnalysisState) {\n        .step_index = parent_step_index + 1,\n        .stack = {\n          [0] = {\n            .parse_state = parse_state,\n            .parent_symbol = parent_symbol,\n            .child_index = 0,\n            .field_id = 0,\n            .done = false,\n          },\n        },\n        .depth = 1,\n        .root_symbol = parent_symbol,\n      }));\n    }\n\n    #ifdef DEBUG_ANALYZE_QUERY\n      printf(\n        \"\\nWalk states for %s:\\n\",\n        ts_language_symbol_name(self->language, (*array_get(&analysis.states, 0))->stack[0].parent_symbol)\n      );\n    #endif\n\n    analysis.did_abort = false;\n    ts_query__perform_analysis(self, &subgraphs, &analysis);\n\n    // If this pattern could not be fully analyzed, then every step should\n    // be considered fallible.\n    if (analysis.did_abort) {\n      for (unsigned j = parent_step_index + 1; j < self->steps.size; j++) {\n        QueryStep *step = array_get(&self->steps, j);\n        if (\n          step->depth <= parent_depth ||\n          step->depth == PATTERN_DONE_MARKER\n        ) break;\n        if (!step->is_dead_end) {\n          step->parent_pattern_guaranteed = false;\n          step->root_pattern_guaranteed = false;\n        }\n      }\n      continue;\n    }\n\n    // If this pattern cannot match, store the pattern index so that it can be\n    // returned to the caller.\n    if (analysis.finished_parent_symbols.size == 0) {\n      ts_assert(analysis.final_step_indices.size > 0);\n      uint16_t impossible_step_index = *array_back(&analysis.final_step_indices);\n      uint32_t j, impossible_exists;\n      array_search_sorted_by(&self->step_offsets, .step_index, impossible_step_index, &j, &impossible_exists);\n      if (j >= self->step_offsets.size) j = self->step_offsets.size - 1;\n      *error_offset = array_get(&self->step_offsets, j)->byte_offset;\n      all_patterns_are_valid = false;\n      break;\n    }\n\n    // Mark as fallible any step where a match terminated.\n    // Later, this property will be propagated to all of the step's predecessors.\n    for (unsigned j = 0; j < analysis.final_step_indices.size; j++) {\n      uint32_t final_step_index = *array_get(&analysis.final_step_indices, j);\n      QueryStep *step = array_get(&self->steps, final_step_index);\n      if (\n        step->depth != PATTERN_DONE_MARKER &&\n        step->depth > parent_depth &&\n        !step->is_dead_end\n      ) {\n        step->parent_pattern_guaranteed = false;\n        step->root_pattern_guaranteed = false;\n      }\n    }\n  }\n\n  // Mark as indefinite any step with captures that are used in predicates.\n  Array(uint16_t) predicate_capture_ids = array_new();\n  for (unsigned i = 0; i < self->patterns.size; i++) {\n    QueryPattern *pattern = array_get(&self->patterns, i);\n\n    // Gather all of the captures that are used in predicates for this pattern.\n    array_clear(&predicate_capture_ids);\n    for (\n      unsigned start = pattern->predicate_steps.offset,\n      end = start + pattern->predicate_steps.length,\n      j = start; j < end; j++\n    ) {\n      TSQueryPredicateStep *step = array_get(&self->predicate_steps, j);\n      if (step->type == TSQueryPredicateStepTypeCapture) {\n        uint16_t value_id = step->value_id;\n        array_insert_sorted_by(&predicate_capture_ids, , value_id);\n      }\n    }\n\n    // Find all of the steps that have these captures.\n    for (\n      unsigned start = pattern->steps.offset,\n      end = start + pattern->steps.length,\n      j = start; j < end; j++\n    ) {\n      QueryStep *step = array_get(&self->steps, j);\n      for (unsigned k = 0; k < MAX_STEP_CAPTURE_COUNT; k++) {\n        uint16_t capture_id = step->capture_ids[k];\n        if (capture_id == NONE) break;\n        unsigned index, exists;\n        array_search_sorted_by(&predicate_capture_ids, , capture_id, &index, &exists);\n        if (exists) {\n          step->root_pattern_guaranteed = false;\n          break;\n        }\n      }\n    }\n  }\n\n  // Propagate fallibility. If a pattern is fallible at a given step, then it is\n  // fallible at all of its preceding steps.\n  bool done = self->steps.size == 0;\n  while (!done) {\n    done = true;\n    for (unsigned i = self->steps.size - 1; i > 0; i--) {\n      QueryStep *step = array_get(&self->steps, i);\n      if (step->depth == PATTERN_DONE_MARKER) continue;\n\n      // Determine if this step is definite or has definite alternatives.\n      bool parent_pattern_guaranteed = false;\n      for (;;) {\n        if (step->root_pattern_guaranteed) {\n          parent_pattern_guaranteed = true;\n          break;\n        }\n        if (step->alternative_index == NONE || step->alternative_index < i) {\n          break;\n        }\n        step = array_get(&self->steps, step->alternative_index);\n      }\n\n      // If not, mark its predecessor as indefinite.\n      if (!parent_pattern_guaranteed) {\n        QueryStep *prev_step = array_get(&self->steps, i - 1);\n        if (\n          !prev_step->is_dead_end &&\n          prev_step->depth != PATTERN_DONE_MARKER &&\n          prev_step->root_pattern_guaranteed\n        ) {\n          prev_step->root_pattern_guaranteed = false;\n          done = false;\n        }\n      }\n    }\n  }\n\n  #ifdef DEBUG_ANALYZE_QUERY\n    printf(\"Steps:\\n\");\n    for (unsigned i = 0; i < self->steps.size; i++) {\n      QueryStep *step = array_get(&self->steps, i);\n      if (step->depth == PATTERN_DONE_MARKER) {\n        printf(\"  %u: DONE\\n\", i);\n      } else {\n        printf(\n          \"  %u: {symbol: %s, field: %s, depth: %u, parent_pattern_guaranteed: %d, root_pattern_guaranteed: %d}\\n\",\n          i,\n          (step->symbol == WILDCARD_SYMBOL)\n            ? \"ANY\"\n            : ts_language_symbol_name(self->language, step->symbol),\n          (step->field ? ts_language_field_name_for_id(self->language, step->field) : \"-\"),\n          step->depth,\n          step->parent_pattern_guaranteed,\n          step->root_pattern_guaranteed\n        );\n      }\n    }\n  #endif\n\n  // Determine which repetition symbols in this language have the possibility\n  // of matching non-rooted patterns in this query. These repetition symbols\n  // prevent certain optimizations with range restrictions.\n  analysis.did_abort = false;\n  for (uint32_t i = 0; i < non_rooted_pattern_start_steps.size; i++) {\n    uint16_t pattern_entry_index = *array_get(&non_rooted_pattern_start_steps, i);\n    PatternEntry *pattern_entry = array_get(&self->pattern_map, pattern_entry_index);\n\n    analysis_state_set__clear(&analysis.states, &analysis.state_pool);\n    analysis_state_set__clear(&analysis.deeper_states, &analysis.state_pool);\n    for (unsigned j = 0; j < subgraphs.size; j++) {\n      AnalysisSubgraph *subgraph = array_get(&subgraphs, j);\n      TSSymbolMetadata metadata = ts_language_symbol_metadata(self->language, subgraph->symbol);\n      if (metadata.visible || metadata.named) continue;\n\n      for (uint32_t k = 0; k < subgraph->start_states.size; k++) {\n        TSStateId parse_state = *array_get(&subgraph->start_states, k);\n        analysis_state_set__push(&analysis.states, &analysis.state_pool, &((AnalysisState) {\n          .step_index = pattern_entry->step_index,\n          .stack = {\n            [0] = {\n              .parse_state = parse_state,\n              .parent_symbol = subgraph->symbol,\n              .child_index = 0,\n              .field_id = 0,\n              .done = false,\n            },\n          },\n          .root_symbol = subgraph->symbol,\n          .depth = 1,\n        }));\n      }\n    }\n\n    #ifdef DEBUG_ANALYZE_QUERY\n      printf(\"\\nWalk states for rootless pattern step %u:\\n\", pattern_entry->step_index);\n    #endif\n\n    ts_query__perform_analysis(\n      self,\n      &subgraphs,\n      &analysis\n    );\n\n    if (analysis.finished_parent_symbols.size > 0) {\n      array_get(&self->patterns, pattern_entry->pattern_index)->is_non_local = true;\n    }\n\n    for (unsigned k = 0; k < analysis.finished_parent_symbols.size; k++) {\n      TSSymbol symbol = *array_get(&analysis.finished_parent_symbols, k);\n      array_insert_sorted_by(&self->repeat_symbols_with_rootless_patterns, , symbol);\n    }\n  }\n\n  #ifdef DEBUG_ANALYZE_QUERY\n    if (self->repeat_symbols_with_rootless_patterns.size > 0) {\n      printf(\"\\nRepetition symbols with rootless patterns:\\n\");\n      printf(\"aborted analysis: %d\\n\", analysis.did_abort);\n      for (unsigned i = 0; i < self->repeat_symbols_with_rootless_patterns.size; i++) {\n        TSSymbol symbol = *array_get(&self->repeat_symbols_with_rootless_patterns, i);\n        printf(\"  %u, %s\\n\", symbol, ts_language_symbol_name(self->language, symbol));\n      }\n      printf(\"\\n\");\n    }\n  #endif\n\n  // Cleanup\n  for (unsigned i = 0; i < subgraphs.size; i++) {\n    array_delete(&array_get(&subgraphs, i)->start_states);\n    array_delete(&array_get(&subgraphs, i)->nodes);\n  }\n  array_delete(&subgraphs);\n  query_analysis__delete(&analysis);\n  array_delete(&next_nodes);\n  array_delete(&non_rooted_pattern_start_steps);\n  array_delete(&parent_step_indices);\n  array_delete(&predicate_capture_ids);\n  state_predecessor_map_delete(&predecessor_map);\n\n  return all_patterns_are_valid;\n}\n\nstatic void ts_query__add_negated_fields(\n  TSQuery *self,\n  uint16_t step_index,\n  TSFieldId *field_ids,\n  uint16_t field_count\n) {\n  QueryStep *step = array_get(&self->steps, step_index);\n\n  // The negated field array stores a list of field lists, separated by zeros.\n  // Try to find the start index of an existing list that matches this new list.\n  bool failed_match = false;\n  unsigned match_count = 0;\n  unsigned start_i = 0;\n  for (unsigned i = 0; i < self->negated_fields.size; i++) {\n    TSFieldId existing_field_id = *array_get(&self->negated_fields, i);\n\n    // At each zero value, terminate the match attempt. If we've exactly\n    // matched the new field list, then reuse this index. Otherwise,\n    // start over the matching process.\n    if (existing_field_id == 0) {\n      if (match_count == field_count) {\n        step->negated_field_list_id = start_i;\n        return;\n      } else {\n        start_i = i + 1;\n        match_count = 0;\n        failed_match = false;\n      }\n    }\n\n    // If the existing list matches our new list so far, then advance\n    // to the next element of the new list.\n    else if (\n      match_count < field_count &&\n      existing_field_id == field_ids[match_count] &&\n      !failed_match\n    ) {\n      match_count++;\n    }\n\n    // Otherwise, this existing list has failed to match.\n    else {\n      match_count = 0;\n      failed_match = true;\n    }\n  }\n\n  step->negated_field_list_id = self->negated_fields.size;\n  array_extend(&self->negated_fields, field_count, field_ids);\n  array_push(&self->negated_fields, 0);\n}\n\nstatic TSQueryError ts_query__parse_string_literal(\n  TSQuery *self,\n  Stream *stream\n) {\n  const char *string_start = stream->input;\n  if (stream->next != '\"') return TSQueryErrorSyntax;\n  stream_advance(stream);\n  const char *prev_position = stream->input;\n\n  bool is_escaped = false;\n  array_clear(&self->string_buffer);\n  for (;;) {\n    if (is_escaped) {\n      is_escaped = false;\n      switch (stream->next) {\n        case 'n':\n          array_push(&self->string_buffer, '\\n');\n          break;\n        case 'r':\n          array_push(&self->string_buffer, '\\r');\n          break;\n        case 't':\n          array_push(&self->string_buffer, '\\t');\n          break;\n        case '0':\n          array_push(&self->string_buffer, '\\0');\n          break;\n        default:\n          array_extend(&self->string_buffer, stream->next_size, stream->input);\n          break;\n      }\n      prev_position = stream->input + stream->next_size;\n    } else {\n      if (stream->next == '\\\\') {\n        array_extend(&self->string_buffer, (uint32_t)(stream->input - prev_position), prev_position);\n        prev_position = stream->input + 1;\n        is_escaped = true;\n      } else if (stream->next == '\"') {\n        array_extend(&self->string_buffer, (uint32_t)(stream->input - prev_position), prev_position);\n        stream_advance(stream);\n        return TSQueryErrorNone;\n      } else if (stream->next == '\\n') {\n        stream_reset(stream, string_start);\n        return TSQueryErrorSyntax;\n      }\n    }\n    if (!stream_advance(stream)) {\n      stream_reset(stream, string_start);\n      return TSQueryErrorSyntax;\n    }\n  }\n}\n\n// Parse a single predicate associated with a pattern, adding it to the\n// query's internal `predicate_steps` array. Predicates are arbitrary\n// S-expressions associated with a pattern which are meant to be handled at\n// a higher level of abstraction, such as the Rust/JavaScript bindings. They\n// can contain '@'-prefixed capture names, double-quoted strings, and bare\n// symbols, which also represent strings.\nstatic TSQueryError ts_query__parse_predicate(\n  TSQuery *self,\n  Stream *stream\n) {\n  if (!stream_is_ident_start(stream)) return TSQueryErrorSyntax;\n  const char *predicate_name = stream->input;\n  stream_scan_identifier(stream);\n  if (stream->next != '?' && stream->next != '!') {\n    return TSQueryErrorSyntax;\n  }\n  stream_advance(stream);\n  uint32_t length = (uint32_t)(stream->input - predicate_name);\n  uint16_t id = symbol_table_insert_name(\n    &self->predicate_values,\n    predicate_name,\n    length\n  );\n  array_push(&self->predicate_steps, ((TSQueryPredicateStep) {\n    .type = TSQueryPredicateStepTypeString,\n    .value_id = id,\n  }));\n  stream_skip_whitespace(stream);\n\n  for (;;) {\n    if (stream->next == ')') {\n      stream_advance(stream);\n      stream_skip_whitespace(stream);\n      array_push(&self->predicate_steps, ((TSQueryPredicateStep) {\n        .type = TSQueryPredicateStepTypeDone,\n        .value_id = 0,\n      }));\n      break;\n    }\n\n    // Parse an '@'-prefixed capture name\n    else if (stream->next == '@') {\n      stream_advance(stream);\n\n      // Parse the capture name\n      if (!stream_is_ident_start(stream)) return TSQueryErrorSyntax;\n      const char *capture_name = stream->input;\n      stream_scan_identifier(stream);\n      uint32_t capture_length = (uint32_t)(stream->input - capture_name);\n\n      // Add the capture id to the first step of the pattern\n      int capture_id = symbol_table_id_for_name(\n        &self->captures,\n        capture_name,\n        capture_length\n      );\n      if (capture_id == -1) {\n        stream_reset(stream, capture_name);\n        return TSQueryErrorCapture;\n      }\n\n      array_push(&self->predicate_steps, ((TSQueryPredicateStep) {\n        .type = TSQueryPredicateStepTypeCapture,\n        .value_id = capture_id,\n      }));\n    }\n\n    // Parse a string literal\n    else if (stream->next == '\"') {\n      TSQueryError e = ts_query__parse_string_literal(self, stream);\n      if (e) return e;\n      uint16_t query_id = symbol_table_insert_name(\n        &self->predicate_values,\n        self->string_buffer.contents,\n        self->string_buffer.size\n      );\n      array_push(&self->predicate_steps, ((TSQueryPredicateStep) {\n        .type = TSQueryPredicateStepTypeString,\n        .value_id = query_id,\n      }));\n    }\n\n    // Parse a bare symbol\n    else if (stream_is_ident_start(stream)) {\n      const char *symbol_start = stream->input;\n      stream_scan_identifier(stream);\n      uint32_t symbol_length = (uint32_t)(stream->input - symbol_start);\n      uint16_t query_id = symbol_table_insert_name(\n        &self->predicate_values,\n        symbol_start,\n        symbol_length\n      );\n      array_push(&self->predicate_steps, ((TSQueryPredicateStep) {\n        .type = TSQueryPredicateStepTypeString,\n        .value_id = query_id,\n      }));\n    }\n\n    else {\n      return TSQueryErrorSyntax;\n    }\n\n    stream_skip_whitespace(stream);\n  }\n\n  return 0;\n}\n\n// Read one S-expression pattern from the stream, and incorporate it into\n// the query's internal state machine representation. For nested patterns,\n// this function calls itself recursively.\n//\n// The caller is responsible for passing in a dedicated CaptureQuantifiers.\n// These should not be shared between different calls to ts_query__parse_pattern!\nstatic TSQueryError ts_query__parse_pattern(\n  TSQuery *self,\n  Stream *stream,\n  uint32_t depth,\n  bool is_immediate,\n  CaptureQuantifiers *capture_quantifiers\n) {\n  if (stream->next == 0) return TSQueryErrorSyntax;\n  if (stream->next == ')' || stream->next == ']') return PARENT_DONE;\n\n  const uint32_t starting_step_index = self->steps.size;\n\n  // Store the byte offset of each step in the query.\n  if (\n    self->step_offsets.size == 0 ||\n    array_back(&self->step_offsets)->step_index != starting_step_index\n  ) {\n    array_push(&self->step_offsets, ((StepOffset) {\n      .step_index = starting_step_index,\n      .byte_offset = stream_offset(stream),\n    }));\n  }\n\n  // An open bracket is the start of an alternation.\n  if (stream->next == '[') {\n    stream_advance(stream);\n    stream_skip_whitespace(stream);\n\n    // Parse each branch, and add a placeholder step in between the branches.\n    Array(uint32_t) branch_step_indices = array_new();\n    CaptureQuantifiers branch_capture_quantifiers = capture_quantifiers_new();\n    for (;;) {\n      uint32_t start_index = self->steps.size;\n      TSQueryError e = ts_query__parse_pattern(\n        self,\n        stream,\n        depth,\n        is_immediate,\n        &branch_capture_quantifiers\n      );\n\n      if (e == PARENT_DONE) {\n        if (stream->next == ']' && branch_step_indices.size > 0) {\n          stream_advance(stream);\n          break;\n        }\n        e = TSQueryErrorSyntax;\n      }\n      if (e) {\n        capture_quantifiers_delete(&branch_capture_quantifiers);\n        array_delete(&branch_step_indices);\n        return e;\n      }\n\n      if (start_index == starting_step_index) {\n        capture_quantifiers_replace(capture_quantifiers, &branch_capture_quantifiers);\n      } else {\n        capture_quantifiers_join_all(capture_quantifiers, &branch_capture_quantifiers);\n      }\n\n      array_push(&branch_step_indices, start_index);\n      array_push(&self->steps, query_step__new(0, depth, false));\n      capture_quantifiers_clear(&branch_capture_quantifiers);\n    }\n    (void)array_pop(&self->steps);\n\n    // For all of the branches except for the last one, add the subsequent branch as an\n    // alternative, and link the end of the branch to the current end of the steps.\n    for (unsigned i = 0; i < branch_step_indices.size - 1; i++) {\n      uint32_t step_index = *array_get(&branch_step_indices, i);\n      uint32_t next_step_index = *array_get(&branch_step_indices, i + 1);\n      QueryStep *start_step = array_get(&self->steps, step_index);\n      QueryStep *end_step = array_get(&self->steps, next_step_index - 1);\n      start_step->alternative_index = next_step_index;\n      end_step->alternative_index = self->steps.size;\n      end_step->is_dead_end = true;\n    }\n\n    capture_quantifiers_delete(&branch_capture_quantifiers);\n    array_delete(&branch_step_indices);\n  }\n\n  // An open parenthesis can be the start of three possible constructs:\n  // * A grouped sequence\n  // * A predicate\n  // * A named node\n  else if (stream->next == '(') {\n    stream_advance(stream);\n    stream_skip_whitespace(stream);\n\n    // If this parenthesis is followed by a node, then it represents a grouped sequence.\n    if (stream->next == '(' || stream->next == '\"' || stream->next == '[') {\n      bool child_is_immediate = is_immediate;\n      CaptureQuantifiers child_capture_quantifiers = capture_quantifiers_new();\n      for (;;) {\n        if (stream->next == '.') {\n          child_is_immediate = true;\n          stream_advance(stream);\n          stream_skip_whitespace(stream);\n        }\n        TSQueryError e = ts_query__parse_pattern(\n          self,\n          stream,\n          depth,\n          child_is_immediate,\n          &child_capture_quantifiers\n        );\n        if (e == PARENT_DONE) {\n          if (stream->next == ')') {\n            stream_advance(stream);\n            break;\n          }\n          e = TSQueryErrorSyntax;\n        }\n        if (e) {\n          capture_quantifiers_delete(&child_capture_quantifiers);\n          return e;\n        }\n\n        capture_quantifiers_add_all(capture_quantifiers, &child_capture_quantifiers);\n        capture_quantifiers_clear(&child_capture_quantifiers);\n        child_is_immediate = false;\n      }\n\n      capture_quantifiers_delete(&child_capture_quantifiers);\n    }\n\n    // A dot/pound character indicates the start of a predicate.\n    else if (stream->next == '.' || stream->next == '#') {\n      stream_advance(stream);\n      return ts_query__parse_predicate(self, stream);\n    }\n\n    // Otherwise, this parenthesis is the start of a named node.\n    else {\n      TSSymbol symbol;\n      bool is_missing = false;\n      const char *node_name = stream->input;\n\n      // Parse a normal node name\n      if (stream_is_ident_start(stream)) {\n        stream_scan_identifier(stream);\n        uint32_t length = (uint32_t)(stream->input - node_name);\n\n        // Parse the wildcard symbol\n        if (length == 1 && node_name[0] == '_') {\n          symbol = WILDCARD_SYMBOL;\n        } else if (!strncmp(node_name, \"MISSING\", length)) {\n          is_missing = true;\n          stream_skip_whitespace(stream);\n\n          if (stream_is_ident_start(stream)) {\n            const char *missing_node_name = stream->input;\n            stream_scan_identifier(stream);\n            uint32_t missing_node_length = (uint32_t)(stream->input - missing_node_name);\n            symbol = ts_language_symbol_for_name(\n              self->language,\n              missing_node_name,\n              missing_node_length,\n              true\n            );\n            if (!symbol) {\n              stream_reset(stream, missing_node_name);\n              return TSQueryErrorNodeType;\n            }\n          }\n\n          else if (stream->next == '\"') {\n            const char *string_start = stream->input;\n            TSQueryError e = ts_query__parse_string_literal(self, stream);\n            if (e) return e;\n\n            symbol = ts_language_symbol_for_name(\n              self->language,\n              self->string_buffer.contents,\n              self->string_buffer.size,\n              false\n            );\n            if (!symbol) {\n              stream_reset(stream, string_start + 1);\n              return TSQueryErrorNodeType;\n            }\n          }\n\n          else if (stream->next == ')') {\n            symbol = WILDCARD_SYMBOL;\n          }\n\n          else {\n            stream_reset(stream, stream->input);\n            return TSQueryErrorSyntax;\n          }\n        }\n\n        else {\n          symbol = ts_language_symbol_for_name(\n            self->language,\n            node_name,\n            length,\n            true\n          );\n          if (!symbol) {\n            stream_reset(stream, node_name);\n            return TSQueryErrorNodeType;\n          }\n        }\n      } else {\n        return TSQueryErrorSyntax;\n      }\n\n      // Add a step for the node.\n      array_push(&self->steps, query_step__new(symbol, depth, is_immediate));\n      QueryStep *step = array_back(&self->steps);\n      if (ts_language_symbol_metadata(self->language, symbol).supertype) {\n        step->supertype_symbol = step->symbol;\n        step->symbol = WILDCARD_SYMBOL;\n      }\n      if (is_missing) {\n        step->is_missing = true;\n      }\n      if (symbol == WILDCARD_SYMBOL) {\n        step->is_named = true;\n      }\n\n      stream_skip_whitespace(stream);\n\n      if (stream->next == '/') {\n        if (!step->supertype_symbol) {\n          stream_reset(stream, node_name - 1); // reset to the start of the node\n          return TSQueryErrorStructure;\n        }\n\n        stream_advance(stream);\n        if (!stream_is_ident_start(stream)) {\n          return TSQueryErrorSyntax;\n        }\n\n        const char *subtype_node_name = stream->input;\n        stream_scan_identifier(stream);\n        uint32_t length = (uint32_t)(stream->input - subtype_node_name);\n\n        step->symbol = ts_language_symbol_for_name(\n          self->language,\n          subtype_node_name,\n          length,\n          true\n        );\n        if (!step->symbol) {\n          stream_reset(stream, subtype_node_name);\n          return TSQueryErrorNodeType;\n        }\n\n        // Get all the possible subtypes for the given supertype,\n        // and check if the given subtype is valid.\n        if (self->language->abi_version >= LANGUAGE_VERSION_WITH_RESERVED_WORDS) {\n          uint32_t subtype_length;\n          const TSSymbol *subtypes = ts_language_subtypes(\n            self->language,\n            step->supertype_symbol,\n            &subtype_length\n          );\n\n          bool subtype_is_valid = false;\n          for (uint32_t i = 0; i < subtype_length; i++) {\n            if (subtypes[i] == step->symbol) {\n              subtype_is_valid = true;\n              break;\n            }\n          }\n\n          // This subtype is not valid for the given supertype.\n          if (!subtype_is_valid) {\n            stream_reset(stream, node_name - 1); // reset to the start of the node\n            return TSQueryErrorStructure;\n          }\n        }\n\n        stream_skip_whitespace(stream);\n      }\n\n      // Parse the child patterns\n      bool child_is_immediate = false;\n      uint16_t last_child_step_index = 0;\n      uint16_t negated_field_count = 0;\n      TSFieldId negated_field_ids[MAX_NEGATED_FIELD_COUNT];\n      CaptureQuantifiers child_capture_quantifiers = capture_quantifiers_new();\n      for (;;) {\n        // Parse a negated field assertion\n        if (stream->next == '!') {\n          stream_advance(stream);\n          stream_skip_whitespace(stream);\n          if (!stream_is_ident_start(stream)) {\n            capture_quantifiers_delete(&child_capture_quantifiers);\n            return TSQueryErrorSyntax;\n          }\n          const char *field_name = stream->input;\n          stream_scan_identifier(stream);\n          uint32_t length = (uint32_t)(stream->input - field_name);\n          stream_skip_whitespace(stream);\n\n          TSFieldId field_id = ts_language_field_id_for_name(\n            self->language,\n            field_name,\n            length\n          );\n          if (!field_id) {\n            stream->input = field_name;\n            capture_quantifiers_delete(&child_capture_quantifiers);\n            return TSQueryErrorField;\n          }\n\n          // Keep the field ids sorted.\n          if (negated_field_count < MAX_NEGATED_FIELD_COUNT) {\n            negated_field_ids[negated_field_count] = field_id;\n            negated_field_count++;\n          }\n\n          continue;\n        }\n\n        // Parse a sibling anchor\n        if (stream->next == '.') {\n          child_is_immediate = true;\n          stream_advance(stream);\n          stream_skip_whitespace(stream);\n        }\n\n        uint16_t step_index = self->steps.size;\n        TSQueryError e = ts_query__parse_pattern(\n          self,\n          stream,\n          depth + 1,\n          child_is_immediate,\n          &child_capture_quantifiers\n        );\n        // In the event we only parsed a predicate, meaning no new steps were added,\n        // then subtract one so we're not indexing past the end of the array\n        if (step_index == self->steps.size) step_index--;\n        if (e == PARENT_DONE) {\n          if (stream->next == ')') {\n            if (child_is_immediate) {\n              if (last_child_step_index == 0) {\n                capture_quantifiers_delete(&child_capture_quantifiers);\n                return TSQueryErrorSyntax;\n              }\n              // Mark this step *and* its alternatives as the last child of the parent.\n              QueryStep *last_child_step = array_get(&self->steps, last_child_step_index);\n              last_child_step->is_last_child = true;\n              if (\n                last_child_step->alternative_index != NONE &&\n                last_child_step->alternative_index < self->steps.size\n              ) {\n                QueryStep *alternative_step = array_get(&self->steps, last_child_step->alternative_index);\n                alternative_step->is_last_child = true;\n                while (\n                  alternative_step->alternative_index != NONE &&\n                  alternative_step->alternative_index < self->steps.size\n                ) {\n                  alternative_step = array_get(&self->steps, alternative_step->alternative_index);\n                  alternative_step->is_last_child = true;\n                }\n              }\n            }\n\n            if (negated_field_count) {\n              ts_query__add_negated_fields(\n                self,\n                starting_step_index,\n                negated_field_ids,\n                negated_field_count\n              );\n            }\n\n            stream_advance(stream);\n            break;\n          }\n          e = TSQueryErrorSyntax;\n        }\n        if (e) {\n          capture_quantifiers_delete(&child_capture_quantifiers);\n          return e;\n        }\n\n        capture_quantifiers_add_all(capture_quantifiers, &child_capture_quantifiers);\n\n        last_child_step_index = step_index;\n        child_is_immediate = false;\n        capture_quantifiers_clear(&child_capture_quantifiers);\n      }\n      capture_quantifiers_delete(&child_capture_quantifiers);\n    }\n  }\n\n  // Parse a wildcard pattern\n  else if (stream->next == '_') {\n    stream_advance(stream);\n    stream_skip_whitespace(stream);\n\n    // Add a step that matches any kind of node\n    array_push(&self->steps, query_step__new(WILDCARD_SYMBOL, depth, is_immediate));\n  }\n\n  // Parse a double-quoted anonymous leaf node expression\n  else if (stream->next == '\"') {\n    const char *string_start = stream->input;\n    TSQueryError e = ts_query__parse_string_literal(self, stream);\n    if (e) return e;\n\n    // Add a step for the node\n    TSSymbol symbol = ts_language_symbol_for_name(\n      self->language,\n      self->string_buffer.contents,\n      self->string_buffer.size,\n      false\n    );\n    if (!symbol) {\n      stream_reset(stream, string_start + 1);\n      return TSQueryErrorNodeType;\n    }\n    array_push(&self->steps, query_step__new(symbol, depth, is_immediate));\n  }\n\n  // Parse a field-prefixed pattern\n  else if (stream_is_ident_start(stream)) {\n    // Parse the field name\n    const char *field_name = stream->input;\n    stream_scan_identifier(stream);\n    uint32_t length = (uint32_t)(stream->input - field_name);\n    stream_skip_whitespace(stream);\n\n    if (stream->next != ':') {\n      stream_reset(stream, field_name);\n      return TSQueryErrorSyntax;\n    }\n    stream_advance(stream);\n    stream_skip_whitespace(stream);\n\n    // Parse the pattern\n    CaptureQuantifiers field_capture_quantifiers = capture_quantifiers_new();\n    TSQueryError e = ts_query__parse_pattern(\n      self,\n      stream,\n      depth,\n      is_immediate,\n      &field_capture_quantifiers\n    );\n    if (e) {\n      capture_quantifiers_delete(&field_capture_quantifiers);\n      if (e == PARENT_DONE) e = TSQueryErrorSyntax;\n      return e;\n    }\n\n    // Add the field name to the first step of the pattern\n    TSFieldId field_id = ts_language_field_id_for_name(\n      self->language,\n      field_name,\n      length\n    );\n    if (!field_id) {\n      stream->input = field_name;\n      return TSQueryErrorField;\n    }\n\n    uint32_t step_index = starting_step_index;\n    QueryStep *step = array_get(&self->steps, step_index);\n    for (;;) {\n      step->field = field_id;\n      if (\n        step->alternative_index != NONE &&\n        step->alternative_index > step_index &&\n        step->alternative_index < self->steps.size\n      ) {\n        step_index = step->alternative_index;\n        step = array_get(&self->steps, step_index);\n      } else {\n        break;\n      }\n    }\n\n    capture_quantifiers_add_all(capture_quantifiers, &field_capture_quantifiers);\n    capture_quantifiers_delete(&field_capture_quantifiers);\n  }\n\n  else {\n    return TSQueryErrorSyntax;\n  }\n\n  stream_skip_whitespace(stream);\n\n  // Parse suffixes modifiers for this pattern\n  TSQuantifier quantifier = TSQuantifierOne;\n  for (;;) {\n    // Parse the one-or-more operator.\n    if (stream->next == '+') {\n      quantifier = quantifier_join(TSQuantifierOneOrMore, quantifier);\n\n      stream_advance(stream);\n      stream_skip_whitespace(stream);\n\n      QueryStep repeat_step = query_step__new(WILDCARD_SYMBOL, depth, false);\n      repeat_step.alternative_index = starting_step_index;\n      repeat_step.is_pass_through = true;\n      repeat_step.alternative_is_immediate = true;\n      array_push(&self->steps, repeat_step);\n    }\n\n    // Parse the zero-or-more repetition operator.\n    else if (stream->next == '*') {\n      quantifier = quantifier_join(TSQuantifierZeroOrMore, quantifier);\n\n      stream_advance(stream);\n      stream_skip_whitespace(stream);\n\n      QueryStep repeat_step = query_step__new(WILDCARD_SYMBOL, depth, false);\n      repeat_step.alternative_index = starting_step_index;\n      repeat_step.is_pass_through = true;\n      repeat_step.alternative_is_immediate = true;\n      array_push(&self->steps, repeat_step);\n\n      // Stop when `step->alternative_index` is `NONE` or it points to\n      // `repeat_step` or beyond. Note that having just been pushed,\n      // `repeat_step` occupies slot `self->steps.size - 1`.\n      QueryStep *step = array_get(&self->steps, starting_step_index);\n      while (step->alternative_index != NONE && step->alternative_index < self->steps.size - 1) {\n        step = array_get(&self->steps, step->alternative_index);\n      }\n      step->alternative_index = self->steps.size;\n    }\n\n    // Parse the optional operator.\n    else if (stream->next == '?') {\n      quantifier = quantifier_join(TSQuantifierZeroOrOne, quantifier);\n\n      stream_advance(stream);\n      stream_skip_whitespace(stream);\n\n      QueryStep *step = array_get(&self->steps, starting_step_index);\n      while (step->alternative_index != NONE && step->alternative_index < self->steps.size) {\n        step = array_get(&self->steps, step->alternative_index);\n      }\n      step->alternative_index = self->steps.size;\n    }\n\n    // Parse an '@'-prefixed capture pattern\n    else if (stream->next == '@') {\n      stream_advance(stream);\n      if (!stream_is_ident_start(stream)) return TSQueryErrorSyntax;\n      const char *capture_name = stream->input;\n      stream_scan_identifier(stream);\n      uint32_t length = (uint32_t)(stream->input - capture_name);\n      stream_skip_whitespace(stream);\n\n      // Add the capture id to the first step of the pattern\n      uint16_t capture_id = symbol_table_insert_name(\n        &self->captures,\n        capture_name,\n        length\n      );\n\n      // Add the capture quantifier\n      capture_quantifiers_add_for_id(capture_quantifiers, capture_id, TSQuantifierOne);\n\n      uint32_t step_index = starting_step_index;\n      for (;;) {\n        QueryStep *step = array_get(&self->steps, step_index);\n        query_step__add_capture(step, capture_id);\n        if (\n          step->alternative_index != NONE &&\n          step->alternative_index > step_index &&\n          step->alternative_index < self->steps.size\n        ) {\n          step_index = step->alternative_index;\n        } else {\n          break;\n        }\n      }\n    }\n\n    // No more suffix modifiers\n    else {\n      break;\n    }\n  }\n\n  capture_quantifiers_mul(capture_quantifiers, quantifier);\n\n  return 0;\n}\n\nTSQuery *ts_query_new(\n  const TSLanguage *language,\n  const char *source,\n  uint32_t source_len,\n  uint32_t *error_offset,\n  TSQueryError *error_type\n) {\n  if (\n    !language ||\n    language->abi_version > TREE_SITTER_LANGUAGE_VERSION ||\n    language->abi_version < TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION\n  ) {\n    *error_type = TSQueryErrorLanguage;\n    return NULL;\n  }\n\n  TSQuery *self = ts_malloc(sizeof(TSQuery));\n  *self = (TSQuery) {\n    .steps = array_new(),\n    .pattern_map = array_new(),\n    .captures = symbol_table_new(),\n    .capture_quantifiers = array_new(),\n    .predicate_values = symbol_table_new(),\n    .predicate_steps = array_new(),\n    .patterns = array_new(),\n    .step_offsets = array_new(),\n    .string_buffer = array_new(),\n    .negated_fields = array_new(),\n    .repeat_symbols_with_rootless_patterns = array_new(),\n    .wildcard_root_pattern_count = 0,\n    .language = ts_language_copy(language),\n  };\n\n  array_push(&self->negated_fields, 0);\n\n  // Parse all of the S-expressions in the given string.\n  Stream stream = stream_new(source, source_len);\n  stream_skip_whitespace(&stream);\n  while (stream.input < stream.end) {\n    uint32_t pattern_index = self->patterns.size;\n    uint32_t start_step_index = self->steps.size;\n    uint32_t start_predicate_step_index = self->predicate_steps.size;\n    array_push(&self->patterns, ((QueryPattern) {\n      .steps = (Slice) {.offset = start_step_index},\n      .predicate_steps = (Slice) {.offset = start_predicate_step_index},\n      .start_byte = stream_offset(&stream),\n      .is_non_local = false,\n    }));\n    CaptureQuantifiers capture_quantifiers = capture_quantifiers_new();\n    *error_type = ts_query__parse_pattern(self, &stream, 0, false, &capture_quantifiers);\n    array_push(&self->steps, query_step__new(0, PATTERN_DONE_MARKER, false));\n\n    QueryPattern *pattern = array_back(&self->patterns);\n    pattern->steps.length = self->steps.size - start_step_index;\n    pattern->predicate_steps.length = self->predicate_steps.size - start_predicate_step_index;\n    pattern->end_byte = stream_offset(&stream);\n\n    // If any pattern could not be parsed, then report the error information\n    // and terminate.\n    if (*error_type) {\n      if (*error_type == PARENT_DONE) *error_type = TSQueryErrorSyntax;\n      *error_offset = stream_offset(&stream);\n      capture_quantifiers_delete(&capture_quantifiers);\n      ts_query_delete(self);\n      return NULL;\n    }\n\n    // Maintain a list of capture quantifiers for each pattern\n    array_push(&self->capture_quantifiers, capture_quantifiers);\n\n    // Maintain a map that can look up patterns for a given root symbol.\n    uint16_t wildcard_root_alternative_index = NONE;\n    for (;;) {\n      QueryStep *step = array_get(&self->steps, start_step_index);\n\n      // If a pattern has a wildcard at its root, but it has a non-wildcard child,\n      // then optimize the matching process by skipping matching the wildcard.\n      // Later, during the matching process, the query cursor will check that\n      // there is a parent node, and capture it if necessary.\n      if (step->symbol == WILDCARD_SYMBOL && step->depth == 0 && !step->field) {\n        QueryStep *second_step = array_get(&self->steps, start_step_index + 1);\n        if (second_step->symbol != WILDCARD_SYMBOL && second_step->depth == 1 && !second_step->is_immediate) {\n          wildcard_root_alternative_index = step->alternative_index;\n          start_step_index += 1;\n          step = second_step;\n        }\n      }\n\n      // Determine whether the pattern has a single root node. This affects\n      // decisions about whether or not to start matching the pattern when\n      // a query cursor has a range restriction or when immediately within an\n      // error node.\n      uint32_t start_depth = step->depth;\n      bool is_rooted = start_depth == 0;\n      for (uint32_t step_index = start_step_index + 1; step_index < self->steps.size; step_index++) {\n        QueryStep *child_step = array_get(&self->steps, step_index);\n        if (child_step->is_dead_end) break;\n        if (child_step->depth == start_depth) {\n          is_rooted = false;\n          break;\n        }\n      }\n\n      ts_query__pattern_map_insert(self, step->symbol, (PatternEntry) {\n        .step_index = start_step_index,\n        .pattern_index = pattern_index,\n        .is_rooted = is_rooted\n      });\n      if (step->symbol == WILDCARD_SYMBOL) {\n        self->wildcard_root_pattern_count++;\n      }\n\n      // If there are alternatives or options at the root of the pattern,\n      // then add multiple entries to the pattern map.\n      if (step->alternative_index != NONE) {\n        start_step_index = step->alternative_index;\n      } else if (wildcard_root_alternative_index != NONE) {\n        start_step_index = wildcard_root_alternative_index;\n        wildcard_root_alternative_index = NONE;\n      } else {\n        break;\n      }\n    }\n  }\n\n  if (!ts_query__analyze_patterns(self, error_offset)) {\n    *error_type = TSQueryErrorStructure;\n    ts_query_delete(self);\n    return NULL;\n  }\n\n  array_delete(&self->string_buffer);\n  return self;\n}\n\nvoid ts_query_delete(TSQuery *self) {\n  if (self) {\n    array_delete(&self->steps);\n    array_delete(&self->pattern_map);\n    array_delete(&self->predicate_steps);\n    array_delete(&self->patterns);\n    array_delete(&self->step_offsets);\n    array_delete(&self->string_buffer);\n    array_delete(&self->negated_fields);\n    array_delete(&self->repeat_symbols_with_rootless_patterns);\n    ts_language_delete(self->language);\n    symbol_table_delete(&self->captures);\n    symbol_table_delete(&self->predicate_values);\n    for (uint32_t index = 0; index < self->capture_quantifiers.size; index++) {\n      CaptureQuantifiers *capture_quantifiers = array_get(&self->capture_quantifiers, index);\n      capture_quantifiers_delete(capture_quantifiers);\n    }\n    array_delete(&self->capture_quantifiers);\n    ts_free(self);\n  }\n}\n\nuint32_t ts_query_pattern_count(const TSQuery *self) {\n  return self->patterns.size;\n}\n\nuint32_t ts_query_capture_count(const TSQuery *self) {\n  return self->captures.slices.size;\n}\n\nuint32_t ts_query_string_count(const TSQuery *self) {\n  return self->predicate_values.slices.size;\n}\n\nconst char *ts_query_capture_name_for_id(\n  const TSQuery *self,\n  uint32_t index,\n  uint32_t *length\n) {\n  return symbol_table_name_for_id(&self->captures, index, length);\n}\n\nTSQuantifier ts_query_capture_quantifier_for_id(\n  const TSQuery *self,\n  uint32_t pattern_index,\n  uint32_t capture_index\n) {\n  CaptureQuantifiers *capture_quantifiers = array_get(&self->capture_quantifiers, pattern_index);\n  return capture_quantifier_for_id(capture_quantifiers, capture_index);\n}\n\nconst char *ts_query_string_value_for_id(\n  const TSQuery *self,\n  uint32_t index,\n  uint32_t *length\n) {\n  return symbol_table_name_for_id(&self->predicate_values, index, length);\n}\n\nconst TSQueryPredicateStep *ts_query_predicates_for_pattern(\n  const TSQuery *self,\n  uint32_t pattern_index,\n  uint32_t *step_count\n) {\n  Slice slice = array_get(&self->patterns, pattern_index)->predicate_steps;\n  *step_count = slice.length;\n  if (slice.length == 0) return NULL;\n  return array_get(&self->predicate_steps, slice.offset);\n}\n\nuint32_t ts_query_start_byte_for_pattern(\n  const TSQuery *self,\n  uint32_t pattern_index\n) {\n  return array_get(&self->patterns, pattern_index)->start_byte;\n}\n\nuint32_t ts_query_end_byte_for_pattern(\n  const TSQuery *self,\n  uint32_t pattern_index\n) {\n  return array_get(&self->patterns, pattern_index)->end_byte;\n}\n\nbool ts_query_is_pattern_rooted(\n  const TSQuery *self,\n  uint32_t pattern_index\n) {\n  for (unsigned i = 0; i < self->pattern_map.size; i++) {\n    PatternEntry *entry = array_get(&self->pattern_map, i);\n    if (entry->pattern_index == pattern_index) {\n      if (!entry->is_rooted) return false;\n    }\n  }\n  return true;\n}\n\nbool ts_query_is_pattern_non_local(\n  const TSQuery *self,\n  uint32_t pattern_index\n) {\n  if (pattern_index < self->patterns.size) {\n    return array_get(&self->patterns, pattern_index)->is_non_local;\n  } else {\n    return false;\n  }\n}\n\nbool ts_query_is_pattern_guaranteed_at_step(\n  const TSQuery *self,\n  uint32_t byte_offset\n) {\n  uint32_t step_index = UINT32_MAX;\n  for (unsigned i = 0; i < self->step_offsets.size; i++) {\n    StepOffset *step_offset = array_get(&self->step_offsets, i);\n    if (step_offset->byte_offset > byte_offset) break;\n    step_index = step_offset->step_index;\n  }\n  if (step_index < self->steps.size) {\n    return array_get(&self->steps, step_index)->root_pattern_guaranteed;\n  } else {\n    return false;\n  }\n}\n\nbool ts_query__step_is_fallible(\n  const TSQuery *self,\n  uint16_t step_index\n) {\n  ts_assert((uint32_t)step_index + 1 < self->steps.size);\n  QueryStep *step = array_get(&self->steps, step_index);\n  QueryStep *next_step = array_get(&self->steps, step_index + 1);\n  return (\n    next_step->depth != PATTERN_DONE_MARKER &&\n    next_step->depth > step->depth &&\n    (!next_step->parent_pattern_guaranteed || step->symbol == WILDCARD_SYMBOL)\n  );\n}\n\nvoid ts_query_disable_capture(\n  TSQuery *self,\n  const char *name,\n  uint32_t length\n) {\n  // Remove capture information for any pattern step that previously\n  // captured with the given name.\n  int id = symbol_table_id_for_name(&self->captures, name, length);\n  if (id != -1) {\n    for (unsigned i = 0; i < self->steps.size; i++) {\n      QueryStep *step = array_get(&self->steps, i);\n      query_step__remove_capture(step, id);\n    }\n  }\n}\n\nvoid ts_query_disable_pattern(\n  TSQuery *self,\n  uint32_t pattern_index\n) {\n  // Remove the given pattern from the pattern map. Its steps will still\n  // be in the `steps` array, but they will never be read.\n  for (unsigned i = 0; i < self->pattern_map.size; i++) {\n    PatternEntry *pattern = array_get(&self->pattern_map, i);\n    if (pattern->pattern_index == pattern_index) {\n      array_erase(&self->pattern_map, i);\n      i--;\n    }\n  }\n}\n\n/***************\n * QueryCursor\n ***************/\n\nTSQueryCursor *ts_query_cursor_new(void) {\n  TSQueryCursor *self = ts_malloc(sizeof(TSQueryCursor));\n  *self = (TSQueryCursor) {\n    .did_exceed_match_limit = false,\n    .ascending = false,\n    .halted = false,\n    .states = array_new(),\n    .finished_states = array_new(),\n    .capture_list_pool = capture_list_pool_new(),\n    .start_byte = 0,\n    .end_byte = UINT32_MAX,\n    .start_point = {0, 0},\n    .end_point = POINT_MAX,\n    .max_start_depth = UINT32_MAX,\n    .timeout_duration = 0,\n    .end_clock = clock_null(),\n    .operation_count = 0,\n  };\n  array_reserve(&self->states, 8);\n  array_reserve(&self->finished_states, 8);\n  return self;\n}\n\nvoid ts_query_cursor_delete(TSQueryCursor *self) {\n  array_delete(&self->states);\n  array_delete(&self->finished_states);\n  ts_tree_cursor_delete(&self->cursor);\n  capture_list_pool_delete(&self->capture_list_pool);\n  ts_free(self);\n}\n\nbool ts_query_cursor_did_exceed_match_limit(const TSQueryCursor *self) {\n  return self->did_exceed_match_limit;\n}\n\nuint32_t ts_query_cursor_match_limit(const TSQueryCursor *self) {\n  return self->capture_list_pool.max_capture_list_count;\n}\n\nvoid ts_query_cursor_set_match_limit(TSQueryCursor *self, uint32_t limit) {\n  self->capture_list_pool.max_capture_list_count = limit;\n}\n\nuint64_t ts_query_cursor_timeout_micros(const TSQueryCursor *self) {\n  return duration_to_micros(self->timeout_duration);\n}\n\nvoid ts_query_cursor_set_timeout_micros(TSQueryCursor *self, uint64_t timeout_micros) {\n  self->timeout_duration = duration_from_micros(timeout_micros);\n}\n\n#ifdef DEBUG_EXECUTE_QUERY\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define LOG(...)\n#endif\n\nvoid ts_query_cursor_exec(\n  TSQueryCursor *self,\n  const TSQuery *query,\n  TSNode node\n) {\n  if (query) {\n    LOG(\"query steps:\\n\");\n    for (unsigned i = 0; i < query->steps.size; i++) {\n      QueryStep *step = array_get(&query->steps, i);\n      LOG(\"  %u: {\", i);\n      if (step->depth == PATTERN_DONE_MARKER) {\n        LOG(\"DONE\");\n      } else if (step->is_dead_end) {\n        LOG(\"dead_end\");\n      } else if (step->is_pass_through) {\n        LOG(\"pass_through\");\n      } else if (step->symbol != WILDCARD_SYMBOL) {\n        LOG(\"symbol: %s\", query->language->symbol_names[step->symbol]);\n      } else {\n        LOG(\"symbol: *\");\n      }\n      if (step->field) {\n        LOG(\", field: %s\", query->language->field_names[step->field]);\n      }\n      if (step->alternative_index != NONE) {\n        LOG(\", alternative: %u\", step->alternative_index);\n      }\n      LOG(\"},\\n\");\n    }\n  }\n\n  array_clear(&self->states);\n  array_clear(&self->finished_states);\n  ts_tree_cursor_reset(&self->cursor, node);\n  capture_list_pool_reset(&self->capture_list_pool);\n  self->on_visible_node = true;\n  self->next_state_id = 0;\n  self->depth = 0;\n  self->ascending = false;\n  self->halted = false;\n  self->query = query;\n  self->did_exceed_match_limit = false;\n  self->operation_count = 0;\n  if (self->timeout_duration) {\n    self->end_clock = clock_after(clock_now(), self->timeout_duration);\n  } else {\n    self->end_clock = clock_null();\n  }\n  self->query_options = NULL;\n  self->query_state = (TSQueryCursorState) {0};\n}\n\nvoid ts_query_cursor_exec_with_options(\n  TSQueryCursor *self,\n  const TSQuery *query,\n  TSNode node,\n  const TSQueryCursorOptions *query_options\n) {\n  ts_query_cursor_exec(self, query, node);\n  if (query_options) {\n    self->query_options = query_options;\n    self->query_state = (TSQueryCursorState) {\n      .payload = query_options->payload\n    };\n  }\n}\n\nbool ts_query_cursor_set_byte_range(\n  TSQueryCursor *self,\n  uint32_t start_byte,\n  uint32_t end_byte\n) {\n  if (end_byte == 0) {\n    end_byte = UINT32_MAX;\n  }\n  if (start_byte > end_byte) {\n    return false;\n  }\n  self->start_byte = start_byte;\n  self->end_byte = end_byte;\n  return true;\n}\n\nbool ts_query_cursor_set_point_range(\n  TSQueryCursor *self,\n  TSPoint start_point,\n  TSPoint end_point\n) {\n  if (end_point.row == 0 && end_point.column == 0) {\n    end_point = POINT_MAX;\n  }\n  if (point_gt(start_point, end_point)) {\n    return false;\n  }\n  self->start_point = start_point;\n  self->end_point = end_point;\n  return true;\n}\n\n// Search through all of the in-progress states, and find the captured\n// node that occurs earliest in the document.\nstatic bool ts_query_cursor__first_in_progress_capture(\n  TSQueryCursor *self,\n  uint32_t *state_index,\n  uint32_t *byte_offset,\n  uint32_t *pattern_index,\n  bool *is_definite\n) {\n  bool result = false;\n  *state_index = UINT32_MAX;\n  *byte_offset = UINT32_MAX;\n  *pattern_index = UINT32_MAX;\n  for (unsigned i = 0; i < self->states.size; i++) {\n    QueryState *state = array_get(&self->states, i);\n    if (state->dead) continue;\n\n    const CaptureList *captures = capture_list_pool_get(\n      &self->capture_list_pool,\n      state->capture_list_id\n    );\n    if (state->consumed_capture_count >= captures->size) {\n      continue;\n    }\n\n    TSNode node = array_get(captures, state->consumed_capture_count)->node;\n    if (\n      ts_node_end_byte(node) <= self->start_byte ||\n      point_lte(ts_node_end_point(node), self->start_point)\n    ) {\n      state->consumed_capture_count++;\n      i--;\n      continue;\n    }\n\n    uint32_t node_start_byte = ts_node_start_byte(node);\n    if (\n      !result ||\n      node_start_byte < *byte_offset ||\n      (node_start_byte == *byte_offset && state->pattern_index < *pattern_index)\n    ) {\n      QueryStep *step = array_get(&self->query->steps, state->step_index);\n      if (is_definite) {\n        // We're being a bit conservative here by asserting that the following step\n        // is not immediate, because this capture might end up being discarded if the\n        // following symbol in the tree isn't the required symbol for this step.\n        *is_definite = step->root_pattern_guaranteed && !step->is_immediate;\n      } else if (step->root_pattern_guaranteed) {\n        continue;\n      }\n\n      result = true;\n      *state_index = i;\n      *byte_offset = node_start_byte;\n      *pattern_index = state->pattern_index;\n    }\n  }\n  return result;\n}\n\n// Determine which node is first in a depth-first traversal\nint ts_query_cursor__compare_nodes(TSNode left, TSNode right) {\n  if (left.id != right.id) {\n    uint32_t left_start = ts_node_start_byte(left);\n    uint32_t right_start = ts_node_start_byte(right);\n    if (left_start < right_start) return -1;\n    if (left_start > right_start) return 1;\n    uint32_t left_node_count = ts_node_end_byte(left);\n    uint32_t right_node_count = ts_node_end_byte(right);\n    if (left_node_count > right_node_count) return -1;\n    if (left_node_count < right_node_count) return 1;\n  }\n  return 0;\n}\n\n// Determine if either state contains a superset of the other state's captures.\nvoid ts_query_cursor__compare_captures(\n  TSQueryCursor *self,\n  QueryState *left_state,\n  QueryState *right_state,\n  bool *left_contains_right,\n  bool *right_contains_left\n) {\n  const CaptureList *left_captures = capture_list_pool_get(\n    &self->capture_list_pool,\n    left_state->capture_list_id\n  );\n  const CaptureList *right_captures = capture_list_pool_get(\n    &self->capture_list_pool,\n    right_state->capture_list_id\n  );\n  *left_contains_right = true;\n  *right_contains_left = true;\n  unsigned i = 0, j = 0;\n  for (;;) {\n    if (i < left_captures->size) {\n      if (j < right_captures->size) {\n        TSQueryCapture *left = array_get(left_captures, i);\n        TSQueryCapture *right = array_get(right_captures, j);\n        if (left->node.id == right->node.id && left->index == right->index) {\n          i++;\n          j++;\n        } else {\n          switch (ts_query_cursor__compare_nodes(left->node, right->node)) {\n            case -1:\n              *right_contains_left = false;\n              i++;\n              break;\n            case 1:\n              *left_contains_right = false;\n              j++;\n              break;\n            default:\n              *right_contains_left = false;\n              *left_contains_right = false;\n              i++;\n              j++;\n              break;\n          }\n        }\n      } else {\n        *right_contains_left = false;\n        break;\n      }\n    } else {\n      if (j < right_captures->size) {\n        *left_contains_right = false;\n      }\n      break;\n    }\n  }\n}\n\nstatic void ts_query_cursor__add_state(\n  TSQueryCursor *self,\n  const PatternEntry *pattern\n) {\n  QueryStep *step = array_get(&self->query->steps, pattern->step_index);\n  uint32_t start_depth = self->depth - step->depth;\n\n  // Keep the states array in ascending order of start_depth and pattern_index,\n  // so that it can be processed more efficiently elsewhere. Usually, there is\n  // no work to do here because of two facts:\n  // * States with lower start_depth are naturally added first due to the\n  //   order in which nodes are visited.\n  // * Earlier patterns are naturally added first because of the ordering of the\n  //   pattern_map data structure that's used to initiate matches.\n  //\n  // This loop is only needed in cases where two conditions hold:\n  // * A pattern consists of more than one sibling node, so that its states\n  //   remain in progress after exiting the node that started the match.\n  // * The first node in the pattern matches against multiple nodes at the\n  //   same depth.\n  //\n  // An example of this is the pattern '((comment)* (function))'. If multiple\n  // `comment` nodes appear in a row, then we may initiate a new state for this\n  // pattern while another state for the same pattern is already in progress.\n  // If there are multiple patterns like this in a query, then this loop will\n  // need to execute in order to keep the states ordered by pattern_index.\n  uint32_t index = self->states.size;\n  while (index > 0) {\n    QueryState *prev_state = array_get(&self->states, index - 1);\n    if (prev_state->start_depth < start_depth) break;\n    if (prev_state->start_depth == start_depth) {\n      // Avoid inserting an unnecessary duplicate state, which would be\n      // immediately pruned by the longest-match criteria.\n      if (\n        prev_state->pattern_index == pattern->pattern_index &&\n        prev_state->step_index == pattern->step_index\n      ) return;\n      if (prev_state->pattern_index <= pattern->pattern_index) break;\n    }\n    index--;\n  }\n\n  LOG(\n    \"  start state. pattern:%u, step:%u\\n\",\n    pattern->pattern_index,\n    pattern->step_index\n  );\n  array_insert(&self->states, index, ((QueryState) {\n    .id = UINT32_MAX,\n    .capture_list_id = NONE,\n    .step_index = pattern->step_index,\n    .pattern_index = pattern->pattern_index,\n    .start_depth = start_depth,\n    .consumed_capture_count = 0,\n    .seeking_immediate_match = true,\n    .has_in_progress_alternatives = false,\n    .needs_parent = step->depth == 1,\n    .dead = false,\n  }));\n}\n\n// Acquire a capture list for this state. If there are no capture lists left in the\n// pool, this will steal the capture list from another existing state, and mark that\n// other state as 'dead'.\nstatic CaptureList *ts_query_cursor__prepare_to_capture(\n  TSQueryCursor *self,\n  QueryState *state,\n  unsigned state_index_to_preserve\n) {\n  if (state->capture_list_id == NONE) {\n    state->capture_list_id = capture_list_pool_acquire(&self->capture_list_pool);\n\n    // If there are no capture lists left in the pool, then terminate whichever\n    // state has captured the earliest node in the document, and steal its\n    // capture list.\n    if (state->capture_list_id == NONE) {\n      self->did_exceed_match_limit = true;\n      uint32_t state_index, byte_offset, pattern_index;\n      if (\n        ts_query_cursor__first_in_progress_capture(\n          self,\n          &state_index,\n          &byte_offset,\n          &pattern_index,\n          NULL\n        ) &&\n        state_index != state_index_to_preserve\n      ) {\n        LOG(\n          \"  abandon state. index:%u, pattern:%u, offset:%u.\\n\",\n          state_index, pattern_index, byte_offset\n        );\n        QueryState *other_state = array_get(&self->states, state_index);\n        state->capture_list_id = other_state->capture_list_id;\n        other_state->capture_list_id = NONE;\n        other_state->dead = true;\n        CaptureList *list = capture_list_pool_get_mut(\n          &self->capture_list_pool,\n          state->capture_list_id\n        );\n        array_clear(list);\n        return list;\n      } else {\n        LOG(\"  ran out of capture lists\");\n        return NULL;\n      }\n    }\n  }\n  return capture_list_pool_get_mut(&self->capture_list_pool, state->capture_list_id);\n}\n\nstatic void ts_query_cursor__capture(\n  TSQueryCursor *self,\n  QueryState *state,\n  QueryStep *step,\n  TSNode node\n) {\n  if (state->dead) return;\n  CaptureList *capture_list = ts_query_cursor__prepare_to_capture(self, state, UINT32_MAX);\n  if (!capture_list) {\n    state->dead = true;\n    return;\n  }\n\n  for (unsigned j = 0; j < MAX_STEP_CAPTURE_COUNT; j++) {\n    uint16_t capture_id = step->capture_ids[j];\n    if (step->capture_ids[j] == NONE) break;\n    array_push(capture_list, ((TSQueryCapture) { node, capture_id }));\n    LOG(\n      \"  capture node. type:%s, pattern:%u, capture_id:%u, capture_count:%u\\n\",\n      ts_node_type(node),\n      state->pattern_index,\n      capture_id,\n      capture_list->size\n    );\n  }\n}\n\n// Duplicate the given state and insert the newly-created state immediately after\n// the given state in the `states` array. Ensures that the given state reference is\n// still valid, even if the states array is reallocated.\nstatic QueryState *ts_query_cursor__copy_state(\n  TSQueryCursor *self,\n  QueryState **state_ref\n) {\n  const QueryState *state = *state_ref;\n  uint32_t state_index = (uint32_t)(state - self->states.contents);\n  QueryState copy = *state;\n  copy.capture_list_id = NONE;\n\n  // If the state has captures, copy its capture list.\n  if (state->capture_list_id != NONE) {\n    CaptureList *new_captures = ts_query_cursor__prepare_to_capture(self, &copy, state_index);\n    if (!new_captures) return NULL;\n    const CaptureList *old_captures = capture_list_pool_get(\n      &self->capture_list_pool,\n      state->capture_list_id\n    );\n    array_push_all(new_captures, old_captures);\n  }\n\n  array_insert(&self->states, state_index + 1, copy);\n  *state_ref = array_get(&self->states, state_index);\n  return array_get(&self->states, state_index + 1);\n}\n\nstatic inline bool ts_query_cursor__should_descend(\n  TSQueryCursor *self,\n  bool node_intersects_range\n) {\n\n  if (node_intersects_range && self->depth < self->max_start_depth) {\n    return true;\n  }\n\n  // If there are in-progress matches whose remaining steps occur\n  // deeper in the tree, then descend.\n  for (unsigned i = 0; i < self->states.size; i++) {\n    QueryState *state = array_get(&self->states, i);\n    QueryStep *next_step = array_get(&self->query->steps, state->step_index);\n    if (\n      next_step->depth != PATTERN_DONE_MARKER &&\n      state->start_depth + next_step->depth > self->depth\n    ) {\n      return true;\n    }\n  }\n\n  if (self->depth >= self->max_start_depth) {\n    return false;\n  }\n\n  // If the current node is hidden, then a non-rooted pattern might match\n  // one if its roots inside of this node, and match another of its roots\n  // as part of a sibling node, so we may need to descend.\n  if (!self->on_visible_node) {\n    // Descending into a repetition node outside of the range can be\n    // expensive, because these nodes can have many visible children.\n    // Avoid descending into repetition nodes unless we have already\n    // determined that this query can match rootless patterns inside\n    // of this type of repetition node.\n    Subtree subtree = ts_tree_cursor_current_subtree(&self->cursor);\n    if (ts_subtree_is_repetition(subtree)) {\n      bool exists;\n      uint32_t index;\n      array_search_sorted_by(\n        &self->query->repeat_symbols_with_rootless_patterns,,\n        ts_subtree_symbol(subtree),\n        &index,\n        &exists\n      );\n      return exists;\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\n// Walk the tree, processing patterns until at least one pattern finishes,\n// If one or more patterns finish, return `true` and store their states in the\n// `finished_states` array. Multiple patterns can finish on the same node. If\n// there are no more matches, return `false`.\nstatic inline bool ts_query_cursor__advance(\n  TSQueryCursor *self,\n  bool stop_on_definite_step\n) {\n  bool did_match = false;\n  for (;;) {\n    if (self->halted) {\n      while (self->states.size > 0) {\n        QueryState state = array_pop(&self->states);\n        capture_list_pool_release(\n          &self->capture_list_pool,\n          state.capture_list_id\n        );\n      }\n    }\n\n    if (++self->operation_count == OP_COUNT_PER_QUERY_TIMEOUT_CHECK) {\n      self->operation_count = 0;\n    }\n\n    if (self->query_options && self->query_options->progress_callback) {\n      self->query_state.current_byte_offset = ts_node_start_byte(ts_tree_cursor_current_node(&self->cursor));\n    }\n    if (\n      did_match ||\n      self->halted ||\n      (\n        self->operation_count == 0 &&\n        (\n          (!clock_is_null(self->end_clock) && clock_is_gt(clock_now(), self->end_clock)) ||\n          (self->query_options && self->query_options->progress_callback && self->query_options->progress_callback(&self->query_state))\n        )\n      )\n    ) {\n      return did_match;\n    }\n\n    // Exit the current node.\n    if (self->ascending) {\n      if (self->on_visible_node) {\n        LOG(\n          \"leave node. depth:%u, type:%s\\n\",\n          self->depth,\n          ts_node_type(ts_tree_cursor_current_node(&self->cursor))\n        );\n\n        // After leaving a node, remove any states that cannot make further progress.\n        uint32_t deleted_count = 0;\n        for (unsigned i = 0, n = self->states.size; i < n; i++) {\n          QueryState *state = array_get(&self->states, i);\n          QueryStep *step = array_get(&self->query->steps, state->step_index);\n\n          // If a state completed its pattern inside of this node, but was deferred from finishing\n          // in order to search for longer matches, mark it as finished.\n          if (\n            step->depth == PATTERN_DONE_MARKER &&\n            (state->start_depth > self->depth || self->depth == 0)\n          ) {\n            LOG(\"  finish pattern %u\\n\", state->pattern_index);\n            array_push(&self->finished_states, *state);\n            did_match = true;\n            deleted_count++;\n          }\n\n          // If a state needed to match something within this node, then remove that state\n          // as it has failed to match.\n          else if (\n            step->depth != PATTERN_DONE_MARKER &&\n            (uint32_t)state->start_depth + (uint32_t)step->depth > self->depth\n          ) {\n            LOG(\n              \"  failed to match. pattern:%u, step:%u\\n\",\n              state->pattern_index,\n              state->step_index\n            );\n            capture_list_pool_release(\n              &self->capture_list_pool,\n              state->capture_list_id\n            );\n            deleted_count++;\n          }\n\n          else if (deleted_count > 0) {\n            *array_get(&self->states, i - deleted_count) = *state;\n          }\n        }\n        self->states.size -= deleted_count;\n      }\n\n      // Leave this node by stepping to its next sibling or to its parent.\n      switch (ts_tree_cursor_goto_next_sibling_internal(&self->cursor)) {\n        case TreeCursorStepVisible:\n          if (!self->on_visible_node) {\n            self->depth++;\n            self->on_visible_node = true;\n          }\n          self->ascending = false;\n          break;\n        case TreeCursorStepHidden:\n          if (self->on_visible_node) {\n            self->depth--;\n            self->on_visible_node = false;\n          }\n          self->ascending = false;\n          break;\n        default:\n          if (ts_tree_cursor_goto_parent(&self->cursor)) {\n            self->depth--;\n          } else {\n            LOG(\"halt at root\\n\");\n            self->halted = true;\n          }\n      }\n    }\n\n    // Enter a new node.\n    else {\n      // Get the properties of the current node.\n      TSNode node = ts_tree_cursor_current_node(&self->cursor);\n      TSNode parent_node = ts_tree_cursor_parent_node(&self->cursor);\n\n      uint32_t start_byte = ts_node_start_byte(node);\n      uint32_t end_byte = ts_node_end_byte(node);\n      TSPoint start_point = ts_node_start_point(node);\n      TSPoint end_point = ts_node_end_point(node);\n      bool is_empty = start_byte == end_byte;\n\n      bool parent_precedes_range = !ts_node_is_null(parent_node) && (\n        ts_node_end_byte(parent_node) <= self->start_byte ||\n        point_lte(ts_node_end_point(parent_node), self->start_point)\n      );\n      bool parent_follows_range = !ts_node_is_null(parent_node) && (\n        ts_node_start_byte(parent_node) >= self->end_byte ||\n        point_gte(ts_node_start_point(parent_node), self->end_point)\n      );\n      bool node_precedes_range =\n        parent_precedes_range ||\n        end_byte < self->start_byte ||\n        point_lt(end_point, self->start_point) ||\n        (!is_empty && end_byte == self->start_byte) ||\n        (!is_empty && point_eq(end_point, self->start_point));\n\n      bool node_follows_range = parent_follows_range || (\n        start_byte >= self->end_byte ||\n        point_gte(start_point, self->end_point)\n      );\n      bool parent_intersects_range = !parent_precedes_range && !parent_follows_range;\n      bool node_intersects_range = !node_precedes_range && !node_follows_range;\n\n      if (self->on_visible_node) {\n        TSSymbol symbol = ts_node_symbol(node);\n        bool is_named = ts_node_is_named(node);\n        bool is_missing = ts_node_is_missing(node);\n        bool has_later_siblings;\n        bool has_later_named_siblings;\n        bool can_have_later_siblings_with_this_field;\n        TSFieldId field_id = 0;\n        TSSymbol supertypes[8] = {0};\n        unsigned supertype_count = 8;\n        ts_tree_cursor_current_status(\n          &self->cursor,\n          &field_id,\n          &has_later_siblings,\n          &has_later_named_siblings,\n          &can_have_later_siblings_with_this_field,\n          supertypes,\n          &supertype_count\n        );\n        LOG(\n          \"enter node. depth:%u, type:%s, field:%s, row:%u state_count:%u, finished_state_count:%u\\n\",\n          self->depth,\n          ts_node_type(node),\n          ts_language_field_name_for_id(self->query->language, field_id),\n          ts_node_start_point(node).row,\n          self->states.size,\n          self->finished_states.size\n        );\n\n        bool node_is_error = symbol == ts_builtin_sym_error;\n        bool parent_is_error =\n          !ts_node_is_null(parent_node) &&\n          ts_node_symbol(parent_node) == ts_builtin_sym_error;\n\n        // Add new states for any patterns whose root node is a wildcard.\n        if (!node_is_error) {\n          for (unsigned i = 0; i < self->query->wildcard_root_pattern_count; i++) {\n            PatternEntry *pattern = array_get(&self->query->pattern_map, i);\n\n            // If this node matches the first step of the pattern, then add a new\n            // state at the start of this pattern.\n            QueryStep *step = array_get(&self->query->steps, pattern->step_index);\n            uint32_t start_depth = self->depth - step->depth;\n            if (\n              (pattern->is_rooted ?\n                node_intersects_range :\n                (parent_intersects_range && !parent_is_error)) &&\n              (!step->field || field_id == step->field) &&\n              (!step->supertype_symbol || supertype_count > 0) &&\n              (start_depth <= self->max_start_depth)\n            ) {\n              ts_query_cursor__add_state(self, pattern);\n            }\n          }\n        }\n\n        // Add new states for any patterns whose root node matches this node.\n        unsigned i;\n        if (ts_query__pattern_map_search(self->query, symbol, &i)) {\n          PatternEntry *pattern = array_get(&self->query->pattern_map, i);\n\n          QueryStep *step = array_get(&self->query->steps, pattern->step_index);\n          uint32_t start_depth = self->depth - step->depth;\n          do {\n            // If this node matches the first step of the pattern, then add a new\n            // state at the start of this pattern.\n            if (\n              (pattern->is_rooted ?\n                node_intersects_range :\n                (parent_intersects_range && !parent_is_error)) &&\n              (!step->field || field_id == step->field) &&\n              (start_depth <= self->max_start_depth)\n            ) {\n              ts_query_cursor__add_state(self, pattern);\n            }\n\n            // Advance to the next pattern whose root node matches this node.\n            i++;\n            if (i == self->query->pattern_map.size) break;\n            pattern = array_get(&self->query->pattern_map, i);\n            step = array_get(&self->query->steps, pattern->step_index);\n          } while (step->symbol == symbol);\n        }\n\n        // Update all of the in-progress states with current node.\n        for (unsigned j = 0, copy_count = 0; j < self->states.size; j += 1 + copy_count) {\n          QueryState *state = array_get(&self->states, j);\n          QueryStep *step = array_get(&self->query->steps, state->step_index);\n          state->has_in_progress_alternatives = false;\n          copy_count = 0;\n\n          // Check that the node matches all of the criteria for the next\n          // step of the pattern.\n          if ((uint32_t)state->start_depth + (uint32_t)step->depth != self->depth) continue;\n\n          // Determine if this node matches this step of the pattern, and also\n          // if this node can have later siblings that match this step of the\n          // pattern.\n          bool node_does_match = false;\n          if (step->symbol == WILDCARD_SYMBOL) {\n            if (step->is_missing) {\n              node_does_match = is_missing;\n            } else {\n              node_does_match = !node_is_error && (is_named || !step->is_named);\n            }\n          } else {\n            node_does_match = symbol == step->symbol && (!step->is_missing || is_missing);\n          }\n          bool later_sibling_can_match = has_later_siblings;\n          if ((step->is_immediate && is_named) || state->seeking_immediate_match) {\n            later_sibling_can_match = false;\n          }\n          if (step->is_last_child && has_later_named_siblings) {\n            node_does_match = false;\n          }\n          if (step->supertype_symbol) {\n            bool has_supertype = false;\n            for (unsigned k = 0; k < supertype_count; k++) {\n              if (supertypes[k] == step->supertype_symbol) {\n                has_supertype = true;\n                break;\n              }\n            }\n            if (!has_supertype) node_does_match = false;\n          }\n          if (step->field) {\n            if (step->field == field_id) {\n              if (!can_have_later_siblings_with_this_field) {\n                later_sibling_can_match = false;\n              }\n            } else {\n              node_does_match = false;\n            }\n          }\n\n          if (step->negated_field_list_id) {\n            TSFieldId *negated_field_ids = array_get(&self->query->negated_fields, step->negated_field_list_id);\n            for (;;) {\n              TSFieldId negated_field_id = *negated_field_ids;\n              if (negated_field_id) {\n                negated_field_ids++;\n                if (ts_node_child_by_field_id(node, negated_field_id).id) {\n                  node_does_match = false;\n                  break;\n                }\n              } else {\n                break;\n              }\n            }\n          }\n\n          // Remove states immediately if it is ever clear that they cannot match.\n          if (!node_does_match) {\n            if (!later_sibling_can_match) {\n              LOG(\n                \"  discard state. pattern:%u, step:%u\\n\",\n                state->pattern_index,\n                state->step_index\n              );\n              capture_list_pool_release(\n                &self->capture_list_pool,\n                state->capture_list_id\n              );\n              array_erase(&self->states, j);\n              j--;\n            }\n            continue;\n          }\n\n          // Some patterns can match their root node in multiple ways, capturing different\n          // children. If this pattern step could match later children within the same\n          // parent, then this query state cannot simply be updated in place. It must be\n          // split into two states: one that matches this node, and one which skips over\n          // this node, to preserve the possibility of matching later siblings.\n          if (later_sibling_can_match && (\n            step->contains_captures ||\n            ts_query__step_is_fallible(self->query, state->step_index)\n          )) {\n            if (ts_query_cursor__copy_state(self, &state)) {\n              LOG(\n                \"  split state for capture. pattern:%u, step:%u\\n\",\n                state->pattern_index,\n                state->step_index\n              );\n              copy_count++;\n            }\n          }\n\n          // If this pattern started with a wildcard, such that the pattern map\n          // actually points to the *second* step of the pattern, then check\n          // that the node has a parent, and capture the parent node if necessary.\n          if (state->needs_parent) {\n            TSNode parent = ts_tree_cursor_parent_node(&self->cursor);\n            if (ts_node_is_null(parent)) {\n              LOG(\"  missing parent node\\n\");\n              state->dead = true;\n            } else {\n              state->needs_parent = false;\n              QueryStep *skipped_wildcard_step = step;\n              do {\n                skipped_wildcard_step--;\n              } while (\n                skipped_wildcard_step->is_dead_end ||\n                skipped_wildcard_step->is_pass_through ||\n                skipped_wildcard_step->depth > 0\n              );\n              if (skipped_wildcard_step->capture_ids[0] != NONE) {\n                LOG(\"  capture wildcard parent\\n\");\n                ts_query_cursor__capture(\n                  self,\n                  state,\n                  skipped_wildcard_step,\n                  parent\n                );\n              }\n            }\n          }\n\n          // If the current node is captured in this pattern, add it to the capture list.\n          if (step->capture_ids[0] != NONE) {\n            ts_query_cursor__capture(self, state, step, node);\n          }\n\n          if (state->dead) {\n            array_erase(&self->states, j);\n            j--;\n            continue;\n          }\n\n          // Advance this state to the next step of its pattern.\n          state->step_index++;\n          LOG(\n            \"  advance state. pattern:%u, step:%u\\n\",\n            state->pattern_index,\n            state->step_index\n          );\n\n          QueryStep *next_step = array_get(&self->query->steps, state->step_index);\n\n          // For a given step, if the current symbol is the wildcard symbol, `_`, and it is **not**\n          // named, meaning it should capture anonymous nodes, **and** the next step is immediate,\n          // we reuse the `seeking_immediate_match` flag to indicate that we are looking for an\n          // immediate match due to an unnamed wildcard symbol.\n          //\n          // The reason for this is that typically, anchors will not consider anonymous nodes,\n          // but we're special casing the wildcard symbol to allow for any immediate matches,\n          // regardless of whether they are named or not.\n          if (step->symbol == WILDCARD_SYMBOL && !step->is_named && next_step->is_immediate) {\n              state->seeking_immediate_match = true;\n          } else {\n              state->seeking_immediate_match = false;\n          }\n\n          if (stop_on_definite_step && next_step->root_pattern_guaranteed) did_match = true;\n\n          // If this state's next step has an alternative step, then copy the state in order\n          // to pursue both alternatives. The alternative step itself may have an alternative,\n          // so this is an interactive process.\n          unsigned end_index = j + 1;\n          for (unsigned k = j; k < end_index; k++) {\n            QueryState *child_state = array_get(&self->states, k);\n            QueryStep *child_step = array_get(&self->query->steps, child_state->step_index);\n            if (child_step->alternative_index != NONE) {\n              // A \"dead-end\" step exists only to add a non-sequential jump into the step sequence,\n              // via its alternative index. When a state reaches a dead-end step, it jumps straight\n              // to the step's alternative.\n              if (child_step->is_dead_end) {\n                child_state->step_index = child_step->alternative_index;\n                k--;\n                continue;\n              }\n\n              // A \"pass-through\" step exists only to add a branch into the step sequence,\n              // via its alternative_index. When a state reaches a pass-through step, it splits\n              // in order to process the alternative step, and then it advances to the next step.\n              if (child_step->is_pass_through) {\n                child_state->step_index++;\n                k--;\n              }\n\n              QueryState *copy = ts_query_cursor__copy_state(self, &child_state);\n              if (copy) {\n                LOG(\n                  \"  split state for branch. pattern:%u, from_step:%u, to_step:%u, immediate:%d, capture_count: %u\\n\",\n                  copy->pattern_index,\n                  copy->step_index,\n                  next_step->alternative_index,\n                  next_step->alternative_is_immediate,\n                  capture_list_pool_get(&self->capture_list_pool, copy->capture_list_id)->size\n                );\n                end_index++;\n                copy_count++;\n                copy->step_index = child_step->alternative_index;\n                if (child_step->alternative_is_immediate) {\n                  copy->seeking_immediate_match = true;\n                }\n              }\n            }\n          }\n        }\n\n        for (unsigned j = 0; j < self->states.size; j++) {\n          QueryState *state = array_get(&self->states, j);\n          if (state->dead) {\n            array_erase(&self->states, j);\n            j--;\n            continue;\n          }\n\n          // Enforce the longest-match criteria. When a query pattern contains optional or\n          // repeated nodes, this is necessary to avoid multiple redundant states, where\n          // one state has a strict subset of another state's captures.\n          bool did_remove = false;\n          for (unsigned k = j + 1; k < self->states.size; k++) {\n            QueryState *other_state = array_get(&self->states, k);\n\n            // Query states are kept in ascending order of start_depth and pattern_index.\n            // Since the longest-match criteria is only used for deduping matches of the same\n            // pattern and root node, we only need to perform pairwise comparisons within a\n            // small slice of the states array.\n            if (\n              other_state->start_depth != state->start_depth ||\n              other_state->pattern_index != state->pattern_index\n            ) break;\n\n            bool left_contains_right, right_contains_left;\n            ts_query_cursor__compare_captures(\n              self,\n              state,\n              other_state,\n              &left_contains_right,\n              &right_contains_left\n            );\n            if (left_contains_right) {\n              if (state->step_index == other_state->step_index) {\n                LOG(\n                  \"  drop shorter state. pattern: %u, step_index: %u\\n\",\n                  state->pattern_index,\n                  state->step_index\n                );\n                capture_list_pool_release(&self->capture_list_pool, other_state->capture_list_id);\n                array_erase(&self->states, k);\n                k--;\n                continue;\n              }\n              other_state->has_in_progress_alternatives = true;\n            }\n            if (right_contains_left) {\n              if (state->step_index == other_state->step_index) {\n                LOG(\n                  \"  drop shorter state. pattern: %u, step_index: %u\\n\",\n                  state->pattern_index,\n                  state->step_index\n                );\n                capture_list_pool_release(&self->capture_list_pool, state->capture_list_id);\n                array_erase(&self->states, j);\n                j--;\n                did_remove = true;\n                break;\n              }\n              state->has_in_progress_alternatives = true;\n            }\n          }\n\n          // If the state is at the end of its pattern, remove it from the list\n          // of in-progress states and add it to the list of finished states.\n          if (!did_remove) {\n            LOG(\n              \"  keep state. pattern: %u, start_depth: %u, step_index: %u, capture_count: %u\\n\",\n              state->pattern_index,\n              state->start_depth,\n              state->step_index,\n              capture_list_pool_get(&self->capture_list_pool, state->capture_list_id)->size\n            );\n            QueryStep *next_step = array_get(&self->query->steps, state->step_index);\n            if (next_step->depth == PATTERN_DONE_MARKER) {\n              if (state->has_in_progress_alternatives) {\n                LOG(\"  defer finishing pattern %u\\n\", state->pattern_index);\n              } else {\n                LOG(\"  finish pattern %u\\n\", state->pattern_index);\n                array_push(&self->finished_states, *state);\n                array_erase(&self->states, (uint32_t)(state - self->states.contents));\n                did_match = true;\n                j--;\n              }\n            }\n          }\n        }\n      }\n\n      if (ts_query_cursor__should_descend(self, node_intersects_range)) {\n        switch (ts_tree_cursor_goto_first_child_internal(&self->cursor)) {\n          case TreeCursorStepVisible:\n            self->depth++;\n            self->on_visible_node = true;\n            continue;\n          case TreeCursorStepHidden:\n            self->on_visible_node = false;\n            continue;\n          default:\n            break;\n        }\n      }\n\n      self->ascending = true;\n    }\n  }\n}\n\nbool ts_query_cursor_next_match(\n  TSQueryCursor *self,\n  TSQueryMatch *match\n) {\n  if (self->finished_states.size == 0) {\n    if (!ts_query_cursor__advance(self, false)) {\n      return false;\n    }\n  }\n\n  QueryState *state = array_get(&self->finished_states, 0);\n  if (state->id == UINT32_MAX) state->id = self->next_state_id++;\n  match->id = state->id;\n  match->pattern_index = state->pattern_index;\n  const CaptureList *captures = capture_list_pool_get(\n    &self->capture_list_pool,\n    state->capture_list_id\n  );\n  match->captures = captures->contents;\n  match->capture_count = captures->size;\n  capture_list_pool_release(&self->capture_list_pool, state->capture_list_id);\n  array_erase(&self->finished_states, 0);\n  return true;\n}\n\nvoid ts_query_cursor_remove_match(\n  TSQueryCursor *self,\n  uint32_t match_id\n) {\n  for (unsigned i = 0; i < self->finished_states.size; i++) {\n    const QueryState *state = array_get(&self->finished_states, i);\n    if (state->id == match_id) {\n      capture_list_pool_release(\n        &self->capture_list_pool,\n        state->capture_list_id\n      );\n      array_erase(&self->finished_states, i);\n      return;\n    }\n  }\n\n  // Remove unfinished query states as well to prevent future\n  // captures for a match being removed.\n  for (unsigned i = 0; i < self->states.size; i++) {\n    const QueryState *state = array_get(&self->states, i);\n    if (state->id == match_id) {\n      capture_list_pool_release(\n        &self->capture_list_pool,\n        state->capture_list_id\n      );\n      array_erase(&self->states, i);\n      return;\n    }\n  }\n}\n\nbool ts_query_cursor_next_capture(\n  TSQueryCursor *self,\n  TSQueryMatch *match,\n  uint32_t *capture_index\n) {\n  // The goal here is to return captures in order, even though they may not\n  // be discovered in order, because patterns can overlap. Search for matches\n  // until there is a finished capture that is before any unfinished capture.\n  for (;;) {\n    // First, find the earliest capture in an unfinished match.\n    uint32_t first_unfinished_capture_byte;\n    uint32_t first_unfinished_pattern_index;\n    uint32_t first_unfinished_state_index;\n    bool first_unfinished_state_is_definite = false;\n    bool found_unfinished_state = ts_query_cursor__first_in_progress_capture(\n      self,\n      &first_unfinished_state_index,\n      &first_unfinished_capture_byte,\n      &first_unfinished_pattern_index,\n      &first_unfinished_state_is_definite\n    );\n\n    // Then find the earliest capture in a finished match. It must occur\n    // before the first capture in an *unfinished* match.\n    QueryState *first_finished_state = NULL;\n    uint32_t first_finished_capture_byte = first_unfinished_capture_byte;\n    uint32_t first_finished_pattern_index = first_unfinished_pattern_index;\n    for (unsigned i = 0; i < self->finished_states.size;) {\n      QueryState *state = array_get(&self->finished_states, i);\n      const CaptureList *captures = capture_list_pool_get(\n        &self->capture_list_pool,\n        state->capture_list_id\n      );\n\n      // Remove states whose captures are all consumed.\n      if (state->consumed_capture_count >= captures->size) {\n        capture_list_pool_release(\n          &self->capture_list_pool,\n          state->capture_list_id\n        );\n        array_erase(&self->finished_states, i);\n        continue;\n      }\n\n      TSNode node = array_get(captures, state->consumed_capture_count)->node;\n\n      bool node_precedes_range = (\n        ts_node_end_byte(node) <= self->start_byte ||\n        point_lte(ts_node_end_point(node), self->start_point)\n      );\n      bool node_follows_range = (\n        ts_node_start_byte(node) >= self->end_byte ||\n        point_gte(ts_node_start_point(node), self->end_point)\n      );\n      bool node_outside_of_range = node_precedes_range || node_follows_range;\n\n      // Skip captures that are outside of the cursor's range.\n      if (node_outside_of_range) {\n        state->consumed_capture_count++;\n        continue;\n      }\n\n      uint32_t node_start_byte = ts_node_start_byte(node);\n      if (\n        node_start_byte < first_finished_capture_byte ||\n        (\n          node_start_byte == first_finished_capture_byte &&\n          state->pattern_index < first_finished_pattern_index\n        )\n      ) {\n        first_finished_state = state;\n        first_finished_capture_byte = node_start_byte;\n        first_finished_pattern_index = state->pattern_index;\n      }\n      i++;\n    }\n\n    // If there is finished capture that is clearly before any unfinished\n    // capture, then return its match, and its capture index. Internally\n    // record the fact that the capture has been 'consumed'.\n    QueryState *state;\n    if (first_finished_state) {\n      state = first_finished_state;\n    } else if (first_unfinished_state_is_definite) {\n      state = array_get(&self->states, first_unfinished_state_index);\n    } else {\n      state = NULL;\n    }\n\n    if (state) {\n      if (state->id == UINT32_MAX) state->id = self->next_state_id++;\n      match->id = state->id;\n      match->pattern_index = state->pattern_index;\n      const CaptureList *captures = capture_list_pool_get(\n        &self->capture_list_pool,\n        state->capture_list_id\n      );\n      match->captures = captures->contents;\n      match->capture_count = captures->size;\n      *capture_index = state->consumed_capture_count;\n      state->consumed_capture_count++;\n      return true;\n    }\n\n    if (capture_list_pool_is_empty(&self->capture_list_pool) && found_unfinished_state) {\n      LOG(\n        \"  abandon state. index:%u, pattern:%u, offset:%u.\\n\",\n        first_unfinished_state_index,\n        first_unfinished_pattern_index,\n        first_unfinished_capture_byte\n      );\n      capture_list_pool_release(\n        &self->capture_list_pool,\n        array_get(&self->states, first_unfinished_state_index)->capture_list_id\n      );\n      array_erase(&self->states, first_unfinished_state_index);\n    }\n\n    // If there are no finished matches that are ready to be returned, then\n    // continue finding more matches.\n    if (\n      !ts_query_cursor__advance(self, true) &&\n      self->finished_states.size == 0\n    ) return false;\n  }\n}\n\nvoid ts_query_cursor_set_max_start_depth(\n  TSQueryCursor *self,\n  uint32_t max_start_depth\n) {\n  self->max_start_depth = max_start_depth;\n}\n\n#undef LOG\n",
    "#ifndef TREE_SITTER_UNICODE_H_\n#define TREE_SITTER_UNICODE_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <limits.h>\n#include <stdint.h>\n\n#define U_EXPORT\n#define U_EXPORT2\n#include \"unicode/utf8.h\"\n#include \"unicode/utf16.h\"\n#include \"portable/endian.h\"\n\n#define U16_NEXT_LE(s, i, length, c) UPRV_BLOCK_MACRO_BEGIN { \\\n    (c)=le16toh((s)[(i)++]); \\\n    if(U16_IS_LEAD(c)) { \\\n        uint16_t __c2; \\\n        if((i)!=(length) && U16_IS_TRAIL(__c2=(s)[(i)])) { \\\n            ++(i); \\\n            (c)=U16_GET_SUPPLEMENTARY((c), __c2); \\\n        } \\\n    } \\\n} UPRV_BLOCK_MACRO_END\n\n#define U16_NEXT_BE(s, i, length, c) UPRV_BLOCK_MACRO_BEGIN { \\\n    (c)=be16toh((s)[(i)++]); \\\n    if(U16_IS_LEAD(c)) { \\\n        uint16_t __c2; \\\n        if((i)!=(length) && U16_IS_TRAIL(__c2=(s)[(i)])) { \\\n            ++(i); \\\n            (c)=U16_GET_SUPPLEMENTARY((c), __c2); \\\n        } \\\n    } \\\n} UPRV_BLOCK_MACRO_END\n\nstatic const int32_t TS_DECODE_ERROR = U_SENTINEL;\n\nstatic inline uint32_t ts_decode_utf8(\n  const uint8_t *string,\n  uint32_t length,\n  int32_t *code_point\n) {\n  uint32_t i = 0;\n  U8_NEXT(string, i, length, *code_point);\n  return i;\n}\n\nstatic inline uint32_t ts_decode_utf16_le(\n  const uint8_t *string,\n  uint32_t length,\n  int32_t *code_point\n) {\n  uint32_t i = 0;\n  U16_NEXT_LE(((uint16_t *)string), i, length, *code_point);\n  return i * 2;\n}\n\nstatic inline uint32_t ts_decode_utf16_be(\n  const uint8_t *string,\n  uint32_t length,\n  int32_t *code_point\n) {\n  uint32_t i = 0;\n  U16_NEXT_BE(((uint16_t *)string), i, length, *code_point);\n  return i * 2;\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  // TREE_SITTER_UNICODE_H_\n",
    "#include \"tree_sitter/api.h\"\n#include \"./tree_cursor.h\"\n#include \"./language.h\"\n#include \"./tree.h\"\n\ntypedef struct {\n  Subtree parent;\n  const TSTree *tree;\n  Length position;\n  uint32_t child_index;\n  uint32_t structural_child_index;\n  uint32_t descendant_index;\n  const TSSymbol *alias_sequence;\n} CursorChildIterator;\n\n// CursorChildIterator\n\nstatic inline bool ts_tree_cursor_is_entry_visible(const TreeCursor *self, uint32_t index) {\n  TreeCursorEntry *entry = array_get(&self->stack, index);\n  if (index == 0 || ts_subtree_visible(*entry->subtree)) {\n    return true;\n  } else if (!ts_subtree_extra(*entry->subtree)) {\n    TreeCursorEntry *parent_entry = array_get(&self->stack, index - 1);\n    return ts_language_alias_at(\n      self->tree->language,\n      parent_entry->subtree->ptr->production_id,\n      entry->structural_child_index\n    );\n  } else {\n    return false;\n  }\n}\n\nstatic inline CursorChildIterator ts_tree_cursor_iterate_children(const TreeCursor *self) {\n  TreeCursorEntry *last_entry = array_back(&self->stack);\n  if (ts_subtree_child_count(*last_entry->subtree) == 0) {\n    return (CursorChildIterator) {NULL_SUBTREE, self->tree, length_zero(), 0, 0, 0, NULL};\n  }\n  const TSSymbol *alias_sequence = ts_language_alias_sequence(\n    self->tree->language,\n    last_entry->subtree->ptr->production_id\n  );\n\n  uint32_t descendant_index = last_entry->descendant_index;\n  if (ts_tree_cursor_is_entry_visible(self, self->stack.size - 1)) {\n    descendant_index += 1;\n  }\n\n  return (CursorChildIterator) {\n    .tree = self->tree,\n    .parent = *last_entry->subtree,\n    .position = last_entry->position,\n    .child_index = 0,\n    .structural_child_index = 0,\n    .descendant_index = descendant_index,\n    .alias_sequence = alias_sequence,\n  };\n}\n\nstatic inline bool ts_tree_cursor_child_iterator_next(\n  CursorChildIterator *self,\n  TreeCursorEntry *result,\n  bool *visible\n) {\n  if (!self->parent.ptr || self->child_index == self->parent.ptr->child_count) return false;\n  const Subtree *child = &ts_subtree_children(self->parent)[self->child_index];\n  *result = (TreeCursorEntry) {\n    .subtree = child,\n    .position = self->position,\n    .child_index = self->child_index,\n    .structural_child_index = self->structural_child_index,\n    .descendant_index = self->descendant_index,\n  };\n  *visible = ts_subtree_visible(*child);\n  bool extra = ts_subtree_extra(*child);\n  if (!extra) {\n    if (self->alias_sequence) {\n      *visible |= self->alias_sequence[self->structural_child_index];\n    }\n    self->structural_child_index++;\n  }\n\n  self->descendant_index += ts_subtree_visible_descendant_count(*child);\n  if (*visible) {\n    self->descendant_index += 1;\n  }\n\n  self->position = length_add(self->position, ts_subtree_size(*child));\n  self->child_index++;\n\n  if (self->child_index < self->parent.ptr->child_count) {\n    Subtree next_child = ts_subtree_children(self->parent)[self->child_index];\n    self->position = length_add(self->position, ts_subtree_padding(next_child));\n  }\n\n  return true;\n}\n\n// Return a position that, when `b` is added to it, yields `a`. This\n// can only be computed if `b` has zero rows. Otherwise, this function\n// returns `LENGTH_UNDEFINED`, and the caller needs to recompute\n// the position some other way.\nstatic inline Length length_backtrack(Length a, Length b) {\n  if (length_is_undefined(a) || b.extent.row != 0) {\n    return LENGTH_UNDEFINED;\n  }\n\n  Length result;\n  result.bytes = a.bytes - b.bytes;\n  result.extent.row = a.extent.row;\n  result.extent.column = a.extent.column - b.extent.column;\n  return result;\n}\n\nstatic inline bool ts_tree_cursor_child_iterator_previous(\n  CursorChildIterator *self,\n  TreeCursorEntry *result,\n  bool *visible\n) {\n  // this is mostly a reverse `ts_tree_cursor_child_iterator_next` taking into\n  // account unsigned underflow\n  if (!self->parent.ptr || (int8_t)self->child_index == -1) return false;\n  const Subtree *child = &ts_subtree_children(self->parent)[self->child_index];\n  *result = (TreeCursorEntry) {\n    .subtree = child,\n    .position = self->position,\n    .child_index = self->child_index,\n    .structural_child_index = self->structural_child_index,\n  };\n  *visible = ts_subtree_visible(*child);\n  bool extra = ts_subtree_extra(*child);\n\n  self->position = length_backtrack(self->position, ts_subtree_padding(*child));\n  self->child_index--;\n\n  if (!extra && self->alias_sequence) {\n    *visible |= self->alias_sequence[self->structural_child_index];\n    if (self->structural_child_index > 0) {\n      self->structural_child_index--;\n    }\n  }\n\n  // unsigned can underflow so compare it to child_count\n  if (self->child_index < self->parent.ptr->child_count) {\n    Subtree previous_child = ts_subtree_children(self->parent)[self->child_index];\n    Length size = ts_subtree_size(previous_child);\n    self->position = length_backtrack(self->position, size);\n  }\n\n  return true;\n}\n\n// TSTreeCursor - lifecycle\n\nTSTreeCursor ts_tree_cursor_new(TSNode node) {\n  TSTreeCursor self = {NULL, NULL, {0, 0, 0}};\n  ts_tree_cursor_init((TreeCursor *)&self, node);\n  return self;\n}\n\nvoid ts_tree_cursor_reset(TSTreeCursor *_self, TSNode node) {\n  ts_tree_cursor_init((TreeCursor *)_self, node);\n}\n\nvoid ts_tree_cursor_init(TreeCursor *self, TSNode node) {\n  self->tree = node.tree;\n  self->root_alias_symbol = node.context[3];\n  array_clear(&self->stack);\n  array_push(&self->stack, ((TreeCursorEntry) {\n    .subtree = (const Subtree *)node.id,\n    .position = {\n      ts_node_start_byte(node),\n      ts_node_start_point(node)\n    },\n    .child_index = 0,\n    .structural_child_index = 0,\n    .descendant_index = 0,\n  }));\n}\n\nvoid ts_tree_cursor_delete(TSTreeCursor *_self) {\n  TreeCursor *self = (TreeCursor *)_self;\n  array_delete(&self->stack);\n}\n\n// TSTreeCursor - walking the tree\n\nTreeCursorStep ts_tree_cursor_goto_first_child_internal(TSTreeCursor *_self) {\n  TreeCursor *self = (TreeCursor *)_self;\n  bool visible;\n  TreeCursorEntry entry;\n  CursorChildIterator iterator = ts_tree_cursor_iterate_children(self);\n  while (ts_tree_cursor_child_iterator_next(&iterator, &entry, &visible)) {\n    if (visible) {\n      array_push(&self->stack, entry);\n      return TreeCursorStepVisible;\n    }\n    if (ts_subtree_visible_child_count(*entry.subtree) > 0) {\n      array_push(&self->stack, entry);\n      return TreeCursorStepHidden;\n    }\n  }\n  return TreeCursorStepNone;\n}\n\nbool ts_tree_cursor_goto_first_child(TSTreeCursor *self) {\n  for (;;) {\n    switch (ts_tree_cursor_goto_first_child_internal(self)) {\n      case TreeCursorStepHidden:\n        continue;\n      case TreeCursorStepVisible:\n        return true;\n      default:\n        return false;\n    }\n  }\n}\n\nTreeCursorStep ts_tree_cursor_goto_last_child_internal(TSTreeCursor *_self) {\n  TreeCursor *self = (TreeCursor *)_self;\n  bool visible;\n  TreeCursorEntry entry;\n  CursorChildIterator iterator = ts_tree_cursor_iterate_children(self);\n  if (!iterator.parent.ptr || iterator.parent.ptr->child_count == 0) return TreeCursorStepNone;\n\n  TreeCursorEntry last_entry = {0};\n  TreeCursorStep last_step = TreeCursorStepNone;\n  while (ts_tree_cursor_child_iterator_next(&iterator, &entry, &visible)) {\n    if (visible) {\n      last_entry = entry;\n      last_step = TreeCursorStepVisible;\n    }\n    else if (ts_subtree_visible_child_count(*entry.subtree) > 0) {\n      last_entry = entry;\n      last_step = TreeCursorStepHidden;\n    }\n  }\n  if (last_entry.subtree) {\n    array_push(&self->stack, last_entry);\n    return last_step;\n  }\n\n  return TreeCursorStepNone;\n}\n\nbool ts_tree_cursor_goto_last_child(TSTreeCursor *self) {\n  for (;;) {\n    switch (ts_tree_cursor_goto_last_child_internal(self)) {\n      case TreeCursorStepHidden:\n        continue;\n      case TreeCursorStepVisible:\n        return true;\n      default:\n        return false;\n    }\n  }\n}\n\nstatic inline int64_t ts_tree_cursor_goto_first_child_for_byte_and_point(\n  TSTreeCursor *_self,\n  uint32_t goal_byte,\n  TSPoint goal_point\n) {\n  TreeCursor *self = (TreeCursor *)_self;\n  uint32_t initial_size = self->stack.size;\n  uint32_t visible_child_index = 0;\n\n  bool did_descend;\n  do {\n    did_descend = false;\n\n    bool visible;\n    TreeCursorEntry entry;\n    CursorChildIterator iterator = ts_tree_cursor_iterate_children(self);\n    while (ts_tree_cursor_child_iterator_next(&iterator, &entry, &visible)) {\n      Length entry_end = length_add(entry.position, ts_subtree_size(*entry.subtree));\n      bool at_goal = entry_end.bytes > goal_byte && point_gt(entry_end.extent, goal_point);\n      uint32_t visible_child_count = ts_subtree_visible_child_count(*entry.subtree);\n      if (at_goal) {\n        if (visible) {\n          array_push(&self->stack, entry);\n          return visible_child_index;\n        }\n        if (visible_child_count > 0) {\n          array_push(&self->stack, entry);\n          did_descend = true;\n          break;\n        }\n      } else if (visible) {\n        visible_child_index++;\n      } else {\n        visible_child_index += visible_child_count;\n      }\n    }\n  } while (did_descend);\n\n  self->stack.size = initial_size;\n  return -1;\n}\n\nint64_t ts_tree_cursor_goto_first_child_for_byte(TSTreeCursor *self, uint32_t goal_byte) {\n  return ts_tree_cursor_goto_first_child_for_byte_and_point(self, goal_byte, POINT_ZERO);\n}\n\nint64_t ts_tree_cursor_goto_first_child_for_point(TSTreeCursor *self, TSPoint goal_point) {\n  return ts_tree_cursor_goto_first_child_for_byte_and_point(self, 0, goal_point);\n}\n\nTreeCursorStep ts_tree_cursor_goto_sibling_internal(\n  TSTreeCursor *_self,\n  bool (*advance)(CursorChildIterator *, TreeCursorEntry *, bool *)\n) {\n  TreeCursor *self = (TreeCursor *)_self;\n  uint32_t initial_size = self->stack.size;\n\n  while (self->stack.size > 1) {\n    TreeCursorEntry entry = array_pop(&self->stack);\n    CursorChildIterator iterator = ts_tree_cursor_iterate_children(self);\n    iterator.child_index = entry.child_index;\n    iterator.structural_child_index = entry.structural_child_index;\n    iterator.position = entry.position;\n    iterator.descendant_index = entry.descendant_index;\n\n    bool visible = false;\n    advance(&iterator, &entry, &visible);\n    if (visible && self->stack.size + 1 < initial_size) break;\n\n    while (advance(&iterator, &entry, &visible)) {\n      if (visible) {\n        array_push(&self->stack, entry);\n        return TreeCursorStepVisible;\n      }\n\n      if (ts_subtree_visible_child_count(*entry.subtree)) {\n        array_push(&self->stack, entry);\n        return TreeCursorStepHidden;\n      }\n    }\n  }\n\n  self->stack.size = initial_size;\n  return TreeCursorStepNone;\n}\n\nTreeCursorStep ts_tree_cursor_goto_next_sibling_internal(TSTreeCursor *_self) {\n  return ts_tree_cursor_goto_sibling_internal(_self, ts_tree_cursor_child_iterator_next);\n}\n\nbool ts_tree_cursor_goto_next_sibling(TSTreeCursor *self) {\n  switch (ts_tree_cursor_goto_next_sibling_internal(self)) {\n    case TreeCursorStepHidden:\n      ts_tree_cursor_goto_first_child(self);\n      return true;\n    case TreeCursorStepVisible:\n      return true;\n    default:\n      return false;\n  }\n}\n\nTreeCursorStep ts_tree_cursor_goto_previous_sibling_internal(TSTreeCursor *_self) {\n  // since subtracting across row loses column information, we may have to\n  // restore it\n  TreeCursor *self = (TreeCursor *)_self;\n\n  // for that, save current position before traversing\n  TreeCursorStep step = ts_tree_cursor_goto_sibling_internal(\n      _self, ts_tree_cursor_child_iterator_previous);\n  if (step == TreeCursorStepNone)\n    return step;\n\n  // if length is already valid, there's no need to recompute it\n  if (!length_is_undefined(array_back(&self->stack)->position))\n    return step;\n\n  // restore position from the parent node\n  const TreeCursorEntry *parent = array_get(&self->stack, self->stack.size - 2);\n  Length position = parent->position;\n  uint32_t child_index = array_back(&self->stack)->child_index;\n  const Subtree *children = ts_subtree_children((*(parent->subtree)));\n\n  if (child_index > 0) {\n    // skip first child padding since its position should match the position of the parent\n    position = length_add(position, ts_subtree_size(children[0]));\n    for (uint32_t i = 1; i < child_index; ++i) {\n      position = length_add(position, ts_subtree_total_size(children[i]));\n    }\n    position = length_add(position, ts_subtree_padding(children[child_index]));\n  }\n\n  array_back(&self->stack)->position = position;\n\n  return step;\n}\n\nbool ts_tree_cursor_goto_previous_sibling(TSTreeCursor *self) {\n  switch (ts_tree_cursor_goto_previous_sibling_internal(self)) {\n    case TreeCursorStepHidden:\n      ts_tree_cursor_goto_last_child(self);\n      return true;\n    case TreeCursorStepVisible:\n      return true;\n    default:\n      return false;\n  }\n}\n\nbool ts_tree_cursor_goto_parent(TSTreeCursor *_self) {\n  TreeCursor *self = (TreeCursor *)_self;\n  for (unsigned i = self->stack.size - 2; i + 1 > 0; i--) {\n    if (ts_tree_cursor_is_entry_visible(self, i)) {\n      self->stack.size = i + 1;\n      return true;\n    }\n  }\n  return false;\n}\n\nvoid ts_tree_cursor_goto_descendant(\n  TSTreeCursor *_self,\n  uint32_t goal_descendant_index\n) {\n  TreeCursor *self = (TreeCursor *)_self;\n\n  // Ascend to the lowest ancestor that contains the goal node.\n  for (;;) {\n    uint32_t i = self->stack.size - 1;\n    TreeCursorEntry *entry = array_get(&self->stack, i);\n    uint32_t next_descendant_index =\n      entry->descendant_index +\n      (ts_tree_cursor_is_entry_visible(self, i) ? 1 : 0) +\n      ts_subtree_visible_descendant_count(*entry->subtree);\n    if (\n      (entry->descendant_index <= goal_descendant_index) &&\n      (next_descendant_index > goal_descendant_index)\n    ) {\n      break;\n    } else if (self->stack.size <= 1) {\n      return;\n    } else {\n      self->stack.size--;\n    }\n  }\n\n  // Descend to the goal node.\n  bool did_descend = true;\n  do {\n    did_descend = false;\n    bool visible;\n    TreeCursorEntry entry;\n    CursorChildIterator iterator = ts_tree_cursor_iterate_children(self);\n    if (iterator.descendant_index > goal_descendant_index) {\n      return;\n    }\n\n    while (ts_tree_cursor_child_iterator_next(&iterator, &entry, &visible)) {\n      if (iterator.descendant_index > goal_descendant_index) {\n        array_push(&self->stack, entry);\n        if (visible && entry.descendant_index == goal_descendant_index) {\n          return;\n        } else {\n          did_descend = true;\n          break;\n        }\n      }\n    }\n  } while (did_descend);\n}\n\nuint32_t ts_tree_cursor_current_descendant_index(const TSTreeCursor *_self) {\n  const TreeCursor *self = (const TreeCursor *)_self;\n  TreeCursorEntry *last_entry = array_back(&self->stack);\n  return last_entry->descendant_index;\n}\n\nTSNode ts_tree_cursor_current_node(const TSTreeCursor *_self) {\n  const TreeCursor *self = (const TreeCursor *)_self;\n  TreeCursorEntry *last_entry = array_back(&self->stack);\n  bool is_extra = ts_subtree_extra(*last_entry->subtree);\n  TSSymbol alias_symbol = is_extra ? 0 : self->root_alias_symbol;\n  if (self->stack.size > 1 && !is_extra) {\n    TreeCursorEntry *parent_entry = array_get(&self->stack, self->stack.size - 2);\n    alias_symbol = ts_language_alias_at(\n      self->tree->language,\n      parent_entry->subtree->ptr->production_id,\n      last_entry->structural_child_index\n    );\n  }\n  return ts_node_new(\n    self->tree,\n    last_entry->subtree,\n    last_entry->position,\n    alias_symbol\n  );\n}\n\n// Private - Get various facts about the current node that are needed\n// when executing tree queries.\nvoid ts_tree_cursor_current_status(\n  const TSTreeCursor *_self,\n  TSFieldId *field_id,\n  bool *has_later_siblings,\n  bool *has_later_named_siblings,\n  bool *can_have_later_siblings_with_this_field,\n  TSSymbol *supertypes,\n  unsigned *supertype_count\n) {\n  const TreeCursor *self = (const TreeCursor *)_self;\n  unsigned max_supertypes = *supertype_count;\n  *field_id = 0;\n  *supertype_count = 0;\n  *has_later_siblings = false;\n  *has_later_named_siblings = false;\n  *can_have_later_siblings_with_this_field = false;\n\n  // Walk up the tree, visiting the current node and its invisible ancestors,\n  // because fields can refer to nodes through invisible *wrapper* nodes,\n  for (unsigned i = self->stack.size - 1; i > 0; i--) {\n    TreeCursorEntry *entry = array_get(&self->stack, i);\n    TreeCursorEntry *parent_entry = array_get(&self->stack, i - 1);\n\n    const TSSymbol *alias_sequence = ts_language_alias_sequence(\n      self->tree->language,\n      parent_entry->subtree->ptr->production_id\n    );\n\n    #define subtree_symbol(subtree, structural_child_index) \\\n      ((                                                    \\\n        !ts_subtree_extra(subtree) &&                       \\\n        alias_sequence &&                                   \\\n        alias_sequence[structural_child_index]              \\\n      ) ?                                                   \\\n        alias_sequence[structural_child_index] :            \\\n        ts_subtree_symbol(subtree))\n\n    // Stop walking up when a visible ancestor is found.\n    TSSymbol entry_symbol = subtree_symbol(\n      *entry->subtree,\n      entry->structural_child_index\n    );\n    TSSymbolMetadata entry_metadata = ts_language_symbol_metadata(\n      self->tree->language,\n      entry_symbol\n    );\n    if (i != self->stack.size - 1 && entry_metadata.visible) break;\n\n    // Record any supertypes\n    if (entry_metadata.supertype && *supertype_count < max_supertypes) {\n      supertypes[*supertype_count] = entry_symbol;\n      (*supertype_count)++;\n    }\n\n    // Determine if the current node has later siblings.\n    if (!*has_later_siblings) {\n      unsigned sibling_count = parent_entry->subtree->ptr->child_count;\n      unsigned structural_child_index = entry->structural_child_index;\n      if (!ts_subtree_extra(*entry->subtree)) structural_child_index++;\n      for (unsigned j = entry->child_index + 1; j < sibling_count; j++) {\n        Subtree sibling = ts_subtree_children(*parent_entry->subtree)[j];\n        TSSymbolMetadata sibling_metadata = ts_language_symbol_metadata(\n          self->tree->language,\n          subtree_symbol(sibling, structural_child_index)\n        );\n        if (sibling_metadata.visible) {\n          *has_later_siblings = true;\n          if (*has_later_named_siblings) break;\n          if (sibling_metadata.named) {\n            *has_later_named_siblings = true;\n            break;\n          }\n        } else if (ts_subtree_visible_child_count(sibling) > 0) {\n          *has_later_siblings = true;\n          if (*has_later_named_siblings) break;\n          if (sibling.ptr->named_child_count > 0) {\n            *has_later_named_siblings = true;\n            break;\n          }\n        }\n        if (!ts_subtree_extra(sibling)) structural_child_index++;\n      }\n    }\n\n    #undef subtree_symbol\n\n    if (!ts_subtree_extra(*entry->subtree)) {\n      const TSFieldMapEntry *field_map, *field_map_end;\n      ts_language_field_map(\n        self->tree->language,\n        parent_entry->subtree->ptr->production_id,\n        &field_map, &field_map_end\n      );\n\n      // Look for a field name associated with the current node.\n      if (!*field_id) {\n        for (const TSFieldMapEntry *map = field_map; map < field_map_end; map++) {\n          if (!map->inherited && map->child_index == entry->structural_child_index) {\n            *field_id = map->field_id;\n            break;\n          }\n        }\n      }\n\n      // Determine if the current node can have later siblings with the same field name.\n      if (*field_id) {\n        for (const TSFieldMapEntry *map = field_map; map < field_map_end; map++) {\n          if (\n            map->field_id == *field_id &&\n            map->child_index > entry->structural_child_index\n          ) {\n            *can_have_later_siblings_with_this_field = true;\n            break;\n          }\n        }\n      }\n    }\n  }\n}\n\nuint32_t ts_tree_cursor_current_depth(const TSTreeCursor *_self) {\n  const TreeCursor *self = (const TreeCursor *)_self;\n  uint32_t depth = 0;\n  for (unsigned i = 1; i < self->stack.size; i++) {\n    if (ts_tree_cursor_is_entry_visible(self, i)) {\n      depth++;\n    }\n  }\n  return depth;\n}\n\nTSNode ts_tree_cursor_parent_node(const TSTreeCursor *_self) {\n  const TreeCursor *self = (const TreeCursor *)_self;\n  for (int i = (int)self->stack.size - 2; i >= 0; i--) {\n    TreeCursorEntry *entry = array_get(&self->stack, i);\n    bool is_visible = true;\n    TSSymbol alias_symbol = 0;\n    if (i > 0) {\n      TreeCursorEntry *parent_entry = array_get(&self->stack, i - 1);\n      alias_symbol = ts_language_alias_at(\n        self->tree->language,\n        parent_entry->subtree->ptr->production_id,\n        entry->structural_child_index\n      );\n      is_visible = (alias_symbol != 0) || ts_subtree_visible(*entry->subtree);\n    }\n    if (is_visible) {\n      return ts_node_new(\n        self->tree,\n        entry->subtree,\n        entry->position,\n        alias_symbol\n      );\n    }\n  }\n  return ts_node_new(NULL, NULL, length_zero(), 0);\n}\n\nTSFieldId ts_tree_cursor_current_field_id(const TSTreeCursor *_self) {\n  const TreeCursor *self = (const TreeCursor *)_self;\n\n  // Walk up the tree, visiting the current node and its invisible ancestors.\n  for (unsigned i = self->stack.size - 1; i > 0; i--) {\n    TreeCursorEntry *entry = array_get(&self->stack, i);\n    TreeCursorEntry *parent_entry = array_get(&self->stack, i - 1);\n\n    // Stop walking up when another visible node is found.\n    if (\n      i != self->stack.size - 1 &&\n      ts_tree_cursor_is_entry_visible(self, i)\n    ) break;\n\n    if (ts_subtree_extra(*entry->subtree)) break;\n\n    const TSFieldMapEntry *field_map, *field_map_end;\n    ts_language_field_map(\n      self->tree->language,\n      parent_entry->subtree->ptr->production_id,\n      &field_map, &field_map_end\n    );\n    for (const TSFieldMapEntry *map = field_map; map < field_map_end; map++) {\n      if (!map->inherited && map->child_index == entry->structural_child_index) {\n        return map->field_id;\n      }\n    }\n  }\n  return 0;\n}\n\nconst char *ts_tree_cursor_current_field_name(const TSTreeCursor *_self) {\n  TSFieldId id = ts_tree_cursor_current_field_id(_self);\n  if (id) {\n    const TreeCursor *self = (const TreeCursor *)_self;\n    return self->tree->language->field_names[id];\n  } else {\n    return NULL;\n  }\n}\n\nTSTreeCursor ts_tree_cursor_copy(const TSTreeCursor *_cursor) {\n  const TreeCursor *cursor = (const TreeCursor *)_cursor;\n  TSTreeCursor res = {NULL, NULL, {0, 0}};\n  TreeCursor *copy = (TreeCursor *)&res;\n  copy->tree = cursor->tree;\n  copy->root_alias_symbol = cursor->root_alias_symbol;\n  array_init(&copy->stack);\n  array_push_all(&copy->stack, &cursor->stack);\n  return res;\n}\n\nvoid ts_tree_cursor_reset_to(TSTreeCursor *_dst, const TSTreeCursor *_src) {\n  const TreeCursor *cursor = (const TreeCursor *)_src;\n  TreeCursor *copy = (TreeCursor *)_dst;\n  copy->tree = cursor->tree;\n  copy->root_alias_symbol = cursor->root_alias_symbol;\n  array_clear(&copy->stack);\n  array_push_all(&copy->stack, &cursor->stack);\n}\n",
    "#ifndef TREE_SITTER_TREE_CURSOR_H_\n#define TREE_SITTER_TREE_CURSOR_H_\n\n#include \"./subtree.h\"\n\ntypedef struct {\n  const Subtree *subtree;\n  Length position;\n  uint32_t child_index;\n  uint32_t structural_child_index;\n  uint32_t descendant_index;\n} TreeCursorEntry;\n\ntypedef struct {\n  const TSTree *tree;\n  Array(TreeCursorEntry) stack;\n  TSSymbol root_alias_symbol;\n} TreeCursor;\n\ntypedef enum {\n  TreeCursorStepNone,\n  TreeCursorStepHidden,\n  TreeCursorStepVisible,\n} TreeCursorStep;\n\nvoid ts_tree_cursor_init(TreeCursor *self, TSNode node);\nvoid ts_tree_cursor_current_status(\n  const TSTreeCursor *_self,\n  TSFieldId *field_id,\n  bool *has_later_siblings,\n  bool *has_later_named_siblings,\n  bool *can_have_later_siblings_with_this_field,\n  TSSymbol *supertypes,\n  unsigned *supertype_count\n);\n\nTreeCursorStep ts_tree_cursor_goto_first_child_internal(TSTreeCursor *_self);\nTreeCursorStep ts_tree_cursor_goto_next_sibling_internal(TSTreeCursor *_self);\n\nstatic inline Subtree ts_tree_cursor_current_subtree(const TSTreeCursor *_self) {\n  const TreeCursor *self = (const TreeCursor *)_self;\n  TreeCursorEntry *last_entry = array_back(&self->stack);\n  return *last_entry->subtree;\n}\n\nTSNode ts_tree_cursor_parent_node(const TSTreeCursor *_self);\n\n#endif  // TREE_SITTER_TREE_CURSOR_H_\n",
    "#include \"array.h\"\n#include \"point.h\"\n\n#include <emscripten.h>\n#include <tree_sitter/api.h>\n\n/*****************************/\n/* Section - Data marshaling */\n/*****************************/\n\nstatic const uint32_t INPUT_BUFFER_SIZE = 10 * 1024;\n\nconst void *TRANSFER_BUFFER[12] = {\n  NULL, NULL, NULL, NULL,\n  NULL, NULL, NULL, NULL,\n  NULL, NULL, NULL, NULL,\n};\n\nstatic const int SIZE_OF_CURSOR = 4;\nstatic const int SIZE_OF_NODE = 5;\nstatic const int SIZE_OF_POINT = 2;\nstatic const int SIZE_OF_RANGE = 2 + (2 * SIZE_OF_POINT);\nstatic const int SIZE_OF_CAPTURE = 1 + SIZE_OF_NODE;\n\nvoid *ts_init() {\n  TRANSFER_BUFFER[0] = (const void *)TREE_SITTER_LANGUAGE_VERSION;\n  TRANSFER_BUFFER[1] = (const void *)TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION;\n  return (void*)TRANSFER_BUFFER;\n}\n\nstatic uint32_t code_unit_to_byte(uint32_t unit) {\n  return unit << 1;\n}\n\nstatic uint32_t byte_to_code_unit(uint32_t byte) {\n  return byte >> 1;\n}\n\nstatic inline void marshal_node(const void **buffer, TSNode node) {\n  buffer[0] = node.id;\n  buffer[1] = (const void *)byte_to_code_unit(node.context[0]);\n  buffer[2] = (const void *)node.context[1];\n  buffer[3] = (const void *)byte_to_code_unit(node.context[2]);\n  buffer[4] = (const void *)node.context[3];\n}\n\nstatic inline TSNode unmarshal_node_at(const TSTree *tree, uint32_t index) {\n  TSNode node;\n  const void **buffer = TRANSFER_BUFFER + index * SIZE_OF_NODE;\n  node.id = buffer[0];\n  node.context[0] = code_unit_to_byte((uint32_t)buffer[1]);\n  node.context[1] = (uint32_t)buffer[2];\n  node.context[2] = code_unit_to_byte((uint32_t)buffer[3]);\n  node.context[3] = (uint32_t)buffer[4];\n  node.tree = tree;\n  return node;\n}\n\nstatic inline TSNode unmarshal_node(const TSTree *tree) {\n  return unmarshal_node_at(tree, 0);\n}\n\nstatic inline void marshal_cursor(const TSTreeCursor *cursor) {\n  TRANSFER_BUFFER[0] = cursor->id;\n  TRANSFER_BUFFER[1] = (const void *)cursor->context[0];\n  TRANSFER_BUFFER[2] = (const void *)cursor->context[1];\n  TRANSFER_BUFFER[3] = (const void *)cursor->context[2];\n}\n\nstatic inline TSTreeCursor unmarshal_cursor(const void **buffer, const TSTree *tree) {\n  TSTreeCursor cursor;\n  cursor.id = buffer[0];\n  cursor.context[0] = (uint32_t)buffer[1];\n  cursor.context[1] = (uint32_t)buffer[2];\n  cursor.context[2] = (uint32_t)buffer[3];\n  cursor.tree = tree;\n  return cursor;\n}\n\nstatic void marshal_point(TSPoint point) {\n  TRANSFER_BUFFER[0] = (const void *)point.row;\n  TRANSFER_BUFFER[1] = (const void *)byte_to_code_unit(point.column);\n}\n\nstatic TSPoint unmarshal_point(const void **address) {\n  TSPoint point;\n  point.row = (uint32_t)address[0];\n  point.column = code_unit_to_byte((uint32_t)address[1]);\n  return point;\n}\n\nstatic void marshal_range(TSRange *range) {\n  range->start_byte = byte_to_code_unit(range->start_byte);\n  range->end_byte = byte_to_code_unit(range->end_byte);\n  range->start_point.column = byte_to_code_unit(range->start_point.column);\n  range->end_point.column = byte_to_code_unit(range->end_point.column);\n}\n\nstatic void unmarshal_range(TSRange *range) {\n  range->start_byte = code_unit_to_byte(range->start_byte);\n  range->end_byte = code_unit_to_byte(range->end_byte);\n  range->start_point.column = code_unit_to_byte(range->start_point.column);\n  range->end_point.column = code_unit_to_byte(range->end_point.column);\n}\n\nstatic TSInputEdit unmarshal_edit() {\n  TSInputEdit edit;\n  const void **address = TRANSFER_BUFFER;\n  edit.start_point = unmarshal_point(address); address += SIZE_OF_POINT;\n  edit.old_end_point = unmarshal_point(address); address += SIZE_OF_POINT;\n  edit.new_end_point = unmarshal_point(address); address += SIZE_OF_POINT;\n  edit.start_byte = code_unit_to_byte((uint32_t)*address); address += 1;\n  edit.old_end_byte = code_unit_to_byte((uint32_t)*address); address += 1;\n  edit.new_end_byte = code_unit_to_byte((uint32_t)*address); address += 1;\n  return edit;\n}\n\nstatic void marshal_language_metadata(const TSLanguageMetadata *metadata) {\n  if (metadata == NULL) {\n    TRANSFER_BUFFER[0] = 0;\n    return;\n  }\n  TRANSFER_BUFFER[0] = (const void*)3;\n  TRANSFER_BUFFER[1] = (const void*)(uint32_t)metadata->major_version;\n  TRANSFER_BUFFER[2] = (const void*)(uint32_t)metadata->minor_version;\n  TRANSFER_BUFFER[3] = (const void*)(uint32_t)metadata->patch_version;\n}\n\n/********************/\n/* Section - Parser */\n/********************/\n\nextern void tree_sitter_parse_callback(\n  char *input_buffer,\n  uint32_t index,\n  uint32_t row,\n  uint32_t column,\n  uint32_t *length_read\n);\n\nextern void tree_sitter_log_callback(\n  bool is_lex_message,\n  const char *message\n);\n\nextern bool tree_sitter_progress_callback(\n  uint32_t current_offset,\n  bool has_error\n);\n\nextern bool tree_sitter_query_progress_callback(\n  uint32_t current_offset\n);\n\nstatic const char *call_parse_callback(\n  void *payload,\n  uint32_t byte,\n  TSPoint position,\n  uint32_t *bytes_read\n) {\n  char *buffer = (char *)payload;\n  tree_sitter_parse_callback(\n    buffer,\n    byte_to_code_unit(byte),\n    position.row,\n    byte_to_code_unit(position.column),\n    bytes_read\n  );\n  *bytes_read = code_unit_to_byte(*bytes_read);\n  if (*bytes_read >= INPUT_BUFFER_SIZE) {\n    *bytes_read = INPUT_BUFFER_SIZE - 2;\n  }\n  return buffer;\n}\n\nstatic void call_log_callback(\n  void *payload,\n  TSLogType log_type,\n  const char *message\n) {\n  tree_sitter_log_callback(log_type == TSLogTypeLex, message);\n}\n\nstatic bool progress_callback(\n  TSParseState *state\n) {\n  return tree_sitter_progress_callback(state->current_byte_offset, state->has_error);\n}\n\nstatic bool query_progress_callback(\n  TSQueryCursorState *state\n) {\n  return tree_sitter_query_progress_callback(state->current_byte_offset);\n}\n\nvoid ts_parser_new_wasm() {\n  TSParser *parser = ts_parser_new();\n  char *input_buffer = calloc(INPUT_BUFFER_SIZE, sizeof(char));\n  TRANSFER_BUFFER[0] = parser;\n  TRANSFER_BUFFER[1] = input_buffer;\n}\n\nvoid ts_parser_enable_logger_wasm(TSParser *self, bool should_log) {\n  TSLogger logger = {self, should_log ? call_log_callback : NULL};\n  ts_parser_set_logger(self, logger);\n}\n\nTSTree *ts_parser_parse_wasm(\n  TSParser *self,\n  char *input_buffer,\n  const TSTree *old_tree,\n  TSRange *ranges,\n  uint32_t range_count\n) {\n  TSInput input = {\n    input_buffer,\n    call_parse_callback,\n    TSInputEncodingUTF16LE,\n    NULL,\n  };\n  if (range_count) {\n    for (unsigned i = 0; i < range_count; i++) {\n      unmarshal_range(&ranges[i]);\n    }\n    ts_parser_set_included_ranges(self, ranges, range_count);\n    free(ranges);\n  } else {\n    ts_parser_set_included_ranges(self, NULL, 0);\n  }\n\n  TSParseOptions options = {.payload = NULL, .progress_callback = progress_callback};\n\n  return ts_parser_parse_with_options(self, old_tree, input, options);\n}\n\nvoid ts_parser_included_ranges_wasm(TSParser *self) {\n  uint32_t range_count = 0;\n  const TSRange *ranges = ts_parser_included_ranges(self, &range_count);\n  TSRange *copied_ranges = malloc(sizeof(TSRange) * range_count);\n  memcpy(copied_ranges, ranges, sizeof(TSRange) * range_count);\n  for (unsigned i = 0; i < range_count; i++) {\n    marshal_range(&copied_ranges[i]);\n  }\n  TRANSFER_BUFFER[0] = range_count ? (const void *)range_count : NULL;\n  TRANSFER_BUFFER[1] = copied_ranges;\n}\n\n/**********************/\n/* Section - Language */\n/**********************/\n\nint ts_language_type_is_named_wasm(const TSLanguage *self, TSSymbol typeId) {\n  const TSSymbolType symbolType = ts_language_symbol_type(self, typeId);\n  return symbolType == TSSymbolTypeRegular;\n}\n\nint ts_language_type_is_visible_wasm(const TSLanguage *self, TSSymbol typeId) {\n  const TSSymbolType symbolType = ts_language_symbol_type(self, typeId);\n  return symbolType <= TSSymbolTypeAnonymous;\n}\n\nvoid ts_language_metadata_wasm(const TSLanguage *self) {\n  const TSLanguageMetadata *metadata = ts_language_metadata(self);\n  marshal_language_metadata(metadata);\n}\n\nvoid ts_language_supertypes_wasm(const TSLanguage *self) {\n  uint32_t length;\n  const TSSymbol *supertypes = ts_language_supertypes(self, &length);\n  TRANSFER_BUFFER[0] = (const void *)length;\n  TRANSFER_BUFFER[1] = supertypes;\n}\n\nvoid ts_language_subtypes_wasm(const TSLanguage *self, TSSymbol supertype) {\n  uint32_t length;\n  const TSSymbol *subtypes = ts_language_subtypes(self, supertype, &length);\n  TRANSFER_BUFFER[0] = (const void *)length;\n  TRANSFER_BUFFER[1] = subtypes;\n}\n\n/******************/\n/* Section - Tree */\n/******************/\n\nvoid ts_tree_root_node_wasm(const TSTree *tree) {\n  marshal_node(TRANSFER_BUFFER, ts_tree_root_node(tree));\n}\n\nvoid ts_tree_root_node_with_offset_wasm(const TSTree *tree) {\n  // read int and point from transfer buffer\n  const void **address = TRANSFER_BUFFER + SIZE_OF_NODE;\n  uint32_t offset = code_unit_to_byte((uint32_t)address[0]);\n  TSPoint extent = unmarshal_point(address + 1);\n  TSNode node = ts_tree_root_node_with_offset(tree, offset, extent);\n  marshal_node(TRANSFER_BUFFER, node);\n}\n\nvoid ts_tree_edit_wasm(TSTree *tree) {\n  TSInputEdit edit = unmarshal_edit();\n  ts_tree_edit(tree, &edit);\n}\n\nvoid ts_tree_included_ranges_wasm(const TSTree *tree) {\n  uint32_t range_count;\n  TSRange *ranges = ts_tree_included_ranges(tree, &range_count);\n  for (unsigned i = 0; i < range_count; i++) {\n    marshal_range(&ranges[i]);\n  }\n  TRANSFER_BUFFER[0] = (range_count ? (const void *)range_count : NULL);\n  TRANSFER_BUFFER[1] = (const void *)ranges;\n}\n\nvoid ts_tree_get_changed_ranges_wasm(TSTree *tree, TSTree *other) {\n  unsigned range_count;\n  TSRange *ranges = ts_tree_get_changed_ranges(tree, other, &range_count);\n  for (unsigned i = 0; i < range_count; i++) {\n    marshal_range(&ranges[i]);\n  }\n  TRANSFER_BUFFER[0] = (const void *)range_count;\n  TRANSFER_BUFFER[1] = (const void *)ranges;\n}\n\n/************************/\n/* Section - TreeCursor */\n/************************/\n\nvoid ts_tree_cursor_new_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  TSTreeCursor cursor = ts_tree_cursor_new(node);\n  marshal_cursor(&cursor);\n}\n\nvoid ts_tree_cursor_copy_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  TSTreeCursor copy = ts_tree_cursor_copy(&cursor);\n  marshal_cursor(&copy);\n}\n\nvoid ts_tree_cursor_delete_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  ts_tree_cursor_delete(&cursor);\n}\n\nvoid ts_tree_cursor_reset_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  TSTreeCursor cursor = unmarshal_cursor(&TRANSFER_BUFFER[SIZE_OF_NODE], tree);\n  ts_tree_cursor_reset(&cursor, node);\n  marshal_cursor(&cursor);\n}\n\nvoid ts_tree_cursor_reset_to_wasm(const TSTree *_dst, const TSTree *_src) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, _dst);\n  TSTreeCursor src = unmarshal_cursor(&TRANSFER_BUFFER[SIZE_OF_CURSOR], _src);\n  ts_tree_cursor_reset_to(&cursor, &src);\n  marshal_cursor(&cursor);\n}\n\nbool ts_tree_cursor_goto_first_child_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  bool result = ts_tree_cursor_goto_first_child(&cursor);\n  marshal_cursor(&cursor);\n  return result;\n}\n\nbool ts_tree_cursor_goto_last_child_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  bool result = ts_tree_cursor_goto_last_child(&cursor);\n  marshal_cursor(&cursor);\n  return result;\n}\n\nbool ts_tree_cursor_goto_first_child_for_index_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  const void **address = TRANSFER_BUFFER + 3;\n  uint32_t index = code_unit_to_byte((uint32_t)address[0]);\n  bool result = ts_tree_cursor_goto_first_child_for_byte(&cursor, index);\n  marshal_cursor(&cursor);\n  return result;\n}\n\nbool ts_tree_cursor_goto_first_child_for_position_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  const void **address = TRANSFER_BUFFER + 3;\n  TSPoint point = unmarshal_point(address);\n  bool result = ts_tree_cursor_goto_first_child_for_point(&cursor, point);\n  marshal_cursor(&cursor);\n  return result;\n}\n\nbool ts_tree_cursor_goto_next_sibling_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  bool result = ts_tree_cursor_goto_next_sibling(&cursor);\n  marshal_cursor(&cursor);\n  return result;\n}\n\nbool ts_tree_cursor_goto_previous_sibling_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  bool result = ts_tree_cursor_goto_previous_sibling(&cursor);\n  marshal_cursor(&cursor);\n  return result;\n}\n\nvoid ts_tree_cursor_goto_descendant_wasm(const TSTree *tree, uint32_t goal_descendant_index) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  ts_tree_cursor_goto_descendant(&cursor, goal_descendant_index);\n  marshal_cursor(&cursor);\n}\n\nbool ts_tree_cursor_goto_parent_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  bool result = ts_tree_cursor_goto_parent(&cursor);\n  marshal_cursor(&cursor);\n  return result;\n}\n\nuint16_t ts_tree_cursor_current_node_type_id_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  TSNode node = ts_tree_cursor_current_node(&cursor);\n  return ts_node_symbol(node);\n}\n\nuint16_t ts_tree_cursor_current_node_state_id_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  TSNode node = ts_tree_cursor_current_node(&cursor);\n  return ts_node_parse_state(node);\n}\n\nbool ts_tree_cursor_current_node_is_named_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  TSNode node = ts_tree_cursor_current_node(&cursor);\n  return ts_node_is_named(node);\n}\n\nbool ts_tree_cursor_current_node_is_missing_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  TSNode node = ts_tree_cursor_current_node(&cursor);\n  return ts_node_is_missing(node);\n}\n\nuint32_t ts_tree_cursor_current_node_id_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  TSNode node = ts_tree_cursor_current_node(&cursor);\n  return (uint32_t)node.id;\n}\n\nvoid ts_tree_cursor_start_position_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  TSNode node = ts_tree_cursor_current_node(&cursor);\n  marshal_point(ts_node_start_point(node));\n}\n\nvoid ts_tree_cursor_end_position_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  TSNode node = ts_tree_cursor_current_node(&cursor);\n  marshal_point(ts_node_end_point(node));\n}\n\nuint32_t ts_tree_cursor_start_index_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  TSNode node = ts_tree_cursor_current_node(&cursor);\n  return byte_to_code_unit(ts_node_start_byte(node));\n}\n\nuint32_t ts_tree_cursor_end_index_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  TSNode node = ts_tree_cursor_current_node(&cursor);\n  return byte_to_code_unit(ts_node_end_byte(node));\n}\n\nuint32_t ts_tree_cursor_current_field_id_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  return ts_tree_cursor_current_field_id(&cursor);\n}\n\nuint32_t ts_tree_cursor_current_depth_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  return ts_tree_cursor_current_depth(&cursor);\n}\n\nuint32_t ts_tree_cursor_current_descendant_index_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  return ts_tree_cursor_current_descendant_index(&cursor);\n}\n\nvoid ts_tree_cursor_current_node_wasm(const TSTree *tree) {\n  TSTreeCursor cursor = unmarshal_cursor(TRANSFER_BUFFER, tree);\n  marshal_node(TRANSFER_BUFFER, ts_tree_cursor_current_node(&cursor));\n}\n\n/******************/\n/* Section - Node */\n/******************/\n\nstatic TSTreeCursor scratch_cursor = {0};\nstatic TSQueryCursor *scratch_query_cursor = NULL;\n\nuint16_t ts_node_symbol_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  return ts_node_symbol(node);\n}\n\nconst char *ts_node_field_name_for_child_wasm(const TSTree *tree, uint32_t index) {\n  TSNode node = unmarshal_node(tree);\n  return ts_node_field_name_for_child(node, index);\n}\n\nconst char *ts_node_field_name_for_named_child_wasm(const TSTree *tree, uint32_t index) {\n  TSNode node = unmarshal_node(tree);\n  return ts_node_field_name_for_named_child(node, index);\n}\n\nvoid ts_node_children_by_field_id_wasm(const TSTree *tree, uint32_t field_id) {\n  TSNode node = unmarshal_node(tree);\n  TSTreeCursor cursor = ts_tree_cursor_new(node);\n\n  bool done = field_id == 0;\n  if (!done) {\n    ts_tree_cursor_reset(&cursor, node);\n    ts_tree_cursor_goto_first_child(&cursor);\n  }\n\n  Array(const void*) result = array_new();\n\n  while (!done) {\n    while (ts_tree_cursor_current_field_id(&cursor) != field_id) {\n      if (!ts_tree_cursor_goto_next_sibling(&cursor)) {\n        done = true;\n        break;\n      }\n    }\n    if (done) {\n      break;\n    }\n    TSNode result_node = ts_tree_cursor_current_node(&cursor);\n    if (!ts_tree_cursor_goto_next_sibling(&cursor)) {\n      done = true;\n    }\n    array_grow_by(&result, SIZE_OF_NODE);\n    marshal_node(result.contents + result.size - SIZE_OF_NODE, result_node);\n  }\n  ts_tree_cursor_delete(&cursor);\n\n  TRANSFER_BUFFER[0] = (const void*)(result.size / SIZE_OF_NODE);\n  TRANSFER_BUFFER[1] = (const void*)result.contents;\n}\n\nvoid ts_node_first_child_for_byte_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  const void** address = TRANSFER_BUFFER + SIZE_OF_NODE;\n  uint32_t byte = code_unit_to_byte((uint32_t)address[0]);\n  marshal_node(TRANSFER_BUFFER, ts_node_first_child_for_byte(node, byte));\n}\n\nvoid ts_node_first_named_child_for_byte_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  const void** address = TRANSFER_BUFFER + SIZE_OF_NODE;\n  uint32_t byte = code_unit_to_byte((uint32_t)address[0]);\n  marshal_node(TRANSFER_BUFFER, ts_node_first_named_child_for_byte(node, byte));\n}\n\nuint16_t ts_node_grammar_symbol_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  return ts_node_grammar_symbol(node);\n}\n\nuint32_t ts_node_child_count_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  return ts_node_child_count(node);\n}\n\nuint32_t ts_node_named_child_count_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  return ts_node_named_child_count(node);\n}\n\nvoid ts_node_child_wasm(const TSTree *tree, uint32_t index) {\n  TSNode node = unmarshal_node(tree);\n  marshal_node(TRANSFER_BUFFER, ts_node_child(node, index));\n}\n\nvoid ts_node_named_child_wasm(const TSTree *tree, uint32_t index) {\n  TSNode node = unmarshal_node(tree);\n  marshal_node(TRANSFER_BUFFER, ts_node_named_child(node, index));\n}\n\nvoid ts_node_child_by_field_id_wasm(const TSTree *tree, uint32_t field_id) {\n  TSNode node = unmarshal_node(tree);\n  marshal_node(TRANSFER_BUFFER, ts_node_child_by_field_id(node, field_id));\n}\n\nvoid ts_node_next_sibling_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  marshal_node(TRANSFER_BUFFER, ts_node_next_sibling(node));\n}\n\nvoid ts_node_prev_sibling_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  marshal_node(TRANSFER_BUFFER, ts_node_prev_sibling(node));\n}\n\nvoid ts_node_next_named_sibling_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  marshal_node(TRANSFER_BUFFER, ts_node_next_named_sibling(node));\n}\n\nvoid ts_node_prev_named_sibling_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  marshal_node(TRANSFER_BUFFER, ts_node_prev_named_sibling(node));\n}\n\nuint32_t ts_node_descendant_count_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  return ts_node_descendant_count(node);\n}\n\nvoid ts_node_parent_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  marshal_node(TRANSFER_BUFFER, ts_node_parent(node));\n}\n\nvoid ts_node_child_with_descendant_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  TSNode descendant = unmarshal_node_at(tree, 1);\n  marshal_node(TRANSFER_BUFFER, ts_node_child_with_descendant(node, descendant));\n}\n\nvoid ts_node_descendant_for_index_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  const void **address = TRANSFER_BUFFER + SIZE_OF_NODE;\n  uint32_t start = code_unit_to_byte((uint32_t)address[0]);\n  uint32_t end = code_unit_to_byte((uint32_t)address[1]);\n  marshal_node(TRANSFER_BUFFER, ts_node_descendant_for_byte_range(node, start, end));\n}\n\nvoid ts_node_named_descendant_for_index_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  const void **address = TRANSFER_BUFFER + SIZE_OF_NODE;\n  uint32_t start = code_unit_to_byte((uint32_t)address[0]);\n  uint32_t end = code_unit_to_byte((uint32_t)address[1]);\n  marshal_node(TRANSFER_BUFFER, ts_node_named_descendant_for_byte_range(node, start, end));\n}\n\nvoid ts_node_descendant_for_position_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  const void **address = TRANSFER_BUFFER + SIZE_OF_NODE;\n  TSPoint start = unmarshal_point(address); address += SIZE_OF_POINT;\n  TSPoint end = unmarshal_point(address);\n  marshal_node(TRANSFER_BUFFER, ts_node_descendant_for_point_range(node, start, end));\n}\n\nvoid ts_node_named_descendant_for_position_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  const void **address = TRANSFER_BUFFER + SIZE_OF_NODE;\n  TSPoint start = unmarshal_point(address); address += SIZE_OF_POINT;\n  TSPoint end = unmarshal_point(address);\n  marshal_node(TRANSFER_BUFFER, ts_node_named_descendant_for_point_range(node, start, end));\n}\n\nvoid ts_node_start_point_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  marshal_point(ts_node_start_point(node));\n}\n\nvoid ts_node_end_point_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  marshal_point(ts_node_end_point(node));\n}\n\nuint32_t ts_node_start_index_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  return byte_to_code_unit(ts_node_start_byte(node));\n}\n\nuint32_t ts_node_end_index_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  return byte_to_code_unit(ts_node_end_byte(node));\n}\n\nchar *ts_node_to_string_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  return ts_node_string(node);\n}\n\nvoid ts_node_children_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  uint32_t count = ts_node_child_count(node);\n  const void **result = NULL;\n  if (count > 0) {\n    result = (const void**)calloc(sizeof(void *), SIZE_OF_NODE * count);\n    const void **address = result;\n    ts_tree_cursor_reset(&scratch_cursor, node);\n    ts_tree_cursor_goto_first_child(&scratch_cursor);\n    marshal_node(address, ts_tree_cursor_current_node(&scratch_cursor));\n    for (uint32_t i = 1; i < count; i++) {\n      address += SIZE_OF_NODE;\n      ts_tree_cursor_goto_next_sibling(&scratch_cursor);\n      TSNode child = ts_tree_cursor_current_node(&scratch_cursor);\n      marshal_node(address, child);\n    }\n  }\n  TRANSFER_BUFFER[0] = (const void *)count;\n  TRANSFER_BUFFER[1] = (const void *)result;\n}\n\nvoid ts_node_named_children_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  uint32_t count = ts_node_named_child_count(node);\n  const void **result = NULL;\n  if (count > 0) {\n    result = (const void**)calloc(sizeof(void *), SIZE_OF_NODE * count);\n    const void **address = result;\n    ts_tree_cursor_reset(&scratch_cursor, node);\n    ts_tree_cursor_goto_first_child(&scratch_cursor);\n    uint32_t i = 0;\n    for (;;) {\n      TSNode child = ts_tree_cursor_current_node(&scratch_cursor);\n      if (ts_node_is_named(child)) {\n        marshal_node(address, child);\n        address += SIZE_OF_NODE;\n        i++;\n        if (i == count) {\n          break;\n        }\n      }\n      if (!ts_tree_cursor_goto_next_sibling(&scratch_cursor)) {\n        break;\n      }\n    }\n  }\n  TRANSFER_BUFFER[0] = (const void *)count;\n  TRANSFER_BUFFER[1] = (const void *)result;\n}\n\nbool symbols_contain(const uint32_t *set, uint32_t length, uint32_t value) {\n  for (unsigned i = 0; i < length; i++) {\n    if (set[i] == value) {\n      return true;\n    }\n    if (set[i] > value) {\n      break;\n    }\n  }\n  return false;\n}\n\nvoid ts_node_descendants_of_type_wasm(\n  const TSTree *tree,\n  const uint32_t *symbols,\n  uint32_t symbol_count,\n  uint32_t start_row,\n  uint32_t start_column,\n  uint32_t end_row,\n  uint32_t end_column\n) {\n  TSNode node = unmarshal_node(tree);\n  TSPoint start_point = {start_row, code_unit_to_byte(start_column)};\n  TSPoint end_point = {end_row, code_unit_to_byte(end_column)};\n  if (end_point.row == 0 && end_point.column == 0) {\n    end_point = (TSPoint) {UINT32_MAX, UINT32_MAX};\n  }\n\n  Array(const void *) result = array_new();\n\n  // Walk the tree depth first looking for matching nodes.\n  ts_tree_cursor_reset(&scratch_cursor, node);\n  bool already_visited_children = false;\n  while (true) {\n    TSNode descendant = ts_tree_cursor_current_node(&scratch_cursor);\n\n    if (!already_visited_children) {\n      // If this node is before the selected range, then avoid\n      // descending into it.\n      if (point_lte(ts_node_end_point(descendant), start_point)) {\n        if (ts_tree_cursor_goto_next_sibling(&scratch_cursor)) {\n          already_visited_children = false;\n        } else {\n          if (!ts_tree_cursor_goto_parent(&scratch_cursor)) {\n            break;\n          }\n          already_visited_children = true;\n        }\n        continue;\n      }\n\n      // If this node is after the selected range, then stop walking.\n      if (point_lte(end_point, ts_node_start_point(descendant))) {\n        break;\n      }\n\n      // Add the node to the result if its type matches one of the given\n      // node types.\n      if (symbols_contain(symbols, symbol_count, ts_node_symbol(descendant))) {\n        array_grow_by(&result, SIZE_OF_NODE);\n        marshal_node(result.contents + result.size - SIZE_OF_NODE, descendant);\n      }\n\n      // Continue walking.\n      if (ts_tree_cursor_goto_first_child(&scratch_cursor)) {\n        already_visited_children = false;\n      } else if (ts_tree_cursor_goto_next_sibling(&scratch_cursor)) {\n        already_visited_children = false;\n      } else {\n        if (!ts_tree_cursor_goto_parent(&scratch_cursor)) {\n          break;\n        }\n        already_visited_children = true;\n      }\n    } else {\n      if (ts_tree_cursor_goto_next_sibling(&scratch_cursor)) {\n        already_visited_children = false;\n      } else {\n        if (!ts_tree_cursor_goto_parent(&scratch_cursor)) {\n          break;\n        }\n      }\n    }\n  }\n\n  TRANSFER_BUFFER[0] = (const void *)(result.size / SIZE_OF_NODE);\n  TRANSFER_BUFFER[1] = (const void *)result.contents;\n}\n\nint ts_node_is_named_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  return ts_node_is_named(node);\n}\n\nint ts_node_has_changes_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  return ts_node_has_changes(node);\n}\n\nint ts_node_has_error_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  return ts_node_has_error(node);\n}\n\nint ts_node_is_error_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  return ts_node_is_error(node);\n}\n\nint ts_node_is_missing_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  return ts_node_is_missing(node);\n}\n\nint ts_node_is_extra_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  return ts_node_is_extra(node);\n}\n\nuint16_t ts_node_parse_state_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  return ts_node_parse_state(node);\n}\n\nuint16_t ts_node_next_parse_state_wasm(const TSTree *tree) {\n  TSNode node = unmarshal_node(tree);\n  return ts_node_next_parse_state(node);\n}\n\n/******************/\n/* Section - Query */\n/******************/\n\nvoid ts_query_matches_wasm(\n  const TSQuery *self,\n  const TSTree *tree,\n  uint32_t start_row,\n  uint32_t start_column,\n  uint32_t end_row,\n  uint32_t end_column,\n  uint32_t start_index,\n  uint32_t end_index,\n  uint32_t match_limit,\n  uint32_t max_start_depth,\n  uint64_t timeout_micros\n) {\n  if (!scratch_query_cursor) {\n    scratch_query_cursor = ts_query_cursor_new();\n  }\n  if (match_limit == 0) {\n    ts_query_cursor_set_match_limit(scratch_query_cursor, UINT32_MAX);\n  } else {\n    ts_query_cursor_set_match_limit(scratch_query_cursor, match_limit);\n  }\n\n  TSNode node = unmarshal_node(tree);\n  TSPoint start_point = {start_row, code_unit_to_byte(start_column)};\n  TSPoint end_point = {end_row, code_unit_to_byte(end_column)};\n  ts_query_cursor_set_point_range(scratch_query_cursor, start_point, end_point);\n  ts_query_cursor_set_byte_range(scratch_query_cursor, start_index, end_index);\n  ts_query_cursor_set_match_limit(scratch_query_cursor, match_limit);\n  ts_query_cursor_set_max_start_depth(scratch_query_cursor, max_start_depth);\n  ts_query_cursor_set_timeout_micros(scratch_query_cursor, timeout_micros);\n\n  TSQueryCursorOptions options = {.payload = NULL, .progress_callback = query_progress_callback};\n\n  ts_query_cursor_exec_with_options(scratch_query_cursor, self, node, &options);\n\n  uint32_t index = 0;\n  uint32_t match_count = 0;\n  Array(const void *) result = array_new();\n\n  TSQueryMatch match;\n  while (ts_query_cursor_next_match(scratch_query_cursor, &match)) {\n    match_count++;\n    array_grow_by(&result, 2 + (SIZE_OF_CAPTURE * match.capture_count));\n    result.contents[index++] = (const void *)(uint32_t)match.pattern_index;\n    result.contents[index++] = (const void *)(uint32_t)match.capture_count;\n    for (unsigned i = 0; i < match.capture_count; i++) {\n      const TSQueryCapture *capture = &match.captures[i];\n      result.contents[index++] = (const void *)capture->index;\n      marshal_node(result.contents + index, capture->node);\n      index += SIZE_OF_NODE;\n    }\n  }\n\n  bool did_exceed_match_limit =\n    ts_query_cursor_did_exceed_match_limit(scratch_query_cursor);\n  TRANSFER_BUFFER[0] = (const void *)(match_count);\n  TRANSFER_BUFFER[1] = (const void *)result.contents;\n  TRANSFER_BUFFER[2] = (const void *)(did_exceed_match_limit);\n}\n\nvoid ts_query_captures_wasm(\n  const TSQuery *self,\n  const TSTree *tree,\n  uint32_t start_row,\n  uint32_t start_column,\n  uint32_t end_row,\n  uint32_t end_column,\n  uint32_t start_index,\n  uint32_t end_index,\n  uint32_t match_limit,\n  uint32_t max_start_depth,\n  uint64_t timeout_micros\n) {\n  if (!scratch_query_cursor) {\n    scratch_query_cursor = ts_query_cursor_new();\n  }\n\n  ts_query_cursor_set_match_limit(scratch_query_cursor, match_limit);\n\n  TSNode node = unmarshal_node(tree);\n  TSPoint start_point = {start_row, code_unit_to_byte(start_column)};\n  TSPoint end_point = {end_row, code_unit_to_byte(end_column)};\n  ts_query_cursor_set_point_range(scratch_query_cursor, start_point, end_point);\n  ts_query_cursor_set_byte_range(scratch_query_cursor, start_index, end_index);\n  ts_query_cursor_set_match_limit(scratch_query_cursor, match_limit);\n  ts_query_cursor_set_max_start_depth(scratch_query_cursor, max_start_depth);\n  ts_query_cursor_set_timeout_micros(scratch_query_cursor, timeout_micros);\n  ts_query_cursor_exec(scratch_query_cursor, self, node);\n\n  unsigned index = 0;\n  unsigned capture_count = 0;\n  Array(const void *) result = array_new();\n\n  TSQueryMatch match;\n  uint32_t capture_index;\n  while (ts_query_cursor_next_capture(\n    scratch_query_cursor,\n    &match,\n    &capture_index\n  )) {\n    capture_count++;\n\n    array_grow_by(&result, 3 + (SIZE_OF_CAPTURE * match.capture_count));\n    result.contents[index++] = (const void *)(uint32_t)match.pattern_index;\n    result.contents[index++] = (const void *)(uint32_t)match.capture_count;\n    result.contents[index++] = (const void *)capture_index;\n    for (unsigned i = 0; i < match.capture_count; i++) {\n      const TSQueryCapture *capture = &match.captures[i];\n      result.contents[index++] = (const void *)capture->index;\n      marshal_node(result.contents + index, capture->node);\n      index += SIZE_OF_NODE;\n    }\n  }\n\n  bool did_exceed_match_limit =\n    ts_query_cursor_did_exceed_match_limit(scratch_query_cursor);\n  TRANSFER_BUFFER[0] = (const void *)(capture_count);\n  TRANSFER_BUFFER[1] = (const void *)result.contents;\n  TRANSFER_BUFFER[2] = (const void *)(did_exceed_match_limit);\n}\n"
  ]
}