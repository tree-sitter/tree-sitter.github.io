{
  "version": 3,
  "sources": ["src/constants.ts", "src/lookahead_iterator.ts", "src/tree.ts", "src/tree_cursor.ts", "src/node.ts", "src/marshal.ts", "src/query.ts", "src/language.ts", "lib/web-tree-sitter.mjs", "src/bindings.ts", "src/parser.ts"],
  "sourcesContent": ["import { type MainModule } from '../lib/web-tree-sitter';\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { ParseState, type Parser } from './parser';\n\n/**\n * A position in a multi-line text document, in terms of rows and columns.\n *\n * Rows and columns are zero-based.\n */\nexport interface Point {\n  /** The zero-based row number. */\n  row: number;\n\n  /** The zero-based column number. */\n  column: number;\n}\n\n/**\n *  A range of positions in a multi-line text document, both in terms of bytes\n *  and of rows and columns.\n */\nexport interface Range {\n  /** The start position of the range. */\n  startPosition: Point;\n\n  /** The end position of the range. */\n  endPosition: Point;\n\n  /** The start index of the range. */\n  startIndex: number;\n\n  /** The end index of the range. */\n  endIndex: number;\n}\n\n/**\n * A summary of a change to a text document.\n */\nexport interface Edit {\n  /** The start position of the change. */\n  startPosition: Point;\n\n  /** The end position of the change before the edit. */\n  oldEndPosition: Point;\n\n  /** The end position of the change after the edit. */\n  newEndPosition: Point;\n\n  /** The start index of the change. */\n  startIndex: number;\n\n  /** The end index of the change before the edit. */\n  oldEndIndex: number;\n\n  /** The end index of the change after the edit. */\n  newEndIndex: number;\n}\n\n/** @internal */\nexport const SIZE_OF_SHORT = 2;\n\n/** @internal */\nexport const SIZE_OF_INT = 4;\n\n/** @internal */\nexport const SIZE_OF_CURSOR = 4 * SIZE_OF_INT;\n\n/** @internal */\nexport const SIZE_OF_NODE = 5 * SIZE_OF_INT;\n\n/** @internal */\nexport const SIZE_OF_POINT = 2 * SIZE_OF_INT;\n\n/** @internal */\nexport const SIZE_OF_RANGE = 2 * SIZE_OF_INT + 2 * SIZE_OF_POINT;\n\n/** @internal */\nexport const ZERO_POINT: Point = { row: 0, column: 0 };\n\n/**\n * A callback for parsing that takes an index and point, and should return a string.\n */\nexport type ParseCallback = (index: number, position: Point) => string | undefined;\n\n/**\n * A callback that receives the parse state during parsing.\n */\nexport type ProgressCallback = (progress: ParseState) => boolean;\n\n/**\n * A callback for logging messages.\n *\n * If `isLex` is `true`, the message is from the lexer, otherwise it's from the parser.\n */\nexport type LogCallback = (message: string, isLex: boolean) => void;\n\n// Helper type for internal use\n/** @internal */\nexport const INTERNAL = Symbol('INTERNAL');\n/** @internal */\nexport type Internal = typeof INTERNAL;\n\n// Helper functions for type checking\n/** @internal */\nexport function assertInternal(x: unknown): asserts x is Internal {\n  if (x !== INTERNAL) throw new Error('Illegal constructor');\n}\n\n/** @internal */\nexport function isPoint(point?: Point): point is Point {\n  return (\n    !!point &&\n    typeof (point).row === 'number' &&\n    typeof (point).column === 'number'\n  );\n}\n\n/**\n * @internal\n *\n * Sets the Tree-sitter Wasm module. This should only be called by the {@link Parser} class via {@link Parser.init}.\n */\nexport function setModule(module: MainModule) {\n  C = module;\n}\n\n/**\n * @internal\n *\n * `C` is a convenient shorthand for the Tree-sitter Wasm module,\n * which allows us to call all of the exported functions.\n */\nexport let C: MainModule;\n", "import { C, Internal, assertInternal } from './constants';\nimport { Language } from './language';\n\nexport class LookaheadIterator implements Iterable<string> {\n  /** @internal */\n  private [0] = 0; // Internal handle for Wasm\n\n  /** @internal */\n  private language: Language;\n\n  /** @internal */\n  constructor(internal: Internal, address: number, language: Language) {\n    assertInternal(internal);\n    this[0] = address;\n    this.language = language;\n  }\n\n  /** Get the current symbol of the lookahead iterator. */\n  get currentTypeId(): number {\n    return C._ts_lookahead_iterator_current_symbol(this[0]);\n  }\n\n  /** Get the current symbol name of the lookahead iterator. */\n  get currentType(): string {\n    return this.language.types[this.currentTypeId] || 'ERROR';\n  }\n\n  /** Delete the lookahead iterator, freeing its resources. */\n  delete(): void {\n    C._ts_lookahead_iterator_delete(this[0]);\n    this[0] = 0;\n  }\n\n\n  /**\n   * Reset the lookahead iterator.\n   *\n   * This returns `true` if the language was set successfully and `false`\n   * otherwise.\n   */\n  reset(language: Language, stateId: number): boolean {\n    if (C._ts_lookahead_iterator_reset(this[0], language[0], stateId)) {\n      this.language = language;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Reset the lookahead iterator to another state.\n   *\n   * This returns `true` if the iterator was reset to the given state and\n   * `false` otherwise.\n   */\n  resetState(stateId: number): boolean {\n    return Boolean(C._ts_lookahead_iterator_reset_state(this[0], stateId));\n  }\n\n  /**\n   * Returns an iterator that iterates over the symbols of the lookahead iterator.\n   *\n   * The iterator will yield the current symbol name as a string for each step\n   * until there are no more symbols to iterate over.\n   */\n  [Symbol.iterator](): Iterator<string> {\n    return {\n      next: (): IteratorResult<string> => {\n        if (C._ts_lookahead_iterator_next(this[0])) {\n          return { done: false, value: this.currentType };\n        }\n        return { done: true, value: '' };\n      }\n    };\n  }\n}\n", "import { INTERNAL, Internal, assertInternal, ParseCallback, Point, Range, Edit, SIZE_OF_NODE, SIZE_OF_INT, SIZE_OF_RANGE, C } from './constants';\nimport { Language } from './language';\nimport { Node } from './node';\nimport { TreeCursor } from './tree_cursor';\nimport { marshalEdit, marshalPoint, unmarshalNode, unmarshalRange } from './marshal';\nimport { TRANSFER_BUFFER } from './parser';\n\n/** @internal */\nexport function getText(tree: Tree, startIndex: number, endIndex: number, startPosition: Point): string {\n  const length = endIndex - startIndex;\n  let result = tree.textCallback(startIndex, startPosition);\n  if (result) {\n    startIndex += result.length;\n    while (startIndex < endIndex) {\n      const string = tree.textCallback(startIndex, startPosition);\n      if (string && string.length > 0) {\n        startIndex += string.length;\n        result += string;\n      } else {\n        break;\n      }\n    }\n    if (startIndex > endIndex) {\n      result = result.slice(0, length);\n    }\n  }\n  return result ?? '';\n}\n\n/** A tree that represents the syntactic structure of a source code file. */\nexport class Tree {\n  /** @internal */\n  private [0] = 0; // Internal handle for Wasm\n\n  /** @internal */\n  textCallback: ParseCallback;\n\n  /** The language that was used to parse the syntax tree. */\n  language: Language;\n\n  /** @internal */\n  constructor(internal: Internal, address: number, language: Language, textCallback: ParseCallback) {\n    assertInternal(internal);\n    this[0] = address;\n    this.language = language;\n    this.textCallback = textCallback;\n  }\n\n  /** Create a shallow copy of the syntax tree. This is very fast. */\n  copy(): Tree {\n    const address = C._ts_tree_copy(this[0]);\n    return new Tree(INTERNAL, address, this.language, this.textCallback);\n  }\n\n  /** Delete the syntax tree, freeing its resources. */\n  delete(): void {\n    C._ts_tree_delete(this[0]);\n    this[0] = 0;\n  }\n\n  /** Get the root node of the syntax tree. */\n  get rootNode(): Node {\n    C._ts_tree_root_node_wasm(this[0]);\n    return unmarshalNode(this)!;\n  }\n\n  /**\n   * Get the root node of the syntax tree, but with its position shifted\n   * forward by the given offset.\n   */\n  rootNodeWithOffset(offsetBytes: number, offsetExtent: Point): Node {\n    const address = TRANSFER_BUFFER + SIZE_OF_NODE;\n    C.setValue(address, offsetBytes, 'i32');\n    marshalPoint(address + SIZE_OF_INT, offsetExtent);\n    C._ts_tree_root_node_with_offset_wasm(this[0]);\n    return unmarshalNode(this)!;\n  }\n\n  /**\n   * Edit the syntax tree to keep it in sync with source code that has been\n   * edited.\n   *\n   * You must describe the edit both in terms of byte offsets and in terms of\n   * row/column coordinates.\n   */\n  edit(edit: Edit): void {\n    marshalEdit(edit);\n    C._ts_tree_edit_wasm(this[0]);\n  }\n\n  /** Create a new {@link TreeCursor} starting from the root of the tree. */\n  walk(): TreeCursor {\n    return this.rootNode.walk();\n  }\n\n  /**\n   * Compare this old edited syntax tree to a new syntax tree representing\n   * the same document, returning a sequence of ranges whose syntactic\n   * structure has changed.\n   *\n   * For this to work correctly, this syntax tree must have been edited such\n   * that its ranges match up to the new tree. Generally, you'll want to\n   * call this method right after calling one of the [`Parser::parse`]\n   * functions. Call it on the old tree that was passed to parse, and\n   * pass the new tree that was returned from `parse`.\n   */\n  getChangedRanges(other: Tree): Range[] {\n    if (!(other instanceof Tree)) {\n      throw new TypeError('Argument must be a Tree');\n    }\n\n    C._ts_tree_get_changed_ranges_wasm(this[0], other[0]);\n    const count = C.getValue(TRANSFER_BUFFER, 'i32');\n    const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32');\n    const result = new Array<Range>(count);\n\n    if (count > 0) {\n      let address = buffer;\n      for (let i = 0; i < count; i++) {\n        result[i] = unmarshalRange(address);\n        address += SIZE_OF_RANGE;\n      }\n      C._free(buffer);\n    }\n    return result;\n  }\n\n  /** Get the included ranges that were used to parse the syntax tree. */\n  getIncludedRanges(): Range[] {\n    C._ts_tree_included_ranges_wasm(this[0]);\n    const count = C.getValue(TRANSFER_BUFFER, 'i32');\n    const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32');\n    const result = new Array<Range>(count);\n\n    if (count > 0) {\n      let address = buffer;\n      for (let i = 0; i < count; i++) {\n        result[i] = unmarshalRange(address);\n        address += SIZE_OF_RANGE;\n      }\n      C._free(buffer);\n    }\n    return result;\n  }\n}\n", "import { INTERNAL, Internal, assertInternal, Point, SIZE_OF_NODE, SIZE_OF_CURSOR, C } from './constants';\nimport { marshalNode, marshalPoint, marshalTreeCursor, unmarshalNode, unmarshalPoint, unmarshalTreeCursor } from './marshal';\nimport { Node } from './node';\nimport { TRANSFER_BUFFER } from './parser';\nimport { getText, Tree } from './tree';\n\n/** A stateful object for walking a syntax {@link Tree} efficiently. */\nexport class TreeCursor {\n  /** @internal */\n  // @ts-expect-error: never read\n  private [0] = 0; // Internal handle for Wasm\n\n  /** @internal */\n  // @ts-expect-error: never read\n  private [1] = 0; // Internal handle for Wasm\n\n  /** @internal */\n  // @ts-expect-error: never read\n  private [2] = 0; // Internal handle for Wasm\n\n  /** @internal */\n  // @ts-expect-error: never read\n  private [3] = 0; // Internal handle for Wasm\n\n  /** @internal */\n  private tree: Tree;\n\n  /** @internal */\n  constructor(internal: Internal, tree: Tree) {\n    assertInternal(internal);\n    this.tree = tree;\n    unmarshalTreeCursor(this);\n  }\n\n  /** Creates a deep copy of the tree cursor. This allocates new memory. */\n  copy(): TreeCursor {\n    const copy = new TreeCursor(INTERNAL, this.tree);\n    C._ts_tree_cursor_copy_wasm(this.tree[0]);\n    unmarshalTreeCursor(copy);\n    return copy;\n  }\n\n  /** Delete the tree cursor, freeing its resources. */\n  delete(): void {\n    marshalTreeCursor(this);\n    C._ts_tree_cursor_delete_wasm(this.tree[0]);\n    this[0] = this[1] = this[2] = 0;\n  }\n\n  /** Get the tree cursor's current {@link Node}. */\n  get currentNode(): Node {\n    marshalTreeCursor(this);\n    C._ts_tree_cursor_current_node_wasm(this.tree[0]);\n    return unmarshalNode(this.tree)!;\n  }\n\n  /**\n   * Get the numerical field id of this tree cursor's current node.\n   *\n   * See also {@link TreeCursor#currentFieldName}.\n   */\n  get currentFieldId(): number {\n    marshalTreeCursor(this);\n    return C._ts_tree_cursor_current_field_id_wasm(this.tree[0]);\n  }\n\n  /** Get the field name of this tree cursor's current node. */\n  get currentFieldName(): string | null {\n    return this.tree.language.fields[this.currentFieldId];\n  }\n\n  /**\n   * Get the depth of the cursor's current node relative to the original\n   * node that the cursor was constructed with.\n   */\n  get currentDepth(): number {\n    marshalTreeCursor(this);\n    return C._ts_tree_cursor_current_depth_wasm(this.tree[0]);\n  }\n\n  /**\n   * Get the index of the cursor's current node out of all of the\n   * descendants of the original node that the cursor was constructed with.\n   */\n  get currentDescendantIndex(): number {\n    marshalTreeCursor(this);\n    return C._ts_tree_cursor_current_descendant_index_wasm(this.tree[0]);\n  }\n\n  /** Get the type of the cursor's current node. */\n  get nodeType(): string {\n    return this.tree.language.types[this.nodeTypeId] || 'ERROR';\n  }\n\n  /** Get the type id of the cursor's current node. */\n  get nodeTypeId(): number {\n    marshalTreeCursor(this);\n    return C._ts_tree_cursor_current_node_type_id_wasm(this.tree[0]);\n  }\n\n  /** Get the state id of the cursor's current node. */\n  get nodeStateId(): number {\n    marshalTreeCursor(this);\n    return C._ts_tree_cursor_current_node_state_id_wasm(this.tree[0]);\n  }\n\n  /** Get the id of the cursor's current node. */\n  get nodeId(): number {\n    marshalTreeCursor(this);\n    return C._ts_tree_cursor_current_node_id_wasm(this.tree[0]);\n  }\n\n  /**\n   * Check if the cursor's current node is *named*.\n   *\n   * Named nodes correspond to named rules in the grammar, whereas\n   * *anonymous* nodes correspond to string literals in the grammar.\n   */\n  get nodeIsNamed(): boolean {\n    marshalTreeCursor(this);\n    return C._ts_tree_cursor_current_node_is_named_wasm(this.tree[0]) === 1;\n  }\n\n  /**\n   * Check if the cursor's current node is *missing*.\n   *\n   * Missing nodes are inserted by the parser in order to recover from\n   * certain kinds of syntax errors.\n   */\n  get nodeIsMissing(): boolean {\n    marshalTreeCursor(this);\n    return C._ts_tree_cursor_current_node_is_missing_wasm(this.tree[0]) === 1;\n  }\n\n  /** Get the string content of the cursor's current node. */\n  get nodeText(): string {\n    marshalTreeCursor(this);\n    const startIndex = C._ts_tree_cursor_start_index_wasm(this.tree[0]);\n    const endIndex = C._ts_tree_cursor_end_index_wasm(this.tree[0]);\n    C._ts_tree_cursor_start_position_wasm(this.tree[0]);\n    const startPosition = unmarshalPoint(TRANSFER_BUFFER);\n    return getText(this.tree, startIndex, endIndex, startPosition);\n  }\n\n  /** Get the start position of the cursor's current node. */\n  get startPosition(): Point {\n    marshalTreeCursor(this);\n    C._ts_tree_cursor_start_position_wasm(this.tree[0]);\n    return unmarshalPoint(TRANSFER_BUFFER);\n  }\n\n  /** Get the end position of the cursor's current node. */\n  get endPosition(): Point {\n    marshalTreeCursor(this);\n    C._ts_tree_cursor_end_position_wasm(this.tree[0]);\n    return unmarshalPoint(TRANSFER_BUFFER);\n  }\n\n  /** Get the start index of the cursor's current node. */\n  get startIndex(): number {\n    marshalTreeCursor(this);\n    return C._ts_tree_cursor_start_index_wasm(this.tree[0]);\n  }\n\n  /** Get the end index of the cursor's current node. */\n  get endIndex(): number {\n    marshalTreeCursor(this);\n    return C._ts_tree_cursor_end_index_wasm(this.tree[0]);\n  }\n\n  /**\n   * Move this cursor to the first child of its current node.\n   *\n   * This returns `true` if the cursor successfully moved, and returns\n   * `false` if there were no children.\n   */\n  gotoFirstChild(): boolean {\n    marshalTreeCursor(this);\n    const result = C._ts_tree_cursor_goto_first_child_wasm(this.tree[0]);\n    unmarshalTreeCursor(this);\n    return result === 1;\n  }\n\n  /**\n   * Move this cursor to the last child of its current node.\n   *\n   * This returns `true` if the cursor successfully moved, and returns\n   * `false` if there were no children.\n   *\n   * Note that this function may be slower than\n   * {@link TreeCursor#gotoFirstChild} because it needs to\n   * iterate through all the children to compute the child's position.\n   */\n  gotoLastChild(): boolean {\n    marshalTreeCursor(this);\n    const result = C._ts_tree_cursor_goto_last_child_wasm(this.tree[0]);\n    unmarshalTreeCursor(this);\n    return result === 1;\n  }\n\n  /**\n   * Move this cursor to the parent of its current node.\n   *\n   * This returns `true` if the cursor successfully moved, and returns\n   * `false` if there was no parent node (the cursor was already on the\n   * root node).\n   *\n   * Note that the node the cursor was constructed with is considered the root\n   * of the cursor, and the cursor cannot walk outside this node.\n   */\n  gotoParent(): boolean {\n    marshalTreeCursor(this);\n    const result = C._ts_tree_cursor_goto_parent_wasm(this.tree[0]);\n    unmarshalTreeCursor(this);\n    return result === 1;\n  }\n\n  /**\n   * Move this cursor to the next sibling of its current node.\n   *\n   * This returns `true` if the cursor successfully moved, and returns\n   * `false` if there was no next sibling node.\n   *\n   * Note that the node the cursor was constructed with is considered the root\n   * of the cursor, and the cursor cannot walk outside this node.\n   */\n  gotoNextSibling(): boolean {\n    marshalTreeCursor(this);\n    const result = C._ts_tree_cursor_goto_next_sibling_wasm(this.tree[0]);\n    unmarshalTreeCursor(this);\n    return result === 1;\n  }\n\n  /**\n   * Move this cursor to the previous sibling of its current node.\n   *\n   * This returns `true` if the cursor successfully moved, and returns\n   * `false` if there was no previous sibling node.\n   *\n   * Note that this function may be slower than\n   * {@link TreeCursor#gotoNextSibling} due to how node\n   * positions are stored. In the worst case, this will need to iterate\n   * through all the children up to the previous sibling node to recalculate\n   * its position. Also note that the node the cursor was constructed with is\n   * considered the root of the cursor, and the cursor cannot walk outside this node.\n   */\n  gotoPreviousSibling(): boolean {\n    marshalTreeCursor(this);\n    const result = C._ts_tree_cursor_goto_previous_sibling_wasm(this.tree[0]);\n    unmarshalTreeCursor(this);\n    return result === 1;\n  }\n\n  /**\n   * Move the cursor to the node that is the nth descendant of\n   * the original node that the cursor was constructed with, where\n   * zero represents the original node itself.\n   */\n  gotoDescendant(goalDescendantIndex: number): void {\n    marshalTreeCursor(this);\n    C._ts_tree_cursor_goto_descendant_wasm(this.tree[0], goalDescendantIndex);\n    unmarshalTreeCursor(this);\n  }\n\n  /**\n   * Move this cursor to the first child of its current node that contains or\n   * starts after the given byte offset.\n   *\n   * This returns `true` if the cursor successfully moved to a child node, and returns\n   * `false` if no such child was found.\n   */\n  gotoFirstChildForIndex(goalIndex: number): boolean {\n    marshalTreeCursor(this);\n    C.setValue(TRANSFER_BUFFER + SIZE_OF_CURSOR, goalIndex, 'i32');\n    const result = C._ts_tree_cursor_goto_first_child_for_index_wasm(this.tree[0]);\n    unmarshalTreeCursor(this);\n    return result === 1;\n  }\n\n  /**\n   * Move this cursor to the first child of its current node that contains or\n   * starts after the given byte offset.\n   *\n   * This returns the index of the child node if one was found, and returns\n   * `null` if no such child was found.\n   */\n  gotoFirstChildForPosition(goalPosition: Point): boolean {\n    marshalTreeCursor(this);\n    marshalPoint(TRANSFER_BUFFER + SIZE_OF_CURSOR, goalPosition);\n    const result = C._ts_tree_cursor_goto_first_child_for_position_wasm(this.tree[0]);\n    unmarshalTreeCursor(this);\n    return result === 1;\n  }\n\n  /**\n   * Re-initialize this tree cursor to start at the original node that the\n   * cursor was constructed with.\n   */\n  reset(node: Node): void {\n    marshalNode(node);\n    marshalTreeCursor(this, TRANSFER_BUFFER + SIZE_OF_NODE);\n    C._ts_tree_cursor_reset_wasm(this.tree[0]);\n    unmarshalTreeCursor(this);\n  }\n\n  /**\n   * Re-initialize a tree cursor to the same position as another cursor.\n   *\n   * Unlike {@link TreeCursor#reset}, this will not lose parent\n   * information and allows reusing already created cursors.\n   */\n  resetTo(cursor: TreeCursor): void {\n    marshalTreeCursor(this, TRANSFER_BUFFER);\n    marshalTreeCursor(cursor, TRANSFER_BUFFER + SIZE_OF_CURSOR);\n    C._ts_tree_cursor_reset_to_wasm(this.tree[0], cursor.tree[0]);\n    unmarshalTreeCursor(this);\n  }\n}\n", "import { INTERNAL, Internal, assertInternal, Point, Edit, SIZE_OF_INT, SIZE_OF_NODE, SIZE_OF_POINT, ZERO_POINT, isPoint, C } from './constants';\nimport { getText, Tree } from './tree';\nimport { TreeCursor } from './tree_cursor';\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { Language } from './language';\nimport { marshalNode, marshalPoint, unmarshalNode, unmarshalPoint } from './marshal';\nimport { TRANSFER_BUFFER } from './parser';\n\n/** A single node within a syntax {@link Tree}. */\nexport class Node {\n  /** @internal */\n  // @ts-expect-error: never read\n  private [0] = 0; // Internal handle for Wasm\n\n  /** @internal */\n  private _children?: Node[];\n\n  /** @internal */\n  private _namedChildren?: Node[];\n\n  /** @internal */\n  constructor(\n    internal: Internal,\n    {\n      id,\n      tree,\n      startIndex,\n      startPosition,\n      other,\n    }: {\n      id: number;\n      tree: Tree;\n      startIndex: number;\n      startPosition: Point;\n      other: number;\n    }\n  ) {\n    assertInternal(internal);\n    this[0] = other;\n    this.id = id;\n    this.tree = tree;\n    this.startIndex = startIndex;\n    this.startPosition = startPosition;\n  }\n\n  /**\n   * The numeric id for this node that is unique.\n   *\n   * Within a given syntax tree, no two nodes have the same id. However:\n   *\n   * * If a new tree is created based on an older tree, and a node from the old tree is reused in\n   *   the process, then that node will have the same id in both trees.\n   *\n   * * A node not marked as having changes does not guarantee it was reused.\n   *\n   * * If a node is marked as having changed in the old tree, it will not be reused.\n   */\n  id: number;\n\n  /** The byte index where this node starts. */\n  startIndex: number;\n\n  /** The position where this node starts. */\n  startPosition: Point;\n\n  /** The tree that this node belongs to. */\n  tree: Tree;\n\n  /** Get this node's type as a numerical id. */\n  get typeId(): number {\n    marshalNode(this);\n    return C._ts_node_symbol_wasm(this.tree[0]);\n  }\n\n  /**\n   * Get the node's type as a numerical id as it appears in the grammar,\n   * ignoring aliases.\n   */\n  get grammarId(): number {\n    marshalNode(this);\n    return C._ts_node_grammar_symbol_wasm(this.tree[0]);\n  }\n\n  /** Get this node's type as a string. */\n  get type(): string {\n    return this.tree.language.types[this.typeId] || 'ERROR';\n  }\n\n  /**\n   * Get this node's symbol name as it appears in the grammar, ignoring\n   * aliases as a string.\n   */\n  get grammarType(): string {\n    return this.tree.language.types[this.grammarId] || 'ERROR';\n  }\n\n  /**\n   * Check if this node is *named*.\n   *\n   * Named nodes correspond to named rules in the grammar, whereas\n   * *anonymous* nodes correspond to string literals in the grammar.\n   */\n  get isNamed(): boolean {\n    marshalNode(this);\n    return C._ts_node_is_named_wasm(this.tree[0]) === 1;\n  }\n\n  /**\n   * Check if this node is *extra*.\n   *\n   * Extra nodes represent things like comments, which are not required\n   * by the grammar, but can appear anywhere.\n   */\n  get isExtra(): boolean {\n    marshalNode(this);\n    return C._ts_node_is_extra_wasm(this.tree[0]) === 1;\n  }\n\n  /**\n   * Check if this node represents a syntax error.\n   *\n   * Syntax errors represent parts of the code that could not be incorporated\n   * into a valid syntax tree.\n   */\n  get isError(): boolean {\n    marshalNode(this);\n    return C._ts_node_is_error_wasm(this.tree[0]) === 1;\n  }\n\n  /**\n   * Check if this node is *missing*.\n   *\n   * Missing nodes are inserted by the parser in order to recover from\n   * certain kinds of syntax errors.\n   */\n  get isMissing(): boolean {\n    marshalNode(this);\n    return C._ts_node_is_missing_wasm(this.tree[0]) === 1;\n  }\n\n  /** Check if this node has been edited. */\n  get hasChanges(): boolean {\n    marshalNode(this);\n    return C._ts_node_has_changes_wasm(this.tree[0]) === 1;\n  }\n\n  /**\n   * Check if this node represents a syntax error or contains any syntax\n   * errors anywhere within it.\n   */\n  get hasError(): boolean {\n    marshalNode(this);\n    return C._ts_node_has_error_wasm(this.tree[0]) === 1;\n  }\n\n  /** Get the byte index where this node ends. */\n  get endIndex(): number {\n    marshalNode(this);\n    return C._ts_node_end_index_wasm(this.tree[0]);\n  }\n\n  /** Get the position where this node ends. */\n  get endPosition(): Point {\n    marshalNode(this);\n    C._ts_node_end_point_wasm(this.tree[0]);\n    return unmarshalPoint(TRANSFER_BUFFER);\n  }\n\n  /** Get the string content of this node. */\n  get text(): string {\n    return getText(this.tree, this.startIndex, this.endIndex, this.startPosition);\n  }\n\n  /** Get this node's parse state. */\n  get parseState(): number {\n    marshalNode(this);\n    return C._ts_node_parse_state_wasm(this.tree[0]);\n  }\n\n  /** Get the parse state after this node. */\n  get nextParseState(): number {\n    marshalNode(this);\n    return C._ts_node_next_parse_state_wasm(this.tree[0]);\n  }\n\n  /** Check if this node is equal to another node. */\n  equals(other: Node): boolean {\n    return this.tree === other.tree && this.id === other.id;\n  }\n\n  /**\n   * Get the node's child at the given index, where zero represents the first child.\n   *\n   * This method is fairly fast, but its cost is technically log(n), so if\n   * you might be iterating over a long list of children, you should use\n   * {@link Node#children} instead.\n   */\n  child(index: number): Node | null {\n    marshalNode(this);\n    C._ts_node_child_wasm(this.tree[0], index);\n    return unmarshalNode(this.tree);\n  }\n\n  /**\n   * Get this node's *named* child at the given index.\n   *\n   * See also {@link Node#isNamed}.\n   * This method is fairly fast, but its cost is technically log(n), so if\n   * you might be iterating over a long list of children, you should use\n   * {@link Node#namedChildren} instead.\n   */\n  namedChild(index: number): Node | null {\n    marshalNode(this);\n    C._ts_node_named_child_wasm(this.tree[0], index);\n    return unmarshalNode(this.tree);\n  }\n\n  /**\n   * Get this node's child with the given numerical field id.\n   *\n   * See also {@link Node#childForFieldName}. You can\n   * convert a field name to an id using {@link Language#fieldIdForName}.\n   */\n  childForFieldId(fieldId: number): Node | null {\n    marshalNode(this);\n    C._ts_node_child_by_field_id_wasm(this.tree[0], fieldId);\n    return unmarshalNode(this.tree);\n  }\n\n  /**\n   * Get the first child with the given field name.\n   *\n   * If multiple children may have the same field name, access them using\n   * {@link Node#childrenForFieldName}.\n   */\n  childForFieldName(fieldName: string): Node | null {\n    const fieldId = this.tree.language.fields.indexOf(fieldName);\n    if (fieldId !== -1) return this.childForFieldId(fieldId);\n    return null;\n  }\n\n  /** Get the field name of this node's child at the given index. */\n  fieldNameForChild(index: number): string | null {\n    marshalNode(this);\n    const address = C._ts_node_field_name_for_child_wasm(this.tree[0], index);\n    if (!address) return null;\n    return C.AsciiToString(address);\n  }\n\n  /** Get the field name of this node's named child at the given index. */\n  fieldNameForNamedChild(index: number): string | null {\n    marshalNode(this);\n    const address = C._ts_node_field_name_for_named_child_wasm(this.tree[0], index);\n    if (!address) return null;\n    return C.AsciiToString(address);\n  }\n  /**\n   * Get an array of this node's children with a given field name.\n   *\n   * See also {@link Node#children}.\n   */\n  childrenForFieldName(fieldName: string): Node[] {\n    const fieldId = this.tree.language.fields.indexOf(fieldName);\n    if (fieldId !== -1 && fieldId !== 0) return this.childrenForFieldId(fieldId);\n    return [];\n  }\n\n  /**\n    * Get an array of this node's children with a given field id.\n    *\n    * See also {@link Node#childrenForFieldName}.\n    */\n  childrenForFieldId(fieldId: number): Node[] {\n    marshalNode(this);\n    C._ts_node_children_by_field_id_wasm(this.tree[0], fieldId);\n    const count = C.getValue(TRANSFER_BUFFER, 'i32');\n    const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32');\n    const result = new Array<Node>(count);\n\n    if (count > 0) {\n      let address = buffer;\n      for (let i = 0; i < count; i++) {\n        result[i] = unmarshalNode(this.tree, address)!;\n        address += SIZE_OF_NODE;\n      }\n      C._free(buffer);\n    }\n    return result;\n  }\n\n  /** Get the node's first child that contains or starts after the given byte offset. */\n  firstChildForIndex(index: number): Node | null {\n    marshalNode(this);\n    const address = TRANSFER_BUFFER + SIZE_OF_NODE;\n    C.setValue(address, index, 'i32');\n    C._ts_node_first_child_for_byte_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n\n  /** Get the node's first named child that contains or starts after the given byte offset. */\n  firstNamedChildForIndex(index: number): Node | null {\n    marshalNode(this);\n    const address = TRANSFER_BUFFER + SIZE_OF_NODE;\n    C.setValue(address, index, 'i32');\n    C._ts_node_first_named_child_for_byte_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n\n  /** Get this node's number of children. */\n  get childCount(): number {\n    marshalNode(this);\n    return C._ts_node_child_count_wasm(this.tree[0]);\n  }\n\n\n  /**\n   * Get this node's number of *named* children.\n   *\n   * See also {@link Node#isNamed}.\n   */\n  get namedChildCount(): number {\n    marshalNode(this);\n    return C._ts_node_named_child_count_wasm(this.tree[0]);\n  }\n\n  /** Get this node's first child. */\n  get firstChild(): Node | null {\n    return this.child(0);\n  }\n\n  /**\n   * Get this node's first named child.\n   *\n   * See also {@link Node#isNamed}.\n   */\n  get firstNamedChild(): Node | null {\n    return this.namedChild(0);\n  }\n\n  /** Get this node's last child. */\n  get lastChild(): Node | null {\n    return this.child(this.childCount - 1);\n  }\n\n  /**\n   * Get this node's last named child.\n   *\n   * See also {@link Node#isNamed}.\n   */\n  get lastNamedChild(): Node | null {\n    return this.namedChild(this.namedChildCount - 1);\n  }\n\n  /**\n   * Iterate over this node's children.\n   *\n   * If you're walking the tree recursively, you may want to use the\n   * {@link TreeCursor} APIs directly instead.\n   */\n  get children(): Node[] {\n    if (!this._children) {\n      marshalNode(this);\n      C._ts_node_children_wasm(this.tree[0]);\n      const count = C.getValue(TRANSFER_BUFFER, 'i32');\n      const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32');\n      this._children = new Array<Node>(count);\n      if (count > 0) {\n        let address = buffer;\n        for (let i = 0; i < count; i++) {\n          this._children[i] = unmarshalNode(this.tree, address)!;\n          address += SIZE_OF_NODE;\n        }\n        C._free(buffer);\n      }\n    }\n    return this._children;\n  }\n\n  /**\n   * Iterate over this node's named children.\n   *\n   * See also {@link Node#children}.\n   */\n  get namedChildren(): Node[] {\n    if (!this._namedChildren) {\n      marshalNode(this);\n      C._ts_node_named_children_wasm(this.tree[0]);\n      const count = C.getValue(TRANSFER_BUFFER, 'i32');\n      const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32');\n      this._namedChildren = new Array<Node>(count);\n      if (count > 0) {\n        let address = buffer;\n        for (let i = 0; i < count; i++) {\n          this._namedChildren[i] = unmarshalNode(this.tree, address)!;\n          address += SIZE_OF_NODE;\n        }\n        C._free(buffer);\n      }\n    }\n    return this._namedChildren;\n  }\n\n  /**\n   * Get the descendants of this node that are the given type, or in the given types array.\n   *\n   * The types array should contain node type strings, which can be retrieved from {@link Language#types}.\n   *\n   * Additionally, a `startPosition` and `endPosition` can be passed in to restrict the search to a byte range.\n   */\n  descendantsOfType(\n    types: string | string[],\n    startPosition: Point = ZERO_POINT,\n    endPosition: Point = ZERO_POINT\n  ): Node[] {\n    if (!Array.isArray(types)) types = [types];\n\n    // Convert the type strings to numeric type symbols\n    const symbols: number[] = [];\n    const typesBySymbol = this.tree.language.types;\n    for (const node_type of types) {\n      if (node_type == \"ERROR\") {\n        symbols.push(65535); // Internally, ts_builtin_sym_error is -1, which is UINT_16MAX\n      }\n    }\n    for (let i = 0, n = typesBySymbol.length; i < n; i++) {\n      if (types.includes(typesBySymbol[i])) {\n        symbols.push(i);\n      }\n    }\n\n    // Copy the array of symbols to the Wasm heap\n    const symbolsAddress = C._malloc(SIZE_OF_INT * symbols.length);\n    for (let i = 0, n = symbols.length; i < n; i++) {\n      C.setValue(symbolsAddress + i * SIZE_OF_INT, symbols[i], 'i32');\n    }\n\n    // Call the C API to compute the descendants\n    marshalNode(this);\n    C._ts_node_descendants_of_type_wasm(\n      this.tree[0],\n      symbolsAddress,\n      symbols.length,\n      startPosition.row,\n      startPosition.column,\n      endPosition.row,\n      endPosition.column\n    );\n\n    // Instantiate the nodes based on the data returned\n    const descendantCount = C.getValue(TRANSFER_BUFFER, 'i32');\n    const descendantAddress = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32');\n    const result = new Array<Node>(descendantCount);\n    if (descendantCount > 0) {\n      let address = descendantAddress;\n      for (let i = 0; i < descendantCount; i++) {\n        result[i] = unmarshalNode(this.tree, address)!;\n        address += SIZE_OF_NODE;\n      }\n    }\n\n    // Free the intermediate buffers\n    C._free(descendantAddress);\n    C._free(symbolsAddress);\n    return result;\n  }\n\n  /** Get this node's next sibling. */\n  get nextSibling(): Node | null {\n    marshalNode(this);\n    C._ts_node_next_sibling_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n\n  /** Get this node's previous sibling. */\n  get previousSibling(): Node | null {\n    marshalNode(this);\n    C._ts_node_prev_sibling_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n\n  /**\n   * Get this node's next *named* sibling.\n   *\n   * See also {@link Node#isNamed}.\n   */\n  get nextNamedSibling(): Node | null {\n    marshalNode(this);\n    C._ts_node_next_named_sibling_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n\n  /**\n   * Get this node's previous *named* sibling.\n   *\n   * See also {@link Node#isNamed}.\n   */\n  get previousNamedSibling(): Node | null {\n    marshalNode(this);\n    C._ts_node_prev_named_sibling_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n\n  /** Get the node's number of descendants, including one for the node itself. */\n  get descendantCount(): number {\n    marshalNode(this);\n    return C._ts_node_descendant_count_wasm(this.tree[0]);\n  }\n\n  /**\n   * Get this node's immediate parent.\n   * Prefer {@link Node#childWithDescendant} for iterating over this node's ancestors.\n   */\n  get parent(): Node | null {\n    marshalNode(this);\n    C._ts_node_parent_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n\n  /**\n   * Get the node that contains `descendant`.\n   *\n   * Note that this can return `descendant` itself.\n   */\n  childWithDescendant(descendant: Node): Node | null {\n    marshalNode(this);\n    marshalNode(descendant, 1);\n    C._ts_node_child_with_descendant_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n\n  /** Get the smallest node within this node that spans the given byte range. */\n  descendantForIndex(start: number, end: number = start): Node | null {\n    if (typeof start !== 'number' || typeof end !== 'number') {\n      throw new Error('Arguments must be numbers');\n    }\n\n    marshalNode(this);\n    const address = TRANSFER_BUFFER + SIZE_OF_NODE;\n    C.setValue(address, start, 'i32');\n    C.setValue(address + SIZE_OF_INT, end, 'i32');\n    C._ts_node_descendant_for_index_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n\n  /** Get the smallest named node within this node that spans the given byte range. */\n  namedDescendantForIndex(start: number, end: number = start): Node | null {\n    if (typeof start !== 'number' || typeof end !== 'number') {\n      throw new Error('Arguments must be numbers');\n    }\n\n    marshalNode(this);\n    const address = TRANSFER_BUFFER + SIZE_OF_NODE;\n    C.setValue(address, start, 'i32');\n    C.setValue(address + SIZE_OF_INT, end, 'i32');\n    C._ts_node_named_descendant_for_index_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n\n  /** Get the smallest node within this node that spans the given point range. */\n  descendantForPosition(start: Point, end: Point = start) {\n    if (!isPoint(start) || !isPoint(end)) {\n      throw new Error('Arguments must be {row, column} objects');\n    }\n\n    marshalNode(this);\n    const address = TRANSFER_BUFFER + SIZE_OF_NODE;\n    marshalPoint(address, start);\n    marshalPoint(address + SIZE_OF_POINT, end);\n    C._ts_node_descendant_for_position_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n\n  /** Get the smallest named node within this node that spans the given point range. */\n  namedDescendantForPosition(start: Point, end: Point = start) {\n    if (!isPoint(start) || !isPoint(end)) {\n      throw new Error('Arguments must be {row, column} objects');\n    }\n\n    marshalNode(this);\n    const address = TRANSFER_BUFFER + SIZE_OF_NODE;\n    marshalPoint(address, start);\n    marshalPoint(address + SIZE_OF_POINT, end);\n    C._ts_node_named_descendant_for_position_wasm(this.tree[0]);\n    return unmarshalNode(this.tree);\n  }\n\n  /**\n   * Create a new {@link TreeCursor} starting from this node.\n   *\n   * Note that the given node is considered the root of the cursor,\n   * and the cursor cannot walk outside this node.\n   */\n  walk(): TreeCursor {\n    marshalNode(this);\n    C._ts_tree_cursor_new_wasm(this.tree[0]);\n    return new TreeCursor(INTERNAL, this.tree);\n  }\n\n  /**\n   * Edit this node to keep it in-sync with source code that has been edited.\n   *\n   * This function is only rarely needed. When you edit a syntax tree with\n   * the {@link Tree#edit} method, all of the nodes that you retrieve from\n   * the tree afterward will already reflect the edit. You only need to\n   * use {@link Node#edit} when you have a specific {@link Node} instance that\n   * you want to keep and continue to use after an edit.\n   */\n  edit(edit: Edit) {\n    if (this.startIndex >= edit.oldEndIndex) {\n      this.startIndex = edit.newEndIndex + (this.startIndex - edit.oldEndIndex);\n      let subbedPointRow;\n      let subbedPointColumn;\n      if (this.startPosition.row > edit.oldEndPosition.row) {\n        subbedPointRow = this.startPosition.row - edit.oldEndPosition.row;\n        subbedPointColumn = this.startPosition.column;\n      } else {\n        subbedPointRow = 0;\n        subbedPointColumn = this.startPosition.column;\n        if (this.startPosition.column >= edit.oldEndPosition.column) {\n          subbedPointColumn =\n            this.startPosition.column - edit.oldEndPosition.column;\n        }\n      }\n\n      if (subbedPointRow > 0) {\n        this.startPosition.row += subbedPointRow;\n        this.startPosition.column = subbedPointColumn;\n      } else {\n        this.startPosition.column += subbedPointColumn;\n      }\n    } else if (this.startIndex > edit.startIndex) {\n      this.startIndex = edit.newEndIndex;\n      this.startPosition.row = edit.newEndPosition.row;\n      this.startPosition.column = edit.newEndPosition.column;\n    }\n  }\n\n  /** Get the S-expression representation of this node. */\n  toString(): string {\n    marshalNode(this);\n    const address = C._ts_node_to_string_wasm(this.tree[0]);\n    const result = C.AsciiToString(address);\n    C._free(address);\n    return result;\n  }\n}\n", "import { Edit, INTERNAL, Point, Range, SIZE_OF_INT, SIZE_OF_NODE, SIZE_OF_POINT, C } from \"./constants\";\nimport { Node } from \"./node\";\nimport { Tree } from \"./tree\";\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { Query, QueryCapture, type QueryMatch } from \"./query\";\nimport { TreeCursor } from \"./tree_cursor\";\nimport { TRANSFER_BUFFER } from \"./parser\";\nimport { LanguageMetadata } from \"./language\";\n\n/**\n * @internal\n *\n * Unmarshals a {@link QueryMatch} to the transfer buffer.\n */\nexport function unmarshalCaptures(\n  query: Query,\n  tree: Tree,\n  address: number,\n  patternIndex: number,\n  result: QueryCapture[]\n) {\n  for (let i = 0, n = result.length; i < n; i++) {\n    const captureIndex = C.getValue(address, 'i32');\n    address += SIZE_OF_INT;\n    const node = unmarshalNode(tree, address)!;\n    address += SIZE_OF_NODE;\n    result[i] = {patternIndex, name: query.captureNames[captureIndex], node};\n  }\n  return address;\n}\n\n/**\n * @internal\n *\n * Marshals a {@link Node} to the transfer buffer.\n */\nexport function marshalNode(node: Node, index = 0) {\n  let address = TRANSFER_BUFFER + index * SIZE_OF_NODE;\n  C.setValue(address, node.id, 'i32');\n  address += SIZE_OF_INT;\n  C.setValue(address, node.startIndex, 'i32');\n  address += SIZE_OF_INT;\n  C.setValue(address, node.startPosition.row, 'i32');\n  address += SIZE_OF_INT;\n  C.setValue(address, node.startPosition.column, 'i32');\n  address += SIZE_OF_INT;\n  C.setValue(address, node[0], 'i32');\n}\n\n/**\n * @internal\n *\n * Unmarshals a {@link Node} from the transfer buffer.\n */\nexport function unmarshalNode(tree: Tree, address = TRANSFER_BUFFER): Node | null {\n  const id = C.getValue(address, 'i32');\n  address += SIZE_OF_INT;\n  if (id === 0) return null;\n\n  const index = C.getValue(address, 'i32');\n  address += SIZE_OF_INT;\n  const row = C.getValue(address, 'i32');\n  address += SIZE_OF_INT;\n  const column = C.getValue(address, 'i32');\n  address += SIZE_OF_INT;\n  const other = C.getValue(address, 'i32');\n\n  const result = new Node(INTERNAL, {\n    id,\n    tree,\n    startIndex: index,\n    startPosition: {row, column},\n    other,\n  });\n\n  return result;\n}\n\n/**\n * @internal\n *\n * Marshals a {@link TreeCursor} to the transfer buffer.\n */\nexport function marshalTreeCursor(cursor: TreeCursor, address = TRANSFER_BUFFER) {\n  C.setValue(address + 0 * SIZE_OF_INT, cursor[0], 'i32');\n  C.setValue(address + 1 * SIZE_OF_INT, cursor[1], 'i32');\n  C.setValue(address + 2 * SIZE_OF_INT, cursor[2], 'i32');\n  C.setValue(address + 3 * SIZE_OF_INT, cursor[3], 'i32');\n}\n\n/**\n * @internal\n *\n * Unmarshals a {@link TreeCursor} from the transfer buffer.\n */\nexport function unmarshalTreeCursor(cursor: TreeCursor) {\n  cursor[0] = C.getValue(TRANSFER_BUFFER + 0 * SIZE_OF_INT, 'i32');\n  cursor[1] = C.getValue(TRANSFER_BUFFER + 1 * SIZE_OF_INT, 'i32');\n  cursor[2] = C.getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, 'i32');\n  cursor[3] = C.getValue(TRANSFER_BUFFER + 3 * SIZE_OF_INT, 'i32');\n}\n\n/**\n * @internal\n *\n * Marshals a {@link Point} to the transfer buffer.\n */\nexport function marshalPoint(address: number, point: Point): void {\n  C.setValue(address, point.row, 'i32');\n  C.setValue(address + SIZE_OF_INT, point.column, 'i32');\n}\n\n/**\n * @internal\n *\n * Unmarshals a {@link Point} from the transfer buffer.\n */\nexport function unmarshalPoint(address: number): Point {\n  const result = {\n    row: C.getValue(address, 'i32') >>> 0,\n    column: C.getValue(address + SIZE_OF_INT, 'i32') >>> 0,\n  };\n  return result;\n}\n\n/**\n * @internal\n *\n * Marshals a {@link Range} to the transfer buffer.\n */\nexport function marshalRange(address: number, range: Range): void {\n  marshalPoint(address, range.startPosition); address += SIZE_OF_POINT;\n  marshalPoint(address, range.endPosition); address += SIZE_OF_POINT;\n  C.setValue(address, range.startIndex, 'i32'); address += SIZE_OF_INT;\n  C.setValue(address, range.endIndex, 'i32'); address += SIZE_OF_INT;\n}\n\n/**\n * @internal\n *\n * Unmarshals a {@link Range} from the transfer buffer.\n */\nexport function unmarshalRange(address: number): Range {\n  const result = {} as Range;\n  result.startPosition = unmarshalPoint(address); address += SIZE_OF_POINT;\n  result.endPosition = unmarshalPoint(address); address += SIZE_OF_POINT;\n  result.startIndex = C.getValue(address, 'i32') >>> 0; address += SIZE_OF_INT;\n  result.endIndex = C.getValue(address, 'i32') >>> 0;\n  return result;\n}\n\n/**\n * @internal\n *\n * Marshals an {@link Edit} to the transfer buffer.\n */\nexport function marshalEdit(edit: Edit, address = TRANSFER_BUFFER) {\n  marshalPoint(address, edit.startPosition); address += SIZE_OF_POINT;\n  marshalPoint(address, edit.oldEndPosition); address += SIZE_OF_POINT;\n  marshalPoint(address, edit.newEndPosition); address += SIZE_OF_POINT;\n  C.setValue(address, edit.startIndex, 'i32'); address += SIZE_OF_INT;\n  C.setValue(address, edit.oldEndIndex, 'i32'); address += SIZE_OF_INT;\n  C.setValue(address, edit.newEndIndex, 'i32'); address += SIZE_OF_INT;\n}\n\n/**\n * @internal\n *\n * Unmarshals a {@link LanguageMetadata} from the transfer buffer.\n */\nexport function unmarshalLanguageMetadata(address: number): LanguageMetadata {  \n  const major_version = C.getValue(address, 'i32');\n  const minor_version = C.getValue(address += SIZE_OF_INT, 'i32');\n  const patch_version = C.getValue(address += SIZE_OF_INT, 'i32');\n  return { major_version, minor_version, patch_version };\n}\n", "import { Point, ZERO_POINT, SIZE_OF_INT, C } from './constants';\nimport { Node } from './node';\nimport { marshalNode, unmarshalCaptures } from './marshal';\nimport { TRANSFER_BUFFER } from './parser';\nimport { Language } from './language';\n\nconst PREDICATE_STEP_TYPE_CAPTURE = 1;\n\nconst PREDICATE_STEP_TYPE_STRING = 2;\n\nconst QUERY_WORD_REGEX = /[\\w-]+/g;\n\n/**\n * Options for query execution\n */\nexport interface QueryOptions {\n  /** The start position of the range to query */\n  startPosition?: Point;\n\n  /** The end position of the range to query */\n  endPosition?: Point;\n\n  /** The start index of the range to query */\n  startIndex?: number;\n\n  /** The end index of the range to query */\n  endIndex?: number;\n\n  /**\n   * The maximum number of in-progress matches for this query.\n   * The limit must be > 0 and <= 65536.\n   */\n  matchLimit?: number;\n\n  /**\n   * The maximum start depth for a query cursor.\n   *\n   * This prevents cursors from exploring children nodes at a certain depth.\n   * Note if a pattern includes many children, then they will still be\n   * checked.\n   *\n   * The zero max start depth value can be used as a special behavior and\n   * it helps to destructure a subtree by staying on a node and using\n   * captures for interested parts. Note that the zero max start depth\n   * only limit a search depth for a pattern's root node but other nodes\n   * that are parts of the pattern may be searched at any depth what\n   * defined by the pattern structure.\n   *\n   * Set to `null` to remove the maximum start depth.\n   */\n  maxStartDepth?: number;\n\n  /**\n   * The maximum duration in microseconds that query execution should be allowed to\n   * take before halting.\n   *\n   * If query execution takes longer than this, it will halt early, returning an empty array.\n   */\n  timeoutMicros?: bigint;\n\n  /**\n   * A function that will be called periodically during the execution of the query to check\n   * if query execution should be cancelled. You can also use this to instrument query execution\n   * and check where the query is at in the document. The progress callback takes a single argument,\n   * which is a {@link QueryState} representing the current state of the query.\n   */\n  progressCallback?: (state: QueryState) => void;\n}\n\n/**\n * A stateful object that is passed into the progress callback {@link QueryOptions#progressCallback}\n * to provide the current state of the query.\n */\nexport interface QueryState {\n  /** The byte offset in the document that the query is at. */\n  currentOffset: number;\n}\n\n/** A record of key-value pairs associated with a particular pattern in a {@link Query}. */\nexport type QueryProperties = Record<string, string | null>;\n\n/**\n * A predicate that contains an operator and list of operands.\n */\nexport interface QueryPredicate {\n  /** The operator of the predicate, like `match?`, `eq?`, `set!`, etc. */\n  operator: string;\n\n  /** The operands of the predicate, which are either captures or strings. */\n  operands: PredicateStep[];\n}\n\n/**\n * A particular {@link Node} that has been captured with a particular name within a\n * {@link Query}.\n */\nexport interface QueryCapture {\n  /** The index of the pattern that matched. */\n  patternIndex: number;\n\n  /** The name of the capture */\n  name: string;\n\n  /** The captured node */\n  node: Node;\n\n  /** The properties for predicates declared with the operator `set!`. */\n  setProperties?: QueryProperties;\n\n  /** The properties for predicates declared with the operator `is?`. */\n  assertedProperties?: QueryProperties;\n\n  /** The properties for predicates declared with the operator `is-not?`. */\n  refutedProperties?: QueryProperties;\n}\n\n/** A match of a {@link Query} to a particular set of {@link Node}s. */\nexport interface QueryMatch {\n  /** @deprecated since version 0.25.0, use `patternIndex` instead. */\n  pattern: number;\n\n  /** The index of the pattern that matched. */\n  patternIndex: number;\n\n  /** The captures associated with the match. */\n  captures: QueryCapture[];\n\n  /** The properties for predicates declared with the operator `set!`. */\n  setProperties?: QueryProperties;\n\n  /** The properties for predicates declared with the operator `is?`. */\n  assertedProperties?: QueryProperties;\n\n  /** The properties for predicates declared with the operator `is-not?`. */\n  refutedProperties?: QueryProperties;\n}\n\n/** A quantifier for captures */\nexport const CaptureQuantifier = {\n  Zero: 0,\n  ZeroOrOne: 1,\n  ZeroOrMore: 2,\n  One: 3,\n  OneOrMore: 4\n} as const;\n\n/** A quantifier for captures */\nexport type CaptureQuantifier = typeof CaptureQuantifier[keyof typeof CaptureQuantifier];\n\n/**\n * Predicates are represented as a single array of steps. There are two\n * types of steps, which correspond to the two legal values for\n * the `type` field:\n *\n * - `CapturePredicateStep` - Steps with this type represent names\n *    of captures.\n *\n * - `StringPredicateStep` - Steps with this type represent literal\n *    strings.\n */\nexport type PredicateStep = CapturePredicateStep | StringPredicateStep;\n\n/**\n * A step in a predicate that refers to a capture.\n *\n * The `name` field is the name of the capture.\n */\nexport interface CapturePredicateStep { type: 'capture', name: string }\n\n/**\n * A step in a predicate that refers to a string.\n *\n * The `value` field is the string value.\n */\nexport interface StringPredicateStep { type: 'string', value: string }\n\nconst isCaptureStep = (step: PredicateStep): step is Extract<PredicateStep, { type: 'capture' }> =>\n  step.type === 'capture';\n\nconst isStringStep = (step: PredicateStep): step is Extract<PredicateStep, { type: 'string' }> =>\n  step.type === 'string';\n\n/**\n * @internal\n *\n * A function that checks if a given set of captures matches a particular\n * condition. This is used in the built-in `eq?`, `match?`, and `any-of?`\n * predicates.\n */\nexport type TextPredicate = (captures: QueryCapture[]) => boolean;\n\n/** Error codes returned from tree-sitter query parsing */\nexport const QueryErrorKind = {\n  Syntax: 1,\n  NodeName: 2,\n  FieldName: 3,\n  CaptureName: 4,\n  PatternStructure: 5,\n} as const;\n\n/** An error that occurred while parsing a query string. */\nexport type QueryErrorKind = typeof QueryErrorKind[keyof typeof QueryErrorKind];\n\n/** Information about a {@link QueryError}. */\nexport interface QueryErrorInfo {\n  [QueryErrorKind.NodeName]: { word: string };\n  [QueryErrorKind.FieldName]: { word: string };\n  [QueryErrorKind.CaptureName]: { word: string };\n  [QueryErrorKind.PatternStructure]: { suffix: string };\n  [QueryErrorKind.Syntax]: { suffix: string };\n}\n\n/** Error thrown when parsing a tree-sitter query fails */\nexport class QueryError extends Error {\n  constructor(\n    public kind: QueryErrorKind,\n    public info: QueryErrorInfo[typeof kind],\n    public index: number,\n    public length: number\n  ) {\n    super(QueryError.formatMessage(kind, info));\n    this.name = 'QueryError';\n  }\n\n  /** Formats an error message based on the error kind and info */\n  private static formatMessage(kind: QueryErrorKind, info: QueryErrorInfo[QueryErrorKind]): string {\n    switch (kind) {\n      case QueryErrorKind.NodeName:\n        return `Bad node name '${(info as QueryErrorInfo[2]).word}'`;\n      case QueryErrorKind.FieldName:\n        return `Bad field name '${(info as QueryErrorInfo[3]).word}'`;\n      case QueryErrorKind.CaptureName:\n        return `Bad capture name @${(info as QueryErrorInfo[4]).word}`;\n      case QueryErrorKind.PatternStructure:\n        return `Bad pattern structure at offset ${(info as QueryErrorInfo[5]).suffix}`;\n      case QueryErrorKind.Syntax:\n        return `Bad syntax at offset ${(info as QueryErrorInfo[1]).suffix}`;\n    }\n  }\n}\n\n/**\n * Parses the `eq?` and `not-eq?` predicates in a query, and updates the text predicates.\n */\nfunction parseAnyPredicate(\n  steps: PredicateStep[],\n  index: number,\n  operator: string,\n  textPredicates: TextPredicate[][],\n) {\n  if (steps.length !== 3) {\n    throw new Error(\n      `Wrong number of arguments to \\`#${operator}\\` predicate. Expected 2, got ${steps.length - 1}`\n    );\n  }\n\n  if (!isCaptureStep(steps[1])) {\n    throw new Error(\n      `First argument of \\`#${operator}\\` predicate must be a capture. Got \"${steps[1].value}\"`\n    );\n  }\n\n  const isPositive = operator === 'eq?' || operator === 'any-eq?';\n  const matchAll = !operator.startsWith('any-');\n\n  if (isCaptureStep(steps[2])) {\n    const captureName1 = steps[1].name;\n    const captureName2 = steps[2].name;\n    textPredicates[index].push((captures) => {\n      const nodes1: Node[] = [];\n      const nodes2: Node[] = [];\n      for (const c of captures) {\n        if (c.name === captureName1) nodes1.push(c.node);\n        if (c.name === captureName2) nodes2.push(c.node);\n      }\n      const compare = (n1: { text: string }, n2: { text: string }, positive: boolean) => {\n        return positive ? n1.text === n2.text : n1.text !== n2.text;\n      };\n      return matchAll\n        ? nodes1.every((n1) => nodes2.some((n2) => compare(n1, n2, isPositive)))\n        : nodes1.some((n1) => nodes2.some((n2) => compare(n1, n2, isPositive)));\n    });\n  } else {\n    const captureName = steps[1].name;\n    const stringValue = steps[2].value;\n    const matches = (n: Node) => n.text === stringValue;\n    const doesNotMatch = (n: Node) => n.text !== stringValue;\n    textPredicates[index].push((captures) => {\n      const nodes = [];\n      for (const c of captures) {\n        if (c.name === captureName) nodes.push(c.node);\n      }\n      const test = isPositive ? matches : doesNotMatch;\n      return matchAll ? nodes.every(test) : nodes.some(test);\n    });\n  }\n}\n\n/**\n * Parses the `match?` and `not-match?` predicates in a query, and updates the text predicates.\n */\nfunction parseMatchPredicate(\n  steps: PredicateStep[],\n  index: number,\n  operator: string,\n  textPredicates: TextPredicate[][],\n) {\n  if (steps.length !== 3) {\n    throw new Error(\n      `Wrong number of arguments to \\`#${operator}\\` predicate. Expected 2, got ${steps.length - 1}.`,\n    );\n  }\n\n  if (steps[1].type !== 'capture') {\n    throw new Error(\n      `First argument of \\`#${operator}\\` predicate must be a capture. Got \"${steps[1].value}\".`,\n    );\n  }\n\n  if (steps[2].type !== 'string') {\n    throw new Error(\n      `Second argument of \\`#${operator}\\` predicate must be a string. Got @${steps[2].name}.`,\n    );\n  }\n\n  const isPositive = operator === 'match?' || operator === 'any-match?';\n  const matchAll = !operator.startsWith('any-');\n  const captureName = steps[1].name;\n  const regex = new RegExp(steps[2].value);\n  textPredicates[index].push((captures) => {\n    const nodes = [];\n    for (const c of captures) {\n      if (c.name === captureName) nodes.push(c.node.text);\n    }\n    const test = (text: string, positive: boolean) => {\n      return positive ?\n        regex.test(text) :\n        !regex.test(text);\n    };\n    if (nodes.length === 0) return !isPositive;\n    return matchAll ?\n      nodes.every((text) => test(text, isPositive)) :\n      nodes.some((text) => test(text, isPositive));\n  });\n}\n\n/**\n * Parses the `any-of?` and `not-any-of?` predicates in a query, and updates the text predicates.\n */\nfunction parseAnyOfPredicate(\n  steps: PredicateStep[],\n  index: number,\n  operator: string,\n  textPredicates: TextPredicate[][],\n) {\n  if (steps.length < 2) {\n    throw new Error(\n      `Wrong number of arguments to \\`#${operator}\\` predicate. Expected at least 1. Got ${steps.length - 1}.`,\n    );\n  }\n\n  if (steps[1].type !== 'capture') {\n    throw new Error(\n      `First argument of \\`#${operator}\\` predicate must be a capture. Got \"${steps[1].value}\".`,\n    );\n  }\n\n  const isPositive = operator === 'any-of?';\n  const captureName = steps[1].name;\n\n  const stringSteps = steps.slice(2);\n  if (!stringSteps.every(isStringStep)) {\n    throw new Error(\n      `Arguments to \\`#${operator}\\` predicate must be strings.\".`,\n    );\n  }\n  const values = stringSteps.map((s) => s.value);\n\n  textPredicates[index].push((captures) => {\n    const nodes = [];\n    for (const c of captures) {\n      if (c.name === captureName) nodes.push(c.node.text);\n    }\n    if (nodes.length === 0) return !isPositive;\n    return nodes.every((text) => values.includes(text)) === isPositive;\n  });\n}\n\n/**\n * Parses the `is?` and `is-not?` predicates in a query, and updates the asserted or refuted properties,\n * depending on if the operator is positive or negative.\n */\nfunction parseIsPredicate(\n  steps: PredicateStep[],\n  index: number,\n  operator: string,\n  assertedProperties: QueryProperties[],\n  refutedProperties: QueryProperties[],\n) {\n  if (steps.length < 2 || steps.length > 3) {\n    throw new Error(\n      `Wrong number of arguments to \\`#${operator}\\` predicate. Expected 1 or 2. Got ${steps.length - 1}.`,\n    );\n  }\n\n  if (!steps.every(isStringStep)) {\n    throw new Error(\n      `Arguments to \\`#${operator}\\` predicate must be strings.\".`,\n    );\n  }\n\n  const properties = operator === 'is?' ? assertedProperties : refutedProperties;\n  if (!properties[index]) properties[index] = {};\n  properties[index][steps[1].value] = steps[2]?.value ?? null;\n}\n\n/**\n * Parses the `set!` directive in a query, and updates the set properties.\n */\nfunction parseSetDirective(\n  steps: PredicateStep[],\n  index: number,\n  setProperties: QueryProperties[],\n) {\n  if (steps.length < 2 || steps.length > 3) {\n    throw new Error(`Wrong number of arguments to \\`#set!\\` predicate. Expected 1 or 2. Got ${steps.length - 1}.`);\n  }\n  if (!steps.every(isStringStep)) {\n    throw new Error(`Arguments to \\`#set!\\` predicate must be strings.\".`);\n  }\n  if (!setProperties[index]) setProperties[index] = {};\n  setProperties[index][steps[1].value] = steps[2]?.value ?? null;\n}\n\n/**\n * Parses the predicate at a given step in a pattern, and updates the appropriate\n * predicates or properties.\n */\nfunction parsePattern(\n  index: number,\n  stepType: number,\n  stepValueId: number,\n  captureNames: string[],\n  stringValues: string[],\n  steps: PredicateStep[],\n  textPredicates: TextPredicate[][],\n  predicates: QueryPredicate[][],\n  setProperties: QueryProperties[],\n  assertedProperties: QueryProperties[],\n  refutedProperties: QueryProperties[],\n) {\n  if (stepType === PREDICATE_STEP_TYPE_CAPTURE) {\n    const name = captureNames[stepValueId];\n    steps.push({ type: 'capture', name });\n  } else if (stepType === PREDICATE_STEP_TYPE_STRING) {\n    steps.push({ type: 'string', value: stringValues[stepValueId] });\n  } else if (steps.length > 0) {\n    if (steps[0].type !== 'string') {\n      throw new Error('Predicates must begin with a literal value');\n    }\n\n    const operator = steps[0].value;\n    switch (operator) {\n      case 'any-not-eq?':\n      case 'not-eq?':\n      case 'any-eq?':\n      case 'eq?':\n        parseAnyPredicate(steps, index, operator, textPredicates);\n        break;\n\n      case 'any-not-match?':\n      case 'not-match?':\n      case 'any-match?':\n      case 'match?':\n        parseMatchPredicate(steps, index, operator, textPredicates);\n        break;\n\n      case 'not-any-of?':\n      case 'any-of?':\n        parseAnyOfPredicate(steps, index, operator, textPredicates);\n        break;\n\n      case 'is?':\n      case 'is-not?':\n        parseIsPredicate(steps, index, operator, assertedProperties, refutedProperties);\n        break;\n\n      case 'set!':\n        parseSetDirective(steps, index, setProperties);\n        break;\n\n      default:\n        predicates[index].push({ operator, operands: steps.slice(1) });\n    }\n\n    steps.length = 0;\n  }\n}\n\nexport class Query {\n  /** @internal */\n  private [0] = 0; // Internal handle for Wasm\n\n  /** @internal */\n  private exceededMatchLimit: boolean;\n\n  /** @internal */\n  private textPredicates: TextPredicate[][];\n\n  /** The names of the captures used in the query. */\n  readonly captureNames: string[];\n\n  /** The quantifiers of the captures used in the query. */\n  readonly captureQuantifiers: CaptureQuantifier[][];\n\n  /**\n   * The other user-defined predicates associated with the given index.\n   *\n   * This includes predicates with operators other than:\n   * - `match?`\n   * - `eq?` and `not-eq?`\n   * - `any-of?` and `not-any-of?`\n   * - `is?` and `is-not?`\n   * - `set!`\n   */\n  readonly predicates: QueryPredicate[][];\n\n  /** The properties for predicates with the operator `set!`. */\n  readonly setProperties: QueryProperties[];\n\n  /** The properties for predicates with the operator `is?`. */\n  readonly assertedProperties: QueryProperties[];\n\n  /** The properties for predicates with the operator `is-not?`. */\n  readonly refutedProperties: QueryProperties[];\n\n  /** The maximum number of in-progress matches for this cursor. */\n  matchLimit?: number;\n\n  /**\n   * Create a new query from a string containing one or more S-expression\n   * patterns.\n   *\n   * The query is associated with a particular language, and can only be run\n   * on syntax nodes parsed with that language. References to Queries can be\n   * shared between multiple threads.\n   *\n   * @link {@see https://tree-sitter.github.io/tree-sitter/using-parsers/queries}\n   */\n  constructor(language: Language, source: string) {\n    const sourceLength = C.lengthBytesUTF8(source);\n    const sourceAddress = C._malloc(sourceLength + 1);\n    C.stringToUTF8(source, sourceAddress, sourceLength + 1);\n    const address = C._ts_query_new(\n      language[0],\n      sourceAddress,\n      sourceLength,\n      TRANSFER_BUFFER,\n      TRANSFER_BUFFER + SIZE_OF_INT\n    );\n\n    if (!address) {\n      const errorId = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32') as QueryErrorKind;\n      const errorByte = C.getValue(TRANSFER_BUFFER, 'i32');\n      const errorIndex = C.UTF8ToString(sourceAddress, errorByte).length;\n      const suffix = source.slice(errorIndex, errorIndex + 100).split('\\n')[0];\n      const word = suffix.match(QUERY_WORD_REGEX)?.[0] ?? '';\n      C._free(sourceAddress);\n\n      switch (errorId) {\n        case QueryErrorKind.Syntax:\n          throw new QueryError(QueryErrorKind.Syntax, { suffix: `${errorIndex}: '${suffix}'...` }, errorIndex, 0);\n        case QueryErrorKind.NodeName:\n          throw new QueryError(errorId, { word }, errorIndex, word.length);\n        case QueryErrorKind.FieldName:\n          throw new QueryError(errorId, { word }, errorIndex, word.length);\n        case QueryErrorKind.CaptureName:\n          throw new QueryError(errorId, { word }, errorIndex, word.length);\n        case QueryErrorKind.PatternStructure:\n          throw new QueryError(errorId, { suffix: `${errorIndex}: '${suffix}'...` }, errorIndex, 0);\n      }\n    }\n\n    const stringCount = C._ts_query_string_count(address);\n    const captureCount = C._ts_query_capture_count(address);\n    const patternCount = C._ts_query_pattern_count(address);\n    const captureNames = new Array<string>(captureCount);\n    const captureQuantifiers = new Array<CaptureQuantifier[]>(patternCount);\n    const stringValues = new Array<string>(stringCount);\n\n    // Fill in the capture names\n    for (let i = 0; i < captureCount; i++) {\n      const nameAddress = C._ts_query_capture_name_for_id(\n        address,\n        i,\n        TRANSFER_BUFFER\n      );\n      const nameLength = C.getValue(TRANSFER_BUFFER, 'i32');\n      captureNames[i] = C.UTF8ToString(nameAddress, nameLength);\n    }\n\n    // Fill in the capture quantifiers\n    for (let i = 0; i < patternCount; i++) {\n      const captureQuantifiersArray = new Array<CaptureQuantifier>(captureCount);\n      for (let j = 0; j < captureCount; j++) {\n        const quantifier = C._ts_query_capture_quantifier_for_id(address, i, j);\n        captureQuantifiersArray[j] = quantifier as CaptureQuantifier;\n      }\n      captureQuantifiers[i] = captureQuantifiersArray;\n    }\n\n    // Fill in the string values\n    for (let i = 0; i < stringCount; i++) {\n      const valueAddress = C._ts_query_string_value_for_id(\n        address,\n        i,\n        TRANSFER_BUFFER\n      );\n      const nameLength = C.getValue(TRANSFER_BUFFER, 'i32');\n      stringValues[i] = C.UTF8ToString(valueAddress, nameLength);\n    }\n\n    const setProperties = new Array<QueryProperties>(patternCount);\n    const assertedProperties = new Array<QueryProperties>(patternCount);\n    const refutedProperties = new Array<QueryProperties>(patternCount);\n    const predicates = new Array<QueryPredicate[]>(patternCount);\n    const textPredicates = new Array<TextPredicate[]>(patternCount);\n\n    // Parse the predicates, and add the appropriate predicates or properties\n    for (let i = 0; i < patternCount; i++) {\n      const predicatesAddress = C._ts_query_predicates_for_pattern(address, i, TRANSFER_BUFFER);\n      const stepCount = C.getValue(TRANSFER_BUFFER, 'i32');\n\n      predicates[i] = [];\n      textPredicates[i] = [];\n\n      const steps = new Array<PredicateStep>();\n\n      let stepAddress = predicatesAddress;\n      for (let j = 0; j < stepCount; j++) {\n        const stepType = C.getValue(stepAddress, 'i32');\n        stepAddress += SIZE_OF_INT;\n\n        const stepValueId = C.getValue(stepAddress, 'i32');\n        stepAddress += SIZE_OF_INT;\n\n        parsePattern(\n          i,\n          stepType,\n          stepValueId,\n          captureNames,\n          stringValues,\n          steps,\n          textPredicates,\n          predicates,\n          setProperties,\n          assertedProperties,\n          refutedProperties,\n        );\n      }\n\n      Object.freeze(textPredicates[i]);\n      Object.freeze(predicates[i]);\n      Object.freeze(setProperties[i]);\n      Object.freeze(assertedProperties[i]);\n      Object.freeze(refutedProperties[i]);\n    }\n\n    C._free(sourceAddress);\n\n\n    this[0] = address;\n    this.captureNames = captureNames;\n    this.captureQuantifiers = captureQuantifiers;\n    this.textPredicates = textPredicates;\n    this.predicates = predicates;\n    this.setProperties = setProperties;\n    this.assertedProperties = assertedProperties;\n    this.refutedProperties = refutedProperties;\n    this.exceededMatchLimit = false;\n  }\n\n  /** Delete the query, freeing its resources. */\n  delete(): void {\n    C._ts_query_delete(this[0]);\n    this[0] = 0;\n  }\n\n  /**\n   * Iterate over all of the matches in the order that they were found.\n   *\n   * Each match contains the index of the pattern that matched, and a list of\n   * captures. Because multiple patterns can match the same set of nodes,\n   * one match may contain captures that appear *before* some of the\n   * captures from a previous match.\n   *\n   * @param {Node} node - The node to execute the query on.\n   *\n   * @param {QueryOptions} options - Options for query execution.\n   */\n  matches(\n    node: Node,\n    options: QueryOptions = {}\n  ): QueryMatch[] {\n    const startPosition = options.startPosition ?? ZERO_POINT;\n    const endPosition = options.endPosition ?? ZERO_POINT;\n    const startIndex = options.startIndex ?? 0;\n    const endIndex = options.endIndex ?? 0;\n    const matchLimit = options.matchLimit ?? 0xFFFFFFFF;\n    const maxStartDepth = options.maxStartDepth ?? 0xFFFFFFFF;\n    const timeoutMicros = options.timeoutMicros ?? 0n;\n    const progressCallback = options.progressCallback;\n\n    if (typeof matchLimit !== 'number') {\n      throw new Error('Arguments must be numbers');\n    }\n    this.matchLimit = matchLimit;\n\n    if (endIndex !== 0 && startIndex > endIndex) {\n      throw new Error('`startIndex` cannot be greater than `endIndex`');\n    }\n\n    if (endPosition !== ZERO_POINT && (\n      startPosition.row > endPosition.row ||\n      (startPosition.row === endPosition.row && startPosition.column > endPosition.column)\n    )) {\n      throw new Error('`startPosition` cannot be greater than `endPosition`');\n    }\n\n    if (progressCallback) {\n      C.currentQueryProgressCallback = progressCallback;\n    }\n\n    marshalNode(node);\n\n    C._ts_query_matches_wasm(\n      this[0],\n      node.tree[0],\n      startPosition.row,\n      startPosition.column,\n      endPosition.row,\n      endPosition.column,\n      startIndex,\n      endIndex,\n      matchLimit,\n      maxStartDepth,\n      timeoutMicros,\n    );\n\n    const rawCount = C.getValue(TRANSFER_BUFFER, 'i32');\n    const startAddress = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32');\n    const didExceedMatchLimit = C.getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, 'i32');\n    const result = new Array<QueryMatch>(rawCount);\n    this.exceededMatchLimit = Boolean(didExceedMatchLimit);\n\n    let filteredCount = 0;\n    let address = startAddress;\n    for (let i = 0; i < rawCount; i++) {\n      const patternIndex = C.getValue(address, 'i32');\n      address += SIZE_OF_INT;\n      const captureCount = C.getValue(address, 'i32');\n      address += SIZE_OF_INT;\n\n      const captures = new Array<QueryCapture>(captureCount);\n      address = unmarshalCaptures(this, node.tree, address, patternIndex, captures);\n\n      if (this.textPredicates[patternIndex].every((p) => p(captures))) {\n        result[filteredCount] = { pattern: patternIndex, patternIndex, captures };\n        const setProperties = this.setProperties[patternIndex];\n        result[filteredCount].setProperties = setProperties;\n        const assertedProperties = this.assertedProperties[patternIndex];\n        result[filteredCount].assertedProperties = assertedProperties;\n        const refutedProperties = this.refutedProperties[patternIndex];\n        result[filteredCount].refutedProperties = refutedProperties;\n        filteredCount++;\n      }\n    }\n    result.length = filteredCount;\n\n    C._free(startAddress);\n    C.currentQueryProgressCallback = null;\n    return result;\n  }\n\n  /**\n   * Iterate over all of the individual captures in the order that they\n   * appear.\n   *\n   * This is useful if you don't care about which pattern matched, and just\n   * want a single, ordered sequence of captures.\n   *\n   * @param {Node} node - The node to execute the query on.\n   *\n   * @param {QueryOptions} options - Options for query execution.\n   */\n  captures(\n    node: Node,\n    options: QueryOptions = {}\n  ): QueryCapture[] {\n    const startPosition = options.startPosition ?? ZERO_POINT;\n    const endPosition = options.endPosition ?? ZERO_POINT;\n    const startIndex = options.startIndex ?? 0;\n    const endIndex = options.endIndex ?? 0;\n    const matchLimit = options.matchLimit ?? 0xFFFFFFFF;\n    const maxStartDepth = options.maxStartDepth ?? 0xFFFFFFFF;\n    const timeoutMicros = options.timeoutMicros ?? 0n;\n    const progressCallback = options.progressCallback;\n\n    if (typeof matchLimit !== 'number') {\n      throw new Error('Arguments must be numbers');\n    }\n    this.matchLimit = matchLimit;\n\n    if (endIndex !== 0 && startIndex > endIndex) {\n      throw new Error('`startIndex` cannot be greater than `endIndex`');\n    }\n\n    if (endPosition !== ZERO_POINT && (\n      startPosition.row > endPosition.row ||\n      (startPosition.row === endPosition.row && startPosition.column > endPosition.column)\n    )) {\n      throw new Error('`startPosition` cannot be greater than `endPosition`');\n    }\n\n    if (progressCallback) {\n      C.currentQueryProgressCallback = progressCallback;\n    }\n\n    marshalNode(node);\n\n    C._ts_query_captures_wasm(\n      this[0],\n      node.tree[0],\n      startPosition.row,\n      startPosition.column,\n      endPosition.row,\n      endPosition.column,\n      startIndex,\n      endIndex,\n      matchLimit,\n      maxStartDepth,\n      timeoutMicros,\n    );\n\n    const count = C.getValue(TRANSFER_BUFFER, 'i32');\n    const startAddress = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32');\n    const didExceedMatchLimit = C.getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, 'i32');\n    const result = new Array<QueryCapture>();\n    this.exceededMatchLimit = Boolean(didExceedMatchLimit);\n\n    const captures = new Array<QueryCapture>();\n    let address = startAddress;\n    for (let i = 0; i < count; i++) {\n      const patternIndex = C.getValue(address, 'i32');\n      address += SIZE_OF_INT;\n      const captureCount = C.getValue(address, 'i32');\n      address += SIZE_OF_INT;\n      const captureIndex = C.getValue(address, 'i32');\n      address += SIZE_OF_INT;\n\n      captures.length = captureCount;\n      address = unmarshalCaptures(this, node.tree, address, patternIndex, captures);\n\n      if (this.textPredicates[patternIndex].every(p => p(captures))) {\n        const capture = captures[captureIndex];\n        const setProperties = this.setProperties[patternIndex];\n        capture.setProperties = setProperties;\n        const assertedProperties = this.assertedProperties[patternIndex];\n        capture.assertedProperties = assertedProperties;\n        const refutedProperties = this.refutedProperties[patternIndex];\n        capture.refutedProperties = refutedProperties;\n        result.push(capture);\n      }\n    }\n\n    C._free(startAddress);\n    C.currentQueryProgressCallback = null;\n    return result;\n  }\n\n  /** Get the predicates for a given pattern. */\n  predicatesForPattern(patternIndex: number): QueryPredicate[] {\n    return this.predicates[patternIndex];\n  }\n\n  /**\n   * Disable a certain capture within a query.\n   *\n   * This prevents the capture from being returned in matches, and also\n   * avoids any resource usage associated with recording the capture.\n   */\n  disableCapture(captureName: string): void {\n    const captureNameLength = C.lengthBytesUTF8(captureName);\n    const captureNameAddress = C._malloc(captureNameLength + 1);\n    C.stringToUTF8(captureName, captureNameAddress, captureNameLength + 1);\n    C._ts_query_disable_capture(this[0], captureNameAddress, captureNameLength);\n    C._free(captureNameAddress);\n  }\n\n  /**\n   * Disable a certain pattern within a query.\n   *\n   * This prevents the pattern from matching, and also avoids any resource\n   * usage associated with the pattern. This throws an error if the pattern\n   * index is out of bounds.\n   */\n  disablePattern(patternIndex: number): void {\n    if (patternIndex >= this.predicates.length) {\n      throw new Error(\n        `Pattern index is ${patternIndex} but the pattern count is ${this.predicates.length}`\n      );\n    }\n    C._ts_query_disable_pattern(this[0], patternIndex);\n  }\n\n  /**\n   * Check if, on its last execution, this cursor exceeded its maximum number\n   * of in-progress matches.\n   */\n  didExceedMatchLimit(): boolean {\n    return this.exceededMatchLimit;\n  }\n\n  /** Get the byte offset where the given pattern starts in the query's source. */\n  startIndexForPattern(patternIndex: number): number {\n    if (patternIndex >= this.predicates.length) {\n      throw new Error(\n        `Pattern index is ${patternIndex} but the pattern count is ${this.predicates.length}`\n      );\n    }\n    return C._ts_query_start_byte_for_pattern(this[0], patternIndex);\n  }\n\n  /** Get the byte offset where the given pattern ends in the query's source. */\n  endIndexForPattern(patternIndex: number): number {\n    if (patternIndex >= this.predicates.length) {\n      throw new Error(\n        `Pattern index is ${patternIndex} but the pattern count is ${this.predicates.length}`\n      );\n    }\n    return C._ts_query_end_byte_for_pattern(this[0], patternIndex);\n  }\n\n  /** Get the number of patterns in the query. */\n  patternCount(): number {\n    return C._ts_query_pattern_count(this[0]);\n  }\n\n  /** Get the index for a given capture name. */\n  captureIndexForName(captureName: string): number {\n    return this.captureNames.indexOf(captureName);\n  }\n\n  /** Check if a given pattern within a query has a single root node. */\n  isPatternRooted(patternIndex: number): boolean {\n    return C._ts_query_is_pattern_rooted(this[0], patternIndex) === 1;\n  }\n\n  /** Check if a given pattern within a query has a single root node. */\n  isPatternNonLocal(patternIndex: number): boolean {\n    return C._ts_query_is_pattern_non_local(this[0], patternIndex) === 1;\n  }\n\n  /**\n   * Check if a given step in a query is 'definite'.\n   *\n   * A query step is 'definite' if its parent pattern will be guaranteed to\n   * match successfully once it reaches the step.\n   */\n  isPatternGuaranteedAtStep(byteIndex: number): boolean {\n    return C._ts_query_is_pattern_guaranteed_at_step(this[0], byteIndex) === 1;\n  }\n}\n", "import { C, INTERNAL, Internal, assertInternal, SIZE_OF_INT, SIZE_OF_SHORT } from './constants';\nimport { LookaheadIterator } from './lookahead_iterator';\nimport { unmarshalLanguageMetadata } from './marshal';\nimport { TRANSFER_BUFFER } from './parser';\nimport { Query } from './query';\n\nconst LANGUAGE_FUNCTION_REGEX = /^tree_sitter_\\w+$/;\n\nexport interface LanguageMetadata {\n  readonly major_version: number;\n  readonly minor_version: number;\n  readonly patch_version: number;\n}\n\n/**\n * An opaque object that defines how to parse a particular language.\n * The code for each `Language` is generated by the Tree-sitter CLI.\n */\nexport class Language {\n  /** @internal */\n  private [0] = 0; // Internal handle for Wasm\n\n  /**\n   * A list of all node types in the language. The index of each type in this\n   * array is its node type id.\n   */\n  types: string[];\n\n  /**\n   * A list of all field names in the language. The index of each field name in\n   * this array is its field id.\n   */\n  fields: (string | null)[];\n\n  /** @internal */\n  constructor(internal: Internal, address: number) {\n    assertInternal(internal);\n    this[0] = address;\n    this.types = new Array<string>(C._ts_language_symbol_count(this[0]));\n    for (let i = 0, n = this.types.length; i < n; i++) {\n      if (C._ts_language_symbol_type(this[0], i) < 2) {\n        this.types[i] = C.UTF8ToString(C._ts_language_symbol_name(this[0], i));\n      }\n    }\n    this.fields = new Array<string>(C._ts_language_field_count(this[0]) + 1);\n    for (let i = 0, n = this.fields.length; i < n; i++) {\n      const fieldName = C._ts_language_field_name_for_id(this[0], i);\n      if (fieldName !== 0) {\n        this.fields[i] = C.UTF8ToString(fieldName);\n      } else {\n        this.fields[i] = null;\n      }\n    }\n  }\n\n\n  /**\n   * Gets the name of the language.\n   */\n  get name(): string | null {\n    const ptr = C._ts_language_name(this[0]);\n    if (ptr === 0) return null;\n    return C.UTF8ToString(ptr);\n  }\n\n  /**\n   * @deprecated since version 0.25.0, use {@link Language#abiVersion} instead\n   * Gets the version of the language.\n   */\n  get version(): number {\n    return C._ts_language_version(this[0]);\n  }\n\n  /**\n   * Gets the ABI version of the language.\n   */\n  get abiVersion(): number {\n    return C._ts_language_abi_version(this[0]);\n  }\n\n  /**\n  * Get the metadata for this language. This information is generated by the\n  * CLI, and relies on the language author providing the correct metadata in\n  * the language's `tree-sitter.json` file.\n  */\n  get metadata(): LanguageMetadata | null {\n    C._ts_language_metadata(this[0]);\n    const length = C.getValue(TRANSFER_BUFFER, 'i32');\n    const address = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32');\n    if (length === 0) return null;\n    return unmarshalLanguageMetadata(address);\n  }\n\n  /**\n   * Gets the number of fields in the language.\n   */\n  get fieldCount(): number {\n    return this.fields.length - 1;\n  }\n\n  /**\n   * Gets the number of states in the language.\n   */\n  get stateCount(): number {\n    return C._ts_language_state_count(this[0]);\n  }\n\n  /**\n   * Get the field id for a field name.\n   */\n  fieldIdForName(fieldName: string): number | null {\n    const result = this.fields.indexOf(fieldName);\n    return result !== -1 ? result : null;\n  }\n\n  /**\n   * Get the field name for a field id.\n   */\n  fieldNameForId(fieldId: number): string | null {\n    return this.fields[fieldId] ?? null;\n  }\n\n  /**\n   * Get the node type id for a node type name.\n   */\n  idForNodeType(type: string, named: boolean): number | null {\n    const typeLength = C.lengthBytesUTF8(type);\n    const typeAddress = C._malloc(typeLength + 1);\n    C.stringToUTF8(type, typeAddress, typeLength + 1);\n    const result = C._ts_language_symbol_for_name(this[0], typeAddress, typeLength, named ? 1 : 0);\n    C._free(typeAddress);\n    return result || null;\n  }\n\n  /**\n   * Gets the number of node types in the language.\n   */\n  get nodeTypeCount(): number {\n    return C._ts_language_symbol_count(this[0]);\n  }\n\n  /**\n   * Get the node type name for a node type id.\n   */\n  nodeTypeForId(typeId: number): string | null {\n    const name = C._ts_language_symbol_name(this[0], typeId);\n    return name ? C.UTF8ToString(name) : null;\n  }\n\n  /**\n   * Check if a node type is named.\n   *\n   * @see {@link https://tree-sitter.github.io/tree-sitter/using-parsers/2-basic-parsing.html#named-vs-anonymous-nodes}\n   */\n  nodeTypeIsNamed(typeId: number): boolean {\n    return C._ts_language_type_is_named_wasm(this[0], typeId) ? true : false;\n  }\n\n  /**\n   * Check if a node type is visible.\n   */\n  nodeTypeIsVisible(typeId: number): boolean {\n    return C._ts_language_type_is_visible_wasm(this[0], typeId) ? true : false;\n  }\n\n  /**\n   * Get the supertypes ids of this language.\n   *\n   * @see {@link https://tree-sitter.github.io/tree-sitter/using-parsers/6-static-node-types.html?highlight=supertype#supertype-nodes}\n   */\n  get supertypes(): number[] {\n    C._ts_language_supertypes_wasm(this[0]);\n    const count = C.getValue(TRANSFER_BUFFER, 'i32');\n    const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32');\n    const result = new Array<number>(count);\n\n    if (count > 0) {\n      let address = buffer;\n      for (let i = 0; i < count; i++) {\n        result[i] = C.getValue(address, 'i16');\n        address += SIZE_OF_SHORT;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Get the subtype ids for a given supertype node id.\n   */\n  subtypes(supertype: number): number[] {\n    C._ts_language_subtypes_wasm(this[0], supertype);\n    const count = C.getValue(TRANSFER_BUFFER, 'i32');\n    const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32');\n    const result = new Array<number>(count);\n\n    if (count > 0) {\n      let address = buffer;\n      for (let i = 0; i < count; i++) {\n        result[i] = C.getValue(address, 'i16');\n        address += SIZE_OF_SHORT;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Get the next state id for a given state id and node type id.\n   */\n  nextState(stateId: number, typeId: number): number {\n    return C._ts_language_next_state(this[0], stateId, typeId);\n  }\n\n  /**\n   * Create a new lookahead iterator for this language and parse state.\n   *\n   * This returns `null` if state is invalid for this language.\n   *\n   * Iterating {@link LookaheadIterator} will yield valid symbols in the given\n   * parse state. Newly created lookahead iterators will return the `ERROR`\n   * symbol from {@link LookaheadIterator#currentType}.\n   *\n   * Lookahead iterators can be useful for generating suggestions and improving\n   * syntax error diagnostics. To get symbols valid in an `ERROR` node, use the\n   * lookahead iterator on its first leaf node state. For `MISSING` nodes, a\n   * lookahead iterator created on the previous non-extra leaf node may be\n   * appropriate.\n   */\n  lookaheadIterator(stateId: number): LookaheadIterator | null {\n    const address = C._ts_lookahead_iterator_new(this[0], stateId);\n    if (address) return new LookaheadIterator(INTERNAL, address, this);\n    return null;\n  }\n\n  /**\n   * @deprecated since version 0.25.0, call `new` on a {@link Query} instead\n   *\n   * Create a new query from a string containing one or more S-expression\n   * patterns.\n   *\n   * The query is associated with a particular language, and can only be run\n   * on syntax nodes parsed with that language. References to Queries can be\n   * shared between multiple threads.\n   *\n   * @link {@see https://tree-sitter.github.io/tree-sitter/using-parsers/queries}\n   */\n  query(source: string): Query {\n    console.warn('Language.query is deprecated. Use new Query(language, source) instead.');\n    return new Query(this, source);\n  }\n\n  /**\n   * Load a language from a WebAssembly module.\n   * The module can be provided as a path to a file or as a buffer.\n   */\n  static async load(input: string | Uint8Array): Promise<Language> {\n    let binary: Uint8Array | WebAssembly.Module;\n    if (input instanceof Uint8Array) {\n      binary = input;\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    } else if (globalThis.process?.versions.node) {\n      const fs: typeof import('fs/promises') = await import('fs/promises');\n      binary = await fs.readFile(input);\n    } else {\n      const response = await fetch(input);\n\n      if (!response.ok){\n        const body = await response.text();\n        throw new Error(`Language.load failed with status ${response.status}.\\n\\n${body}`);\n      }\n\n      const retryResp = response.clone();\n      try {\n        binary = await WebAssembly.compileStreaming(response);\n      } catch (reason) {\n        console.error('wasm streaming compile failed:', reason);\n        console.error('falling back to ArrayBuffer instantiation');\n        // fallback, probably because of bad MIME type\n        binary = new Uint8Array(await retryResp.arrayBuffer())\n      }\n    }\n\n    const mod = await C.loadWebAssemblyModule(binary, { loadAsync: true });\n    const symbolNames = Object.keys(mod);\n    const functionName = symbolNames.find((key) => LANGUAGE_FUNCTION_REGEX.test(key) &&\n      !key.includes('external_scanner_'));\n    if (!functionName) {\n        console.log(`Couldn't find language function in Wasm file. Symbols:\\n${JSON.stringify(symbolNames, null, 2)}`);\n        throw new Error('Language.load failed: no language function found in Wasm file');\n    }\n    const languageAddress = mod[functionName]();\n    return new Language(INTERNAL, languageAddress);\n  }\n}\n", "// This code implements the `-sMODULARIZE` settings by taking the generated\n// JS program code (INNER_JS_CODE) and wrapping it in a factory function.\n\n// When targetting node and ES6 we use `await import ..` in the generated code\n// so the outer function needs to be marked as async.\nasync function Module(moduleArg = {}) {\n  var moduleRtn;\n\n// include: shell.js\n// The Module object: Our interface to the outside world. We import\n// and export values on it. There are various ways Module can be used:\n// 1. Not defined. We create it here\n// 2. A function parameter, function(moduleArg) => Promise<Module>\n// 3. pre-run appended it, var Module = {}; ..generated code..\n// 4. External script tag defines var Module.\n// We need to check if Module already exists (e.g. case 3 above).\n// Substitution will be replaced with actual code on later stage of the build,\n// this way Closure Compiler will not mangle it (e.g. case 4. above).\n// Note that if you want to run closure, and also to use Module\n// after the generated code, you will need to define   var Module = {};\n// before the code. Then that object will be used in the code, and you\n// can continue to use Module afterwards as well.\nvar Module = moduleArg;\n\n// Determine the runtime environment we are in. You can customize this by\n// setting the ENVIRONMENT setting at compile time (see settings.js).\n// Attempt to auto-detect the environment\nvar ENVIRONMENT_IS_WEB = typeof window == \"object\";\n\nvar ENVIRONMENT_IS_WORKER = typeof WorkerGlobalScope != \"undefined\";\n\n// N.b. Electron.js environment is simultaneously a NODE-environment, but\n// also a web environment.\nvar ENVIRONMENT_IS_NODE = typeof process == \"object\" && process.versions?.node && process.type != \"renderer\";\n\nvar ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n\nif (ENVIRONMENT_IS_NODE) {\n  // When building an ES module `require` is not normally available.\n  // We need to use `createRequire()` to construct the require()` function.\n  const {createRequire} = await import(\"module\");\n  /** @suppress{duplicate} */ var require = createRequire(import.meta.url);\n}\n\n// --pre-jses are emitted after the Module integration code, so that they can\n// refer to Module (if they choose; they can also define Module)\n// include: lib/binding_web/lib/prefix.js\nModule.currentQueryProgressCallback = null;\n\nModule.currentProgressCallback = null;\n\nModule.currentLogCallback = null;\n\nModule.currentParseCallback = null;\n\n// end include: lib/binding_web/lib/prefix.js\nvar arguments_ = [];\n\nvar thisProgram = \"./this.program\";\n\nvar quit_ = (status, toThrow) => {\n  throw toThrow;\n};\n\nvar _scriptName = import.meta.url;\n\n// `/` should be present at the end if `scriptDirectory` is not empty\nvar scriptDirectory = \"\";\n\nfunction locateFile(path) {\n  if (Module[\"locateFile\"]) {\n    return Module[\"locateFile\"](path, scriptDirectory);\n  }\n  return scriptDirectory + path;\n}\n\n// Hooks that are implemented differently in different runtime environments.\nvar readAsync, readBinary;\n\nif (ENVIRONMENT_IS_NODE) {\n  // These modules will usually be used on Node.js. Load them eagerly to avoid\n  // the complexity of lazy-loading.\n  var fs = require(\"fs\");\n  if (_scriptName.startsWith(\"file:\")) {\n    scriptDirectory = require(\"path\").dirname(require(\"url\").fileURLToPath(_scriptName)) + \"/\";\n  }\n  // include: node_shell_read.js\n  readBinary = filename => {\n    // We need to re-wrap `file://` strings to URLs.\n    filename = isFileURI(filename) ? new URL(filename) : filename;\n    var ret = fs.readFileSync(filename);\n    return ret;\n  };\n  readAsync = async (filename, binary = true) => {\n    // See the comment in the `readBinary` function.\n    filename = isFileURI(filename) ? new URL(filename) : filename;\n    var ret = fs.readFileSync(filename, binary ? undefined : \"utf8\");\n    return ret;\n  };\n  // end include: node_shell_read.js\n  if (process.argv.length > 1) {\n    thisProgram = process.argv[1].replace(/\\\\/g, \"/\");\n  }\n  arguments_ = process.argv.slice(2);\n  quit_ = (status, toThrow) => {\n    process.exitCode = status;\n    throw toThrow;\n  };\n} else // Note that this includes Node.js workers when relevant (pthreads is enabled).\n// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and\n// ENVIRONMENT_IS_NODE.\nif (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n  try {\n    scriptDirectory = new URL(\".\", _scriptName).href;\n  } catch {}\n  {\n    // include: web_or_worker_shell_read.js\n    if (ENVIRONMENT_IS_WORKER) {\n      readBinary = url => {\n        var xhr = new XMLHttpRequest;\n        xhr.open(\"GET\", url, false);\n        xhr.responseType = \"arraybuffer\";\n        xhr.send(null);\n        return new Uint8Array(/** @type{!ArrayBuffer} */ (xhr.response));\n      };\n    }\n    readAsync = async url => {\n      // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.\n      // See https://github.com/github/fetch/pull/92#issuecomment-140665932\n      // Cordova or Electron apps are typically loaded from a file:// url.\n      // So use XHR on webview if URL is a file URL.\n      if (isFileURI(url)) {\n        return new Promise((resolve, reject) => {\n          var xhr = new XMLHttpRequest;\n          xhr.open(\"GET\", url, true);\n          xhr.responseType = \"arraybuffer\";\n          xhr.onload = () => {\n            if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) {\n              // file URLs can return 0\n              resolve(xhr.response);\n              return;\n            }\n            reject(xhr.status);\n          };\n          xhr.onerror = reject;\n          xhr.send(null);\n        });\n      }\n      var response = await fetch(url, {\n        credentials: \"same-origin\"\n      });\n      if (response.ok) {\n        return response.arrayBuffer();\n      }\n      throw new Error(response.status + \" : \" + response.url);\n    };\n  }\n} else {}\n\nvar out = console.log.bind(console);\n\nvar err = console.error.bind(console);\n\n// end include: shell.js\n// include: preamble.js\n// === Preamble library stuff ===\n// Documentation for the public APIs defined in this file must be updated in:\n//    site/source/docs/api_reference/preamble.js.rst\n// A prebuilt local version of the documentation is available at:\n//    site/build/text/docs/api_reference/preamble.js.txt\n// You can also build docs locally as HTML or other formats in site/\n// An online HTML version (which may be of a different version of Emscripten)\n//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\nvar dynamicLibraries = [];\n\nvar wasmBinary;\n\n// Wasm globals\n//========================================\n// Runtime essentials\n//========================================\n// whether we are quitting the application. no code should run after this.\n// set in exit() and abort()\nvar ABORT = false;\n\n// set by exit() and abort().  Passed to 'onExit' handler.\n// NOTE: This is also used as the process return code code in shell environments\n// but only when noExitRuntime is false.\nvar EXITSTATUS;\n\n// In STRICT mode, we only define assert() when ASSERTIONS is set.  i.e. we\n// don't define it at all in release modes.  This matches the behaviour of\n// MINIMAL_RUNTIME.\n// TODO(sbc): Make this the default even without STRICT enabled.\n/** @type {function(*, string=)} */ function assert(condition, text) {\n  if (!condition) {\n    // This build was created without ASSERTIONS defined.  `assert()` should not\n    // ever be called in this configuration but in case there are callers in\n    // the wild leave this simple abort() implementation here for now.\n    abort(text);\n  }\n}\n\n/**\n * Indicates whether filename is delivered via file protocol (as opposed to http/https)\n * @noinline\n */ var isFileURI = filename => filename.startsWith(\"file://\");\n\n// include: runtime_common.js\n// include: runtime_stack_check.js\n// end include: runtime_stack_check.js\n// include: runtime_exceptions.js\n// end include: runtime_exceptions.js\n// include: runtime_debug.js\n// end include: runtime_debug.js\nvar readyPromiseResolve, readyPromiseReject;\n\n// Memory management\nvar wasmMemory;\n\nvar /** @type {!Int8Array} */ HEAP8, /** @type {!Uint8Array} */ HEAPU8, /** @type {!Int16Array} */ HEAP16, /** @type {!Uint16Array} */ HEAPU16, /** @type {!Int32Array} */ HEAP32, /** @type {!Uint32Array} */ HEAPU32, /** @type {!Float32Array} */ HEAPF32, /** @type {!Float64Array} */ HEAPF64;\n\n// BigInt64Array type is not correctly defined in closure\nvar /** not-@type {!BigInt64Array} */ HEAP64, /* BigUint64Array type is not correctly defined in closure\n/** not-@type {!BigUint64Array} */ HEAPU64;\n\n/** @type {!DataView} */ var HEAP_DATA_VIEW;\n\nvar runtimeInitialized = false;\n\nfunction updateMemoryViews() {\n  var b = wasmMemory.buffer;\n  Module[\"HEAP8\"] = HEAP8 = new Int8Array(b);\n  Module[\"HEAP16\"] = HEAP16 = new Int16Array(b);\n  Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(b);\n  Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(b);\n  Module[\"HEAP32\"] = HEAP32 = new Int32Array(b);\n  Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(b);\n  Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(b);\n  Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(b);\n  Module[\"HEAP64\"] = HEAP64 = new BigInt64Array(b);\n  Module[\"HEAPU64\"] = HEAPU64 = new BigUint64Array(b);\n  Module[\"HEAP_DATA_VIEW\"] = HEAP_DATA_VIEW = new DataView(b);\n  LE_HEAP_UPDATE();\n}\n\n// In non-standalone/normal mode, we create the memory here.\n// include: runtime_init_memory.js\n// Create the wasm memory. (Note: this only applies if IMPORTED_MEMORY is defined)\n// check for full engine support (use string 'subarray' to avoid closure compiler confusion)\nfunction initMemory() {\n  if (Module[\"wasmMemory\"]) {\n    wasmMemory = Module[\"wasmMemory\"];\n  } else {\n    var INITIAL_MEMORY = Module[\"INITIAL_MEMORY\"] || 33554432;\n    /** @suppress {checkTypes} */ wasmMemory = new WebAssembly.Memory({\n      \"initial\": INITIAL_MEMORY / 65536,\n      // In theory we should not need to emit the maximum if we want \"unlimited\"\n      // or 4GB of memory, but VMs error on that atm, see\n      // https://github.com/emscripten-core/emscripten/issues/14130\n      // And in the pthreads case we definitely need to emit a maximum. So\n      // always emit one.\n      \"maximum\": 32768\n    });\n  }\n  updateMemoryViews();\n}\n\n// end include: runtime_init_memory.js\n// include: memoryprofiler.js\n// end include: memoryprofiler.js\n// end include: runtime_common.js\nvar __RELOC_FUNCS__ = [];\n\nfunction preRun() {\n  if (Module[\"preRun\"]) {\n    if (typeof Module[\"preRun\"] == \"function\") Module[\"preRun\"] = [ Module[\"preRun\"] ];\n    while (Module[\"preRun\"].length) {\n      addOnPreRun(Module[\"preRun\"].shift());\n    }\n  }\n  // Begin ATPRERUNS hooks\n  callRuntimeCallbacks(onPreRuns);\n}\n\nfunction initRuntime() {\n  runtimeInitialized = true;\n  callRuntimeCallbacks(__RELOC_FUNCS__);\n  // No ATINITS hooks\n  wasmExports[\"__wasm_call_ctors\"]();\n  // Begin ATPOSTCTORS hooks\n  callRuntimeCallbacks(onPostCtors);\n}\n\nfunction preMain() {}\n\nfunction postRun() {\n  // PThreads reuse the runtime from the main thread.\n  if (Module[\"postRun\"]) {\n    if (typeof Module[\"postRun\"] == \"function\") Module[\"postRun\"] = [ Module[\"postRun\"] ];\n    while (Module[\"postRun\"].length) {\n      addOnPostRun(Module[\"postRun\"].shift());\n    }\n  }\n  // Begin ATPOSTRUNS hooks\n  callRuntimeCallbacks(onPostRuns);\n}\n\n// A counter of dependencies for calling run(). If we need to\n// do asynchronous work before running, increment this and\n// decrement it. Incrementing must happen in a place like\n// Module.preRun (used by emcc to add file preloading).\n// Note that you can add dependencies in preRun, even though\n// it happens right before run - run will be postponed until\n// the dependencies are met.\nvar runDependencies = 0;\n\nvar dependenciesFulfilled = null;\n\n// overridden to take different actions when all run dependencies are fulfilled\nfunction addRunDependency(id) {\n  runDependencies++;\n  Module[\"monitorRunDependencies\"]?.(runDependencies);\n}\n\nfunction removeRunDependency(id) {\n  runDependencies--;\n  Module[\"monitorRunDependencies\"]?.(runDependencies);\n  if (runDependencies == 0) {\n    if (dependenciesFulfilled) {\n      var callback = dependenciesFulfilled;\n      dependenciesFulfilled = null;\n      callback();\n    }\n  }\n}\n\n/** @param {string|number=} what */ function abort(what) {\n  Module[\"onAbort\"]?.(what);\n  what = \"Aborted(\" + what + \")\";\n  // TODO(sbc): Should we remove printing and leave it up to whoever\n  // catches the exception?\n  err(what);\n  ABORT = true;\n  what += \". Build with -sASSERTIONS for more info.\";\n  // Use a wasm runtime error, because a JS error might be seen as a foreign\n  // exception, which means we'd run destructors on it. We need the error to\n  // simply make the program stop.\n  // FIXME This approach does not work in Wasm EH because it currently does not assume\n  // all RuntimeErrors are from traps; it decides whether a RuntimeError is from\n  // a trap or not based on a hidden field within the object. So at the moment\n  // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that\n  // allows this in the wasm spec.\n  // Suppress closure compiler warning here. Closure compiler's builtin extern\n  // definition for WebAssembly.RuntimeError claims it takes no arguments even\n  // though it can.\n  // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.\n  /** @suppress {checkTypes} */ var e = new WebAssembly.RuntimeError(what);\n  readyPromiseReject?.(e);\n  // Throw the error whether or not MODULARIZE is set because abort is used\n  // in code paths apart from instantiation where an exception is expected\n  // to be thrown when abort is called.\n  throw e;\n}\n\nvar wasmBinaryFile;\n\nfunction findWasmBinary() {\n  if (Module[\"locateFile\"]) {\n    return locateFile(\"web-tree-sitter.wasm\");\n  }\n  // Use bundler-friendly `new URL(..., import.meta.url)` pattern; works in browsers too.\n  return new URL(\"web-tree-sitter.wasm\", import.meta.url).href;\n}\n\nfunction getBinarySync(file) {\n  if (file == wasmBinaryFile && wasmBinary) {\n    return new Uint8Array(wasmBinary);\n  }\n  if (readBinary) {\n    return readBinary(file);\n  }\n  throw \"both async and sync fetching of the wasm failed\";\n}\n\nasync function getWasmBinary(binaryFile) {\n  // If we don't have the binary yet, load it asynchronously using readAsync.\n  if (!wasmBinary) {\n    // Fetch the binary using readAsync\n    try {\n      var response = await readAsync(binaryFile);\n      return new Uint8Array(response);\n    } catch {}\n  }\n  // Otherwise, getBinarySync should be able to get it synchronously\n  return getBinarySync(binaryFile);\n}\n\nasync function instantiateArrayBuffer(binaryFile, imports) {\n  try {\n    var binary = await getWasmBinary(binaryFile);\n    var instance = await WebAssembly.instantiate(binary, imports);\n    return instance;\n  } catch (reason) {\n    err(`failed to asynchronously prepare wasm: ${reason}`);\n    abort(reason);\n  }\n}\n\nasync function instantiateAsync(binary, binaryFile, imports) {\n  if (!binary && !isFileURI(binaryFile) && !ENVIRONMENT_IS_NODE) {\n    try {\n      var response = fetch(binaryFile, {\n        credentials: \"same-origin\"\n      });\n      var instantiationResult = await WebAssembly.instantiateStreaming(response, imports);\n      return instantiationResult;\n    } catch (reason) {\n      // We expect the most common failure cause to be a bad MIME type for the binary,\n      // in which case falling back to ArrayBuffer instantiation should work.\n      err(`wasm streaming compile failed: ${reason}`);\n      err(\"falling back to ArrayBuffer instantiation\");\n    }\n  }\n  return instantiateArrayBuffer(binaryFile, imports);\n}\n\nfunction getWasmImports() {\n  // prepare imports\n  return {\n    \"env\": wasmImports,\n    \"wasi_snapshot_preview1\": wasmImports,\n    \"GOT.mem\": new Proxy(wasmImports, GOTHandler),\n    \"GOT.func\": new Proxy(wasmImports, GOTHandler)\n  };\n}\n\n// Create the wasm instance.\n// Receives the wasm imports, returns the exports.\nasync function createWasm() {\n  // Load the wasm module and create an instance of using native support in the JS engine.\n  // handle a generated wasm instance, receiving its exports and\n  // performing other necessary setup\n  /** @param {WebAssembly.Module=} module*/ function receiveInstance(instance, module) {\n    wasmExports = instance.exports;\n    wasmExports = relocateExports(wasmExports, 1024);\n    var metadata = getDylinkMetadata(module);\n    if (metadata.neededDynlibs) {\n      dynamicLibraries = metadata.neededDynlibs.concat(dynamicLibraries);\n    }\n    mergeLibSymbols(wasmExports, \"main\");\n    LDSO.init();\n    loadDylibs();\n    __RELOC_FUNCS__.push(wasmExports[\"__wasm_apply_data_relocs\"]);\n    assignWasmExports(wasmExports);\n    removeRunDependency(\"wasm-instantiate\");\n    return wasmExports;\n  }\n  // wait for the pthread pool (if any)\n  addRunDependency(\"wasm-instantiate\");\n  // Prefer streaming instantiation if available.\n  function receiveInstantiationResult(result) {\n    // 'result' is a ResultObject object which has both the module and instance.\n    // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n    return receiveInstance(result[\"instance\"], result[\"module\"]);\n  }\n  var info = getWasmImports();\n  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n  // to manually instantiate the Wasm module themselves. This allows pages to\n  // run the instantiation parallel to any other async startup actions they are\n  // performing.\n  // Also pthreads and wasm workers initialize the wasm instance through this\n  // path.\n  if (Module[\"instantiateWasm\"]) {\n    return new Promise((resolve, reject) => {\n      Module[\"instantiateWasm\"](info, (mod, inst) => {\n        resolve(receiveInstance(mod, inst));\n      });\n    });\n  }\n  wasmBinaryFile ??= findWasmBinary();\n  var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);\n  var exports = receiveInstantiationResult(result);\n  return exports;\n}\n\n// end include: preamble.js\n// Begin JS library code\nclass ExitStatus {\n  name=\"ExitStatus\";\n  constructor(status) {\n    this.message = `Program terminated with exit(${status})`;\n    this.status = status;\n  }\n}\n\nvar GOT = {};\n\nvar currentModuleWeakSymbols = new Set([]);\n\nvar GOTHandler = {\n  get(obj, symName) {\n    var rtn = GOT[symName];\n    if (!rtn) {\n      rtn = GOT[symName] = new WebAssembly.Global({\n        \"value\": \"i32\",\n        \"mutable\": true\n      });\n    }\n    if (!currentModuleWeakSymbols.has(symName)) {\n      // Any non-weak reference to a symbol marks it as `required`, which\n      // enabled `reportUndefinedSymbols` to report undefined symbol errors\n      // correctly.\n      rtn.required = true;\n    }\n    return rtn;\n  }\n};\n\nvar LE_ATOMICS_ADD = (heap, offset, value) => {\n  const order = LE_ATOMICS_NATIVE_BYTE_ORDER[heap.BYTES_PER_ELEMENT - 1];\n  const res = order(Atomics.add(heap, offset, order(value)));\n  return heap.unsigned ? heap.unsigned(res) : res;\n};\n\nvar LE_ATOMICS_AND = (heap, offset, value) => {\n  const order = LE_ATOMICS_NATIVE_BYTE_ORDER[heap.BYTES_PER_ELEMENT - 1];\n  const res = order(Atomics.and(heap, offset, order(value)));\n  return heap.unsigned ? heap.unsigned(res) : res;\n};\n\nvar LE_ATOMICS_COMPAREEXCHANGE = (heap, offset, expected, replacement) => {\n  const order = LE_ATOMICS_NATIVE_BYTE_ORDER[heap.BYTES_PER_ELEMENT - 1];\n  const res = order(Atomics.compareExchange(heap, offset, order(expected), order(replacement)));\n  return heap.unsigned ? heap.unsigned(res) : res;\n};\n\nvar LE_ATOMICS_EXCHANGE = (heap, offset, value) => {\n  const order = LE_ATOMICS_NATIVE_BYTE_ORDER[heap.BYTES_PER_ELEMENT - 1];\n  const res = order(Atomics.exchange(heap, offset, order(value)));\n  return heap.unsigned ? heap.unsigned(res) : res;\n};\n\nvar LE_ATOMICS_ISLOCKFREE = size => Atomics.isLockFree(size);\n\nvar LE_ATOMICS_LOAD = (heap, offset) => {\n  const order = LE_ATOMICS_NATIVE_BYTE_ORDER[heap.BYTES_PER_ELEMENT - 1];\n  const res = order(Atomics.load(heap, offset));\n  return heap.unsigned ? heap.unsigned(res) : res;\n};\n\nvar LE_ATOMICS_NATIVE_BYTE_ORDER = [];\n\nvar LE_ATOMICS_NOTIFY = (heap, offset, count) => Atomics.notify(heap, offset, count);\n\nvar LE_ATOMICS_OR = (heap, offset, value) => {\n  const order = LE_ATOMICS_NATIVE_BYTE_ORDER[heap.BYTES_PER_ELEMENT - 1];\n  const res = order(Atomics.or(heap, offset, order(value)));\n  return heap.unsigned ? heap.unsigned(res) : res;\n};\n\nvar LE_ATOMICS_STORE = (heap, offset, value) => {\n  const order = LE_ATOMICS_NATIVE_BYTE_ORDER[heap.BYTES_PER_ELEMENT - 1];\n  Atomics.store(heap, offset, order(value));\n};\n\nvar LE_ATOMICS_SUB = (heap, offset, value) => {\n  const order = LE_ATOMICS_NATIVE_BYTE_ORDER[heap.BYTES_PER_ELEMENT - 1];\n  const res = order(Atomics.sub(heap, offset, order(value)));\n  return heap.unsigned ? heap.unsigned(res) : res;\n};\n\nvar LE_ATOMICS_WAIT = (heap, offset, value, timeout) => {\n  const order = LE_ATOMICS_NATIVE_BYTE_ORDER[heap.BYTES_PER_ELEMENT - 1];\n  return Atomics.wait(heap, offset, order(value), timeout);\n};\n\nvar LE_ATOMICS_WAITASYNC = (heap, offset, value, timeout) => {\n  const order = LE_ATOMICS_NATIVE_BYTE_ORDER[heap.BYTES_PER_ELEMENT - 1];\n  return Atomics.waitAsync(heap, offset, order(value), timeout);\n};\n\nvar LE_ATOMICS_XOR = (heap, offset, value) => {\n  const order = LE_ATOMICS_NATIVE_BYTE_ORDER[heap.BYTES_PER_ELEMENT - 1];\n  const res = order(Atomics.xor(heap, offset, order(value)));\n  return heap.unsigned ? heap.unsigned(res) : res;\n};\n\nvar LE_HEAP_LOAD_F32 = byteOffset => HEAP_DATA_VIEW.getFloat32(byteOffset, true);\n\nvar LE_HEAP_LOAD_F64 = byteOffset => HEAP_DATA_VIEW.getFloat64(byteOffset, true);\n\nvar LE_HEAP_LOAD_I16 = byteOffset => HEAP_DATA_VIEW.getInt16(byteOffset, true);\n\nvar LE_HEAP_LOAD_I32 = byteOffset => HEAP_DATA_VIEW.getInt32(byteOffset, true);\n\nvar LE_HEAP_LOAD_U16 = byteOffset => HEAP_DATA_VIEW.getUint16(byteOffset, true);\n\nvar LE_HEAP_LOAD_U32 = byteOffset => HEAP_DATA_VIEW.getUint32(byteOffset, true);\n\nvar LE_HEAP_STORE_F32 = (byteOffset, value) => HEAP_DATA_VIEW.setFloat32(byteOffset, value, true);\n\nvar LE_HEAP_STORE_F64 = (byteOffset, value) => HEAP_DATA_VIEW.setFloat64(byteOffset, value, true);\n\nvar LE_HEAP_STORE_I16 = (byteOffset, value) => HEAP_DATA_VIEW.setInt16(byteOffset, value, true);\n\nvar LE_HEAP_STORE_I32 = (byteOffset, value) => HEAP_DATA_VIEW.setInt32(byteOffset, value, true);\n\nvar LE_HEAP_STORE_U16 = (byteOffset, value) => HEAP_DATA_VIEW.setUint16(byteOffset, value, true);\n\nvar LE_HEAP_STORE_U32 = (byteOffset, value) => HEAP_DATA_VIEW.setUint32(byteOffset, value, true);\n\nvar callRuntimeCallbacks = callbacks => {\n  while (callbacks.length > 0) {\n    // Pass the module as the first argument.\n    callbacks.shift()(Module);\n  }\n};\n\nvar onPostRuns = [];\n\nvar addOnPostRun = cb => onPostRuns.push(cb);\n\nvar onPreRuns = [];\n\nvar addOnPreRun = cb => onPreRuns.push(cb);\n\nvar UTF8Decoder = typeof TextDecoder != \"undefined\" ? new TextDecoder : undefined;\n\nvar findStringEnd = (heapOrArray, idx, maxBytesToRead, ignoreNul) => {\n  var maxIdx = idx + maxBytesToRead;\n  if (ignoreNul) return maxIdx;\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on\n  // null terminator by itself.\n  // As a tiny code save trick, compare idx against maxIdx using a negation,\n  // so that maxBytesToRead=undefined/NaN means Infinity.\n  while (heapOrArray[idx] && !(idx >= maxIdx)) ++idx;\n  return idx;\n};\n\n/**\n     * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given\n     * array that contains uint8 values, returns a copy of that string as a\n     * Javascript String object.\n     * heapOrArray is either a regular array, or a JavaScript typed array view.\n     * @param {number=} idx\n     * @param {number=} maxBytesToRead\n     * @param {boolean=} ignoreNul - If true, the function will not stop on a NUL character.\n     * @return {string}\n     */ var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead, ignoreNul) => {\n  var endPtr = findStringEnd(heapOrArray, idx, maxBytesToRead, ignoreNul);\n  // When using conditional TextDecoder, skip it for short strings as the overhead of the native call is not worth it.\n  if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n    return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n  }\n  var str = \"\";\n  while (idx < endPtr) {\n    // For UTF8 byte structure, see:\n    // http://en.wikipedia.org/wiki/UTF-8#Description\n    // https://www.ietf.org/rfc/rfc2279.txt\n    // https://tools.ietf.org/html/rfc3629\n    var u0 = heapOrArray[idx++];\n    if (!(u0 & 128)) {\n      str += String.fromCharCode(u0);\n      continue;\n    }\n    var u1 = heapOrArray[idx++] & 63;\n    if ((u0 & 224) == 192) {\n      str += String.fromCharCode(((u0 & 31) << 6) | u1);\n      continue;\n    }\n    var u2 = heapOrArray[idx++] & 63;\n    if ((u0 & 240) == 224) {\n      u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n    } else {\n      u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);\n    }\n    if (u0 < 65536) {\n      str += String.fromCharCode(u0);\n    } else {\n      var ch = u0 - 65536;\n      str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));\n    }\n  }\n  return str;\n};\n\nvar getDylinkMetadata = binary => {\n  var offset = 0;\n  var end = 0;\n  function getU8() {\n    return binary[offset++];\n  }\n  function getLEB() {\n    var ret = 0;\n    var mul = 1;\n    while (1) {\n      var byte = binary[offset++];\n      ret += ((byte & 127) * mul);\n      mul *= 128;\n      if (!(byte & 128)) break;\n    }\n    return ret;\n  }\n  function getString() {\n    var len = getLEB();\n    offset += len;\n    return UTF8ArrayToString(binary, offset - len, len);\n  }\n  function getStringList() {\n    var count = getLEB();\n    var rtn = [];\n    while (count--) rtn.push(getString());\n    return rtn;\n  }\n  /** @param {string=} message */ function failIf(condition, message) {\n    if (condition) throw new Error(message);\n  }\n  if (binary instanceof WebAssembly.Module) {\n    var dylinkSection = WebAssembly.Module.customSections(binary, \"dylink.0\");\n    failIf(dylinkSection.length === 0, \"need dylink section\");\n    binary = new Uint8Array(dylinkSection[0]);\n    end = binary.length;\n  } else {\n    var int32View = new Uint32Array(new Uint8Array(binary.subarray(0, 24)).buffer);\n    var magicNumberFound = int32View[0] == 1836278016 || int32View[0] == 6386541;\n    failIf(!magicNumberFound, \"need to see wasm magic number\");\n    // \\0asm\n    // we should see the dylink custom section right after the magic number and wasm version\n    failIf(binary[8] !== 0, \"need the dylink section to be first\");\n    offset = 9;\n    var section_size = getLEB();\n    //section size\n    end = offset + section_size;\n    var name = getString();\n    failIf(name !== \"dylink.0\");\n  }\n  var customSection = {\n    neededDynlibs: [],\n    tlsExports: new Set,\n    weakImports: new Set,\n    runtimePaths: []\n  };\n  var WASM_DYLINK_MEM_INFO = 1;\n  var WASM_DYLINK_NEEDED = 2;\n  var WASM_DYLINK_EXPORT_INFO = 3;\n  var WASM_DYLINK_IMPORT_INFO = 4;\n  var WASM_DYLINK_RUNTIME_PATH = 5;\n  var WASM_SYMBOL_TLS = 256;\n  var WASM_SYMBOL_BINDING_MASK = 3;\n  var WASM_SYMBOL_BINDING_WEAK = 1;\n  while (offset < end) {\n    var subsectionType = getU8();\n    var subsectionSize = getLEB();\n    if (subsectionType === WASM_DYLINK_MEM_INFO) {\n      customSection.memorySize = getLEB();\n      customSection.memoryAlign = getLEB();\n      customSection.tableSize = getLEB();\n      customSection.tableAlign = getLEB();\n    } else if (subsectionType === WASM_DYLINK_NEEDED) {\n      customSection.neededDynlibs = getStringList();\n    } else if (subsectionType === WASM_DYLINK_EXPORT_INFO) {\n      var count = getLEB();\n      while (count--) {\n        var symname = getString();\n        var flags = getLEB();\n        if (flags & WASM_SYMBOL_TLS) {\n          customSection.tlsExports.add(symname);\n        }\n      }\n    } else if (subsectionType === WASM_DYLINK_IMPORT_INFO) {\n      var count = getLEB();\n      while (count--) {\n        var modname = getString();\n        var symname = getString();\n        var flags = getLEB();\n        if ((flags & WASM_SYMBOL_BINDING_MASK) == WASM_SYMBOL_BINDING_WEAK) {\n          customSection.weakImports.add(symname);\n        }\n      }\n    } else if (subsectionType === WASM_DYLINK_RUNTIME_PATH) {\n      customSection.runtimePaths = getStringList();\n    } else {\n      // unknown subsection\n      offset += subsectionSize;\n    }\n  }\n  return customSection;\n};\n\n/**\n     * @param {number} ptr\n     * @param {string} type\n     */ function getValue(ptr, type = \"i8\") {\n  if (type.endsWith(\"*\")) type = \"*\";\n  switch (type) {\n   case \"i1\":\n    return HEAP8[ptr];\n\n   case \"i8\":\n    return HEAP8[ptr];\n\n   case \"i16\":\n    return LE_HEAP_LOAD_I16(((ptr) >> 1) * 2);\n\n   case \"i32\":\n    return LE_HEAP_LOAD_I32(((ptr) >> 2) * 4);\n\n   case \"i64\":\n    return LE_HEAP_LOAD_I64(((ptr) >> 3) * 8);\n\n   case \"float\":\n    return LE_HEAP_LOAD_F32(((ptr) >> 2) * 4);\n\n   case \"double\":\n    return LE_HEAP_LOAD_F64(((ptr) >> 3) * 8);\n\n   case \"*\":\n    return LE_HEAP_LOAD_U32(((ptr) >> 2) * 4);\n\n   default:\n    abort(`invalid type for getValue: ${type}`);\n  }\n}\n\nvar newDSO = (name, handle, syms) => {\n  var dso = {\n    refcount: Infinity,\n    name,\n    exports: syms,\n    global: true\n  };\n  LDSO.loadedLibsByName[name] = dso;\n  if (handle != undefined) {\n    LDSO.loadedLibsByHandle[handle] = dso;\n  }\n  return dso;\n};\n\nvar LDSO = {\n  loadedLibsByName: {},\n  loadedLibsByHandle: {},\n  init() {\n    newDSO(\"__main__\", 0, wasmImports);\n  }\n};\n\nvar ___heap_base = 78240;\n\nvar alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;\n\nvar getMemory = size => {\n  // After the runtime is initialized, we must only use sbrk() normally.\n  if (runtimeInitialized) {\n    // Currently we don't support freeing of static data when modules are\n    // unloaded via dlclose.  This function is tagged as `noleakcheck` to\n    // avoid having this reported as leak.\n    return _calloc(size, 1);\n  }\n  var ret = ___heap_base;\n  // Keep __heap_base stack aligned.\n  var end = ret + alignMemory(size, 16);\n  ___heap_base = end;\n  GOT[\"__heap_base\"].value = end;\n  return ret;\n};\n\nvar isInternalSym = symName => [ \"__cpp_exception\", \"__c_longjmp\", \"__wasm_apply_data_relocs\", \"__dso_handle\", \"__tls_size\", \"__tls_align\", \"__set_stack_limits\", \"_emscripten_tls_init\", \"__wasm_init_tls\", \"__wasm_call_ctors\", \"__start_em_asm\", \"__stop_em_asm\", \"__start_em_js\", \"__stop_em_js\" ].includes(symName) || symName.startsWith(\"__em_js__\");\n\nvar uleb128EncodeWithLen = arr => {\n  const n = arr.length;\n  // Note: this LEB128 length encoding produces extra byte for n < 128,\n  // but we don't care as it's only used in a temporary representation.\n  return [ (n % 128) | 128, n >> 7, ...arr ];\n};\n\nvar wasmTypeCodes = {\n  \"i\": 127,\n  // i32\n  \"p\": 127,\n  // i32\n  \"j\": 126,\n  // i64\n  \"f\": 125,\n  // f32\n  \"d\": 124,\n  // f64\n  \"e\": 111\n};\n\nvar generateTypePack = types => uleb128EncodeWithLen(Array.from(types, type => {\n  var code = wasmTypeCodes[type];\n  return code;\n}));\n\nvar convertJsFunctionToWasm = (func, sig) => {\n  // Rest of the module is static\n  var bytes = Uint8Array.of(0, 97, 115, 109, // magic (\"\\0asm\")\n  1, 0, 0, 0, // version: 1\n  1, // Type section code\n  // The module is static, with the exception of the type section, which is\n  // generated based on the signature passed in.\n  ...uleb128EncodeWithLen([ 1, // count: 1\n  96, // param types\n  ...generateTypePack(sig.slice(1)), // return types (for now only supporting [] if `void` and single [T] otherwise)\n  ...generateTypePack(sig[0] === \"v\" ? \"\" : sig[0]) ]), // The rest of the module is static\n  2, 7, // import section\n  // (import \"e\" \"f\" (func 0 (type 0)))\n  1, 1, 101, 1, 102, 0, 0, 7, 5, // export section\n  // (export \"f\" (func 0 (type 0)))\n  1, 1, 102, 0, 0);\n  // We can compile this wasm module synchronously because it is very small.\n  // This accepts an import (at \"e.f\"), that it reroutes to an export (at \"f\")\n  var module = new WebAssembly.Module(bytes);\n  var instance = new WebAssembly.Instance(module, {\n    \"e\": {\n      \"f\": func\n    }\n  });\n  var wrappedFunc = instance.exports[\"f\"];\n  return wrappedFunc;\n};\n\nvar wasmTableMirror = [];\n\n/** @type {WebAssembly.Table} */ var wasmTable = new WebAssembly.Table({\n  \"initial\": 31,\n  \"element\": \"anyfunc\"\n});\n\nvar getWasmTableEntry = funcPtr => {\n  var func = wasmTableMirror[funcPtr];\n  if (!func) {\n    /** @suppress {checkTypes} */ wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\n  }\n  return func;\n};\n\nvar updateTableMap = (offset, count) => {\n  if (functionsInTableMap) {\n    for (var i = offset; i < offset + count; i++) {\n      var item = getWasmTableEntry(i);\n      // Ignore null values.\n      if (item) {\n        functionsInTableMap.set(item, i);\n      }\n    }\n  }\n};\n\nvar functionsInTableMap;\n\nvar getFunctionAddress = func => {\n  // First, create the map if this is the first use.\n  if (!functionsInTableMap) {\n    functionsInTableMap = new WeakMap;\n    updateTableMap(0, wasmTable.length);\n  }\n  return functionsInTableMap.get(func) || 0;\n};\n\nvar freeTableIndexes = [];\n\nvar getEmptyTableSlot = () => {\n  // Reuse a free index if there is one, otherwise grow.\n  if (freeTableIndexes.length) {\n    return freeTableIndexes.pop();\n  }\n  // Grow the table\n  return wasmTable[\"grow\"](1);\n};\n\nvar setWasmTableEntry = (idx, func) => {\n  /** @suppress {checkTypes} */ wasmTable.set(idx, func);\n  // With ABORT_ON_WASM_EXCEPTIONS wasmTable.get is overridden to return wrapped\n  // functions so we need to call it here to retrieve the potential wrapper correctly\n  // instead of just storing 'func' directly into wasmTableMirror\n  /** @suppress {checkTypes} */ wasmTableMirror[idx] = wasmTable.get(idx);\n};\n\n/** @param {string=} sig */ var addFunction = (func, sig) => {\n  // Check if the function is already in the table, to ensure each function\n  // gets a unique index.\n  var rtn = getFunctionAddress(func);\n  if (rtn) {\n    return rtn;\n  }\n  // It's not in the table, add it now.\n  var ret = getEmptyTableSlot();\n  // Set the new value.\n  try {\n    // Attempting to call this with JS function will cause of table.set() to fail\n    setWasmTableEntry(ret, func);\n  } catch (err) {\n    if (!(err instanceof TypeError)) {\n      throw err;\n    }\n    var wrapped = convertJsFunctionToWasm(func, sig);\n    setWasmTableEntry(ret, wrapped);\n  }\n  functionsInTableMap.set(func, ret);\n  return ret;\n};\n\nvar updateGOT = (exports, replace) => {\n  for (var symName in exports) {\n    if (isInternalSym(symName)) {\n      continue;\n    }\n    var value = exports[symName];\n    GOT[symName] ||= new WebAssembly.Global({\n      \"value\": \"i32\",\n      \"mutable\": true\n    });\n    if (replace || GOT[symName].value == 0) {\n      if (typeof value == \"function\") {\n        GOT[symName].value = addFunction(value);\n      } else if (typeof value == \"number\") {\n        GOT[symName].value = value;\n      } else {\n        err(`unhandled export type for '${symName}': ${typeof value}`);\n      }\n    }\n  }\n};\n\n/** @param {boolean=} replace */ var relocateExports = (exports, memoryBase, replace) => {\n  var relocated = {};\n  for (var e in exports) {\n    var value = exports[e];\n    if (typeof value == \"object\") {\n      // a breaking change in the wasm spec, globals are now objects\n      // https://github.com/WebAssembly/mutable-global/issues/1\n      value = value.value;\n    }\n    if (typeof value == \"number\") {\n      value += memoryBase;\n    }\n    relocated[e] = value;\n  }\n  updateGOT(relocated, replace);\n  return relocated;\n};\n\nvar isSymbolDefined = symName => {\n  // Ignore 'stub' symbols that are auto-generated as part of the original\n  // `wasmImports` used to instantiate the main module.\n  var existing = wasmImports[symName];\n  if (!existing || existing.stub) {\n    return false;\n  }\n  return true;\n};\n\nvar dynCall = (sig, ptr, args = [], promising = false) => {\n  var func = getWasmTableEntry(ptr);\n  var rtn = func(...args);\n  function convert(rtn) {\n    return rtn;\n  }\n  return convert(rtn);\n};\n\nvar stackSave = () => _emscripten_stack_get_current();\n\nvar stackRestore = val => __emscripten_stack_restore(val);\n\nvar createInvokeFunction = sig => (ptr, ...args) => {\n  var sp = stackSave();\n  try {\n    return dynCall(sig, ptr, args);\n  } catch (e) {\n    stackRestore(sp);\n    // Create a try-catch guard that rethrows the Emscripten EH exception.\n    // Exceptions thrown from C++ will be a pointer (number) and longjmp\n    // will throw the number Infinity. Use the compact and fast \"e !== e+0\"\n    // test to check if e was not a Number.\n    if (e !== e + 0) throw e;\n    _setThrew(1, 0);\n    // In theory this if statement could be done on\n    // creating the function, but I just added this to\n    // save wasting code space as it only happens on exception.\n    if (sig[0] == \"j\") return 0n;\n  }\n};\n\nvar resolveGlobalSymbol = (symName, direct = false) => {\n  var sym;\n  if (isSymbolDefined(symName)) {\n    sym = wasmImports[symName];\n  } else if (symName.startsWith(\"invoke_\")) {\n    // Create (and cache) new invoke_ functions on demand.\n    sym = wasmImports[symName] = createInvokeFunction(symName.split(\"_\")[1]);\n  }\n  return {\n    sym,\n    name: symName\n  };\n};\n\nvar onPostCtors = [];\n\nvar addOnPostCtor = cb => onPostCtors.push(cb);\n\n/**\n     * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the\n     * emscripten HEAP, returns a copy of that string as a Javascript String object.\n     *\n     * @param {number} ptr\n     * @param {number=} maxBytesToRead - An optional length that specifies the\n     *   maximum number of bytes to read. You can omit this parameter to scan the\n     *   string until the first 0 byte. If maxBytesToRead is passed, and the string\n     *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the\n     *   string will cut short at that byte index.\n     * @param {boolean=} ignoreNul - If true, the function will not stop on a NUL character.\n     * @return {string}\n     */ var UTF8ToString = (ptr, maxBytesToRead, ignoreNul) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead, ignoreNul) : \"\";\n\n/**\n      * @param {string=} libName\n      * @param {Object=} localScope\n      * @param {number=} handle\n      */ var loadWebAssemblyModule = (binary, flags, libName, localScope, handle) => {\n  var metadata = getDylinkMetadata(binary);\n  currentModuleWeakSymbols = metadata.weakImports;\n  // loadModule loads the wasm module after all its dependencies have been loaded.\n  // can be called both sync/async.\n  function loadModule() {\n    // alignments are powers of 2\n    var memAlign = Math.pow(2, metadata.memoryAlign);\n    // prepare memory\n    var memoryBase = metadata.memorySize ? alignMemory(getMemory(metadata.memorySize + memAlign), memAlign) : 0;\n    // TODO: add to cleanups\n    var tableBase = metadata.tableSize ? wasmTable.length : 0;\n    if (handle) {\n      HEAP8[(handle) + (8)] = 1;\n      LE_HEAP_STORE_U32((((handle) + (12)) >> 2) * 4, memoryBase);\n      LE_HEAP_STORE_I32((((handle) + (16)) >> 2) * 4, metadata.memorySize);\n      LE_HEAP_STORE_U32((((handle) + (20)) >> 2) * 4, tableBase);\n      LE_HEAP_STORE_I32((((handle) + (24)) >> 2) * 4, metadata.tableSize);\n    }\n    if (metadata.tableSize) {\n      wasmTable.grow(metadata.tableSize);\n    }\n    // This is the export map that we ultimately return.  We declare it here\n    // so it can be used within resolveSymbol.  We resolve symbols against\n    // this local symbol map in the case there they are not present on the\n    // global Module object.  We need this fallback because Modules sometime\n    // need to import their own symbols\n    var moduleExports;\n    function resolveSymbol(sym) {\n      var resolved = resolveGlobalSymbol(sym).sym;\n      if (!resolved && localScope) {\n        resolved = localScope[sym];\n      }\n      if (!resolved) {\n        resolved = moduleExports[sym];\n      }\n      return resolved;\n    }\n    // TODO kill \u2193\u2193\u2193 (except \"symbols local to this module\", it will likely be\n    // not needed if we require that if A wants symbols from B it has to link\n    // to B explicitly: similarly to -Wl,--no-undefined)\n    // wasm dynamic libraries are pure wasm, so they cannot assist in\n    // their own loading. When side module A wants to import something\n    // provided by a side module B that is loaded later, we need to\n    // add a layer of indirection, but worse, we can't even tell what\n    // to add the indirection for, without inspecting what A's imports\n    // are. To do that here, we use a JS proxy (another option would\n    // be to inspect the binary directly).\n    var proxyHandler = {\n      get(stubs, prop) {\n        // symbols that should be local to this module\n        switch (prop) {\n         case \"__memory_base\":\n          return memoryBase;\n\n         case \"__table_base\":\n          return tableBase;\n        }\n        if (prop in wasmImports && !wasmImports[prop].stub) {\n          // No stub needed, symbol already exists in symbol table\n          var res = wasmImports[prop];\n          return res;\n        }\n        // Return a stub function that will resolve the symbol\n        // when first called.\n        if (!(prop in stubs)) {\n          var resolved;\n          stubs[prop] = (...args) => {\n            resolved ||= resolveSymbol(prop);\n            return resolved(...args);\n          };\n        }\n        return stubs[prop];\n      }\n    };\n    var proxy = new Proxy({}, proxyHandler);\n    var info = {\n      \"GOT.mem\": new Proxy({}, GOTHandler),\n      \"GOT.func\": new Proxy({}, GOTHandler),\n      \"env\": proxy,\n      \"wasi_snapshot_preview1\": proxy\n    };\n    function postInstantiation(module, instance) {\n      // add new entries to functionsInTableMap\n      updateTableMap(tableBase, metadata.tableSize);\n      moduleExports = relocateExports(instance.exports, memoryBase);\n      if (!flags.allowUndefined) {\n        reportUndefinedSymbols();\n      }\n      function addEmAsm(addr, body) {\n        var args = [];\n        var arity = 0;\n        for (;arity < 16; arity++) {\n          if (body.indexOf(\"$\" + arity) != -1) {\n            args.push(\"$\" + arity);\n          } else {\n            break;\n          }\n        }\n        args = args.join(\",\");\n        var func = `(${args}) => { ${body} };`;\n        ASM_CONSTS[start] = eval(func);\n      }\n      // Add any EM_ASM function that exist in the side module\n      if (\"__start_em_asm\" in moduleExports) {\n        var start = moduleExports[\"__start_em_asm\"];\n        var stop = moduleExports[\"__stop_em_asm\"];\n        while (start < stop) {\n          var jsString = UTF8ToString(start);\n          addEmAsm(start, jsString);\n          start = HEAPU8.indexOf(0, start) + 1;\n        }\n      }\n      function addEmJs(name, cSig, body) {\n        // The signature here is a C signature (e.g. \"(int foo, char* bar)\").\n        // See `create_em_js` in emcc.py` for the build-time version of this\n        // code.\n        var jsArgs = [];\n        cSig = cSig.slice(1, -1);\n        if (cSig != \"void\") {\n          cSig = cSig.split(\",\");\n          for (var i in cSig) {\n            var jsArg = cSig[i].split(\" \").pop();\n            jsArgs.push(jsArg.replace(\"*\", \"\"));\n          }\n        }\n        var func = `(${jsArgs}) => ${body};`;\n        moduleExports[name] = eval(func);\n      }\n      for (var name in moduleExports) {\n        if (name.startsWith(\"__em_js__\")) {\n          var start = moduleExports[name];\n          var jsString = UTF8ToString(start);\n          // EM_JS strings are stored in the data section in the form\n          // SIG<::>BODY.\n          var parts = jsString.split(\"<::>\");\n          addEmJs(name.replace(\"__em_js__\", \"\"), parts[0], parts[1]);\n          delete moduleExports[name];\n        }\n      }\n      // initialize the module\n      var applyRelocs = moduleExports[\"__wasm_apply_data_relocs\"];\n      if (applyRelocs) {\n        if (runtimeInitialized) {\n          applyRelocs();\n        } else {\n          __RELOC_FUNCS__.push(applyRelocs);\n        }\n      }\n      var init = moduleExports[\"__wasm_call_ctors\"];\n      if (init) {\n        if (runtimeInitialized) {\n          init();\n        } else {\n          // we aren't ready to run compiled code yet\n          addOnPostCtor(init);\n        }\n      }\n      return moduleExports;\n    }\n    if (flags.loadAsync) {\n      return (async () => {\n        var instance;\n        if (binary instanceof WebAssembly.Module) {\n          instance = new WebAssembly.Instance(binary, info);\n        } else {\n          // Destructuring assignment without declaration has to be wrapped\n          // with parens or parser will treat the l-value as an object\n          // literal instead.\n          (({module: binary, instance} = await WebAssembly.instantiate(binary, info)));\n        }\n        return postInstantiation(binary, instance);\n      })();\n    }\n    var module = binary instanceof WebAssembly.Module ? binary : new WebAssembly.Module(binary);\n    var instance = new WebAssembly.Instance(module, info);\n    return postInstantiation(module, instance);\n  }\n  // We need to set rpath in flags based on the current library's rpath.\n  // We can't mutate flags or else if a depends on b and c and b depends on d,\n  // then c will be loaded with b's rpath instead of a's.\n  flags = {\n    ...flags,\n    rpath: {\n      parentLibPath: libName,\n      paths: metadata.runtimePaths\n    }\n  };\n  // now load needed libraries and the module itself.\n  if (flags.loadAsync) {\n    return metadata.neededDynlibs.reduce((chain, dynNeeded) => chain.then(() => loadDynamicLibrary(dynNeeded, flags, localScope)), Promise.resolve()).then(loadModule);\n  }\n  metadata.neededDynlibs.forEach(needed => loadDynamicLibrary(needed, flags, localScope));\n  return loadModule();\n};\n\nvar mergeLibSymbols = (exports, libName) => {\n  // add symbols into global namespace TODO: weak linking etc.\n  for (var [sym, exp] of Object.entries(exports)) {\n    // When RTLD_GLOBAL is enabled, the symbols defined by this shared object\n    // will be made available for symbol resolution of subsequently loaded\n    // shared objects.\n    // We should copy the symbols (which include methods and variables) from\n    // SIDE_MODULE to MAIN_MODULE.\n    const setImport = target => {\n      if (!isSymbolDefined(target)) {\n        wasmImports[target] = exp;\n      }\n    };\n    setImport(sym);\n    // Special case for handling of main symbol:  If a side module exports\n    // `main` that also acts a definition for `__main_argc_argv` and vice\n    // versa.\n    const main_alias = \"__main_argc_argv\";\n    if (sym == \"main\") {\n      setImport(main_alias);\n    }\n    if (sym == main_alias) {\n      setImport(\"main\");\n    }\n  }\n};\n\nvar asyncLoad = async url => {\n  var arrayBuffer = await readAsync(url);\n  return new Uint8Array(arrayBuffer);\n};\n\n/**\n       * @param {number=} handle\n       * @param {Object=} localScope\n       */ function loadDynamicLibrary(libName, flags = {\n  global: true,\n  nodelete: true\n}, localScope, handle) {\n  // when loadDynamicLibrary did not have flags, libraries were loaded\n  // globally & permanently\n  var dso = LDSO.loadedLibsByName[libName];\n  if (dso) {\n    // the library is being loaded or has been loaded already.\n    if (!flags.global) {\n      if (localScope) {\n        Object.assign(localScope, dso.exports);\n      }\n    } else if (!dso.global) {\n      // The library was previously loaded only locally but not\n      // we have a request with global=true.\n      dso.global = true;\n      mergeLibSymbols(dso.exports, libName);\n    }\n    // same for \"nodelete\"\n    if (flags.nodelete && dso.refcount !== Infinity) {\n      dso.refcount = Infinity;\n    }\n    dso.refcount++;\n    if (handle) {\n      LDSO.loadedLibsByHandle[handle] = dso;\n    }\n    return flags.loadAsync ? Promise.resolve(true) : true;\n  }\n  // allocate new DSO\n  dso = newDSO(libName, handle, \"loading\");\n  dso.refcount = flags.nodelete ? Infinity : 1;\n  dso.global = flags.global;\n  // libName -> libData\n  function loadLibData() {\n    // for wasm, we can use fetch for async, but for fs mode we can only imitate it\n    if (handle) {\n      var data = LE_HEAP_LOAD_U32((((handle) + (28)) >> 2) * 4);\n      var dataSize = LE_HEAP_LOAD_U32((((handle) + (32)) >> 2) * 4);\n      if (data && dataSize) {\n        var libData = HEAP8.slice(data, data + dataSize);\n        return flags.loadAsync ? Promise.resolve(libData) : libData;\n      }\n    }\n    var libFile = locateFile(libName);\n    if (flags.loadAsync) {\n      return asyncLoad(libFile);\n    }\n    // load the binary synchronously\n    if (!readBinary) {\n      throw new Error(`${libFile}: file not found, and synchronous loading of external files is not available`);\n    }\n    return readBinary(libFile);\n  }\n  // libName -> exports\n  function getExports() {\n    // module not preloaded - load lib data and create new module from it\n    if (flags.loadAsync) {\n      return loadLibData().then(libData => loadWebAssemblyModule(libData, flags, libName, localScope, handle));\n    }\n    return loadWebAssemblyModule(loadLibData(), flags, libName, localScope, handle);\n  }\n  // module for lib is loaded - update the dso & global namespace\n  function moduleLoaded(exports) {\n    if (dso.global) {\n      mergeLibSymbols(exports, libName);\n    } else if (localScope) {\n      Object.assign(localScope, exports);\n    }\n    dso.exports = exports;\n  }\n  if (flags.loadAsync) {\n    return getExports().then(exports => {\n      moduleLoaded(exports);\n      return true;\n    });\n  }\n  moduleLoaded(getExports());\n  return true;\n}\n\nvar reportUndefinedSymbols = () => {\n  for (var [symName, entry] of Object.entries(GOT)) {\n    if (entry.value == 0) {\n      var value = resolveGlobalSymbol(symName, true).sym;\n      if (!value && !entry.required) {\n        // Ignore undefined symbols that are imported as weak.\n        continue;\n      }\n      if (typeof value == \"function\") {\n        /** @suppress {checkTypes} */ entry.value = addFunction(value, value.sig);\n      } else if (typeof value == \"number\") {\n        entry.value = value;\n      } else {\n        throw new Error(`bad export type for '${symName}': ${typeof value}`);\n      }\n    }\n  }\n};\n\nvar loadDylibs = () => {\n  if (!dynamicLibraries.length) {\n    reportUndefinedSymbols();\n    return;\n  }\n  // Load binaries asynchronously\n  addRunDependency(\"loadDylibs\");\n  dynamicLibraries.reduce((chain, lib) => chain.then(() => loadDynamicLibrary(lib, {\n    loadAsync: true,\n    global: true,\n    nodelete: true,\n    allowUndefined: true\n  })), Promise.resolve()).then(() => {\n    // we got them all, wonderful\n    reportUndefinedSymbols();\n    removeRunDependency(\"loadDylibs\");\n  });\n};\n\nvar noExitRuntime = true;\n\n/**\n     * @param {number} ptr\n     * @param {number} value\n     * @param {string} type\n     */ function setValue(ptr, value, type = \"i8\") {\n  if (type.endsWith(\"*\")) type = \"*\";\n  switch (type) {\n   case \"i1\":\n    HEAP8[ptr] = value;\n    break;\n\n   case \"i8\":\n    HEAP8[ptr] = value;\n    break;\n\n   case \"i16\":\n    LE_HEAP_STORE_I16(((ptr) >> 1) * 2, value);\n    break;\n\n   case \"i32\":\n    LE_HEAP_STORE_I32(((ptr) >> 2) * 4, value);\n    break;\n\n   case \"i64\":\n    LE_HEAP_STORE_I64(((ptr) >> 3) * 8, BigInt(value));\n    break;\n\n   case \"float\":\n    LE_HEAP_STORE_F32(((ptr) >> 2) * 4, value);\n    break;\n\n   case \"double\":\n    LE_HEAP_STORE_F64(((ptr) >> 3) * 8, value);\n    break;\n\n   case \"*\":\n    LE_HEAP_STORE_U32(((ptr) >> 2) * 4, value);\n    break;\n\n   default:\n    abort(`invalid type for setValue: ${type}`);\n  }\n}\n\nvar ___memory_base = new WebAssembly.Global({\n  \"value\": \"i32\",\n  \"mutable\": false\n}, 1024);\n\nvar ___stack_high = 78240;\n\nvar ___stack_low = 12704;\n\nvar ___stack_pointer = new WebAssembly.Global({\n  \"value\": \"i32\",\n  \"mutable\": true\n}, 78240);\n\nvar ___table_base = new WebAssembly.Global({\n  \"value\": \"i32\",\n  \"mutable\": false\n}, 1);\n\nvar __abort_js = () => abort(\"\");\n\n__abort_js.sig = \"v\";\n\nvar _emscripten_get_now = () => performance.now();\n\n_emscripten_get_now.sig = \"d\";\n\nvar _emscripten_date_now = () => Date.now();\n\n_emscripten_date_now.sig = \"d\";\n\nvar nowIsMonotonic = 1;\n\nvar checkWasiClock = clock_id => clock_id >= 0 && clock_id <= 3;\n\nvar INT53_MAX = 9007199254740992;\n\nvar INT53_MIN = -9007199254740992;\n\nvar bigintToI53Checked = num => (num < INT53_MIN || num > INT53_MAX) ? NaN : Number(num);\n\nfunction _clock_time_get(clk_id, ignored_precision, ptime) {\n  ignored_precision = bigintToI53Checked(ignored_precision);\n  if (!checkWasiClock(clk_id)) {\n    return 28;\n  }\n  var now;\n  // all wasi clocks but realtime are monotonic\n  if (clk_id === 0) {\n    now = _emscripten_date_now();\n  } else if (nowIsMonotonic) {\n    now = _emscripten_get_now();\n  } else {\n    return 52;\n  }\n  // \"now\" is in ms, and wasi times are in ns.\n  var nsec = Math.round(now * 1e3 * 1e3);\n  LE_HEAP_STORE_I64(((ptime) >> 3) * 8, BigInt(nsec));\n  return 0;\n}\n\n_clock_time_get.sig = \"iijp\";\n\nvar getHeapMax = () => // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate\n// full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side\n// for any code that deals with heap sizes, which would require special\n// casing all heap size related code to treat 0 specially.\n2147483648;\n\nvar growMemory = size => {\n  var oldHeapSize = wasmMemory.buffer.byteLength;\n  var pages = ((size - oldHeapSize + 65535) / 65536) | 0;\n  try {\n    // round size grow request up to wasm page size (fixed 64KB per spec)\n    wasmMemory.grow(pages);\n    // .grow() takes a delta compared to the previous size\n    updateMemoryViews();\n    return 1;\n  } catch (e) {}\n};\n\nvar _emscripten_resize_heap = requestedSize => {\n  var oldSize = HEAPU8.length;\n  // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.\n  requestedSize >>>= 0;\n  // With multithreaded builds, races can happen (another thread might increase the size\n  // in between), so return a failure, and let the caller retry.\n  // Memory resize rules:\n  // 1.  Always increase heap size to at least the requested size, rounded up\n  //     to next page multiple.\n  // 2a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap\n  //     geometrically: increase the heap size according to\n  //     MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%), At most\n  //     overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).\n  // 2b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap\n  //     linearly: increase the heap size by at least\n  //     MEMORY_GROWTH_LINEAR_STEP bytes.\n  // 3.  Max size for the heap is capped at 2048MB-WASM_PAGE_SIZE, or by\n  //     MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest\n  // 4.  If we were unable to allocate as much memory, it may be due to\n  //     over-eager decision to excessively reserve due to (3) above.\n  //     Hence if an allocation fails, cut down on the amount of excess\n  //     growth, in an attempt to succeed to perform a smaller allocation.\n  // A limit is set for how much we can grow. We should not exceed that\n  // (the wasm binary specifies it, so if we tried, we'd fail anyhow).\n  var maxHeapSize = getHeapMax();\n  if (requestedSize > maxHeapSize) {\n    return false;\n  }\n  // Loop through potential heap size increases. If we attempt a too eager\n  // reservation that fails, cut down on the attempted size and reserve a\n  // smaller bump instead. (max 3 times, chosen somewhat arbitrarily)\n  for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n    var overGrownHeapSize = oldSize * (1 + .2 / cutDown);\n    // ensure geometric growth\n    // but limit overreserving (default to capping at +96MB overgrowth at most)\n    overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n    var newSize = Math.min(maxHeapSize, alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536));\n    var replacement = growMemory(newSize);\n    if (replacement) {\n      return true;\n    }\n  }\n  return false;\n};\n\n_emscripten_resize_heap.sig = \"ip\";\n\nvar _fd_close = fd => 52;\n\n_fd_close.sig = \"ii\";\n\nfunction _fd_seek(fd, offset, whence, newOffset) {\n  offset = bigintToI53Checked(offset);\n  return 70;\n}\n\n_fd_seek.sig = \"iijip\";\n\nvar printCharBuffers = [ null, [], [] ];\n\nvar printChar = (stream, curr) => {\n  var buffer = printCharBuffers[stream];\n  if (curr === 0 || curr === 10) {\n    (stream === 1 ? out : err)(UTF8ArrayToString(buffer));\n    buffer.length = 0;\n  } else {\n    buffer.push(curr);\n  }\n};\n\nvar flush_NO_FILESYSTEM = () => {\n  // flush anything remaining in the buffers during shutdown\n  if (printCharBuffers[1].length) printChar(1, 10);\n  if (printCharBuffers[2].length) printChar(2, 10);\n};\n\nvar SYSCALLS = {\n  varargs: undefined,\n  getStr(ptr) {\n    var ret = UTF8ToString(ptr);\n    return ret;\n  }\n};\n\nvar _fd_write = (fd, iov, iovcnt, pnum) => {\n  // hack to support printf in SYSCALLS_REQUIRE_FILESYSTEM=0\n  var num = 0;\n  for (var i = 0; i < iovcnt; i++) {\n    var ptr = LE_HEAP_LOAD_U32(((iov) >> 2) * 4);\n    var len = LE_HEAP_LOAD_U32((((iov) + (4)) >> 2) * 4);\n    iov += 8;\n    for (var j = 0; j < len; j++) {\n      printChar(fd, HEAPU8[ptr + j]);\n    }\n    num += len;\n  }\n  LE_HEAP_STORE_U32(((pnum) >> 2) * 4, num);\n  return 0;\n};\n\n_fd_write.sig = \"iippp\";\n\nfunction _tree_sitter_log_callback(isLexMessage, messageAddress) {\n  if (Module.currentLogCallback) {\n    const message = UTF8ToString(messageAddress);\n    Module.currentLogCallback(message, isLexMessage !== 0);\n  }\n}\n\nfunction _tree_sitter_parse_callback(inputBufferAddress, index, row, column, lengthAddress) {\n  const INPUT_BUFFER_SIZE = 10 * 1024;\n  const string = Module.currentParseCallback(index, {\n    row,\n    column\n  });\n  if (typeof string === \"string\") {\n    setValue(lengthAddress, string.length, \"i32\");\n    stringToUTF16(string, inputBufferAddress, INPUT_BUFFER_SIZE);\n  } else {\n    setValue(lengthAddress, 0, \"i32\");\n  }\n}\n\nfunction _tree_sitter_progress_callback(currentOffset, hasError) {\n  if (Module.currentProgressCallback) {\n    return Module.currentProgressCallback({\n      currentOffset,\n      hasError\n    });\n  }\n  return false;\n}\n\nfunction _tree_sitter_query_progress_callback(currentOffset) {\n  if (Module.currentQueryProgressCallback) {\n    return Module.currentQueryProgressCallback({\n      currentOffset\n    });\n  }\n  return false;\n}\n\nvar runtimeKeepaliveCounter = 0;\n\nvar keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;\n\nvar _proc_exit = code => {\n  EXITSTATUS = code;\n  if (!keepRuntimeAlive()) {\n    Module[\"onExit\"]?.(code);\n    ABORT = true;\n  }\n  quit_(code, new ExitStatus(code));\n};\n\n_proc_exit.sig = \"vi\";\n\n/** @param {boolean|number=} implicit */ var exitJS = (status, implicit) => {\n  EXITSTATUS = status;\n  _proc_exit(status);\n};\n\nvar handleException = e => {\n  // Certain exception types we do not treat as errors since they are used for\n  // internal control flow.\n  // 1. ExitStatus, which is thrown by exit()\n  // 2. \"unwind\", which is thrown by emscripten_unwind_to_js_event_loop() and others\n  //    that wish to return to JS event loop.\n  if (e instanceof ExitStatus || e == \"unwind\") {\n    return EXITSTATUS;\n  }\n  quit_(1, e);\n};\n\nvar lengthBytesUTF8 = str => {\n  var len = 0;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\n    // unit, not a Unicode code point of the character! So decode\n    // UTF16->UTF32->UTF8.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var c = str.charCodeAt(i);\n    // possibly a lead surrogate\n    if (c <= 127) {\n      len++;\n    } else if (c <= 2047) {\n      len += 2;\n    } else if (c >= 55296 && c <= 57343) {\n      len += 4;\n      ++i;\n    } else {\n      len += 3;\n    }\n  }\n  return len;\n};\n\nvar stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {\n  // Parameter maxBytesToWrite is not optional. Negative values, 0, null,\n  // undefined and false each don't write out any bytes.\n  if (!(maxBytesToWrite > 0)) return 0;\n  var startIdx = outIdx;\n  var endIdx = outIdx + maxBytesToWrite - 1;\n  // -1 for string null terminator.\n  for (var i = 0; i < str.length; ++i) {\n    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description\n    // and https://www.ietf.org/rfc/rfc2279.txt\n    // and https://tools.ietf.org/html/rfc3629\n    var u = str.codePointAt(i);\n    if (u <= 127) {\n      if (outIdx >= endIdx) break;\n      heap[outIdx++] = u;\n    } else if (u <= 2047) {\n      if (outIdx + 1 >= endIdx) break;\n      heap[outIdx++] = 192 | (u >> 6);\n      heap[outIdx++] = 128 | (u & 63);\n    } else if (u <= 65535) {\n      if (outIdx + 2 >= endIdx) break;\n      heap[outIdx++] = 224 | (u >> 12);\n      heap[outIdx++] = 128 | ((u >> 6) & 63);\n      heap[outIdx++] = 128 | (u & 63);\n    } else {\n      if (outIdx + 3 >= endIdx) break;\n      heap[outIdx++] = 240 | (u >> 18);\n      heap[outIdx++] = 128 | ((u >> 12) & 63);\n      heap[outIdx++] = 128 | ((u >> 6) & 63);\n      heap[outIdx++] = 128 | (u & 63);\n      // Gotcha: if codePoint is over 0xFFFF, it is represented as a surrogate pair in UTF-16.\n      // We need to manually skip over the second code unit for correct iteration.\n      i++;\n    }\n  }\n  // Null-terminate the pointer to the buffer.\n  heap[outIdx] = 0;\n  return outIdx - startIdx;\n};\n\nvar stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n\nvar stackAlloc = sz => __emscripten_stack_alloc(sz);\n\nvar stringToUTF8OnStack = str => {\n  var size = lengthBytesUTF8(str) + 1;\n  var ret = stackAlloc(size);\n  stringToUTF8(str, ret, size);\n  return ret;\n};\n\nvar AsciiToString = ptr => {\n  var str = \"\";\n  while (1) {\n    var ch = HEAPU8[ptr++];\n    if (!ch) return str;\n    str += String.fromCharCode(ch);\n  }\n};\n\nvar stringToUTF16 = (str, outPtr, maxBytesToWrite) => {\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n  maxBytesToWrite ??= 2147483647;\n  if (maxBytesToWrite < 2) return 0;\n  maxBytesToWrite -= 2;\n  // Null terminator.\n  var startPtr = outPtr;\n  var numCharsToWrite = (maxBytesToWrite < str.length * 2) ? (maxBytesToWrite / 2) : str.length;\n  for (var i = 0; i < numCharsToWrite; ++i) {\n    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\n    var codeUnit = str.charCodeAt(i);\n    // possibly a lead surrogate\n    LE_HEAP_STORE_I16(((outPtr) >> 1) * 2, codeUnit);\n    outPtr += 2;\n  }\n  // Null-terminate the pointer to the HEAP.\n  LE_HEAP_STORE_I16(((outPtr) >> 1) * 2, 0);\n  return outPtr - startPtr;\n};\n\nvar LE_HEAP_STORE_I64 = (byteOffset, value) => HEAP_DATA_VIEW.setBigInt64(byteOffset, value, true);\n\nLE_ATOMICS_NATIVE_BYTE_ORDER = (new Int8Array(new Int16Array([ 1 ]).buffer)[0] === 1) ? [ /* little endian */ (x => x), (x => x), undefined, (x => x) ] : [ /* big endian */ (x => x), (x => (((x & 65280) << 8) | ((x & 255) << 24)) >> 16), undefined, (x => ((x >> 24) & 255) | ((x >> 8) & 65280) | ((x & 65280) << 8) | ((x & 255) << 24)) ];\n\nfunction LE_HEAP_UPDATE() {\n  HEAPU16.unsigned = (x => x & 65535);\n  HEAPU32.unsigned = (x => x >>> 0);\n}\n\n// End JS library code\n// include: postlibrary.js\n// This file is included after the automatically-generated JS library code\n// but before the wasm module is created.\n{\n  // With WASM_ESM_INTEGRATION this has to happen at the top level and not\n  // delayed until processModuleArgs.\n  initMemory();\n  // Begin ATMODULES hooks\n  if (Module[\"noExitRuntime\"]) noExitRuntime = Module[\"noExitRuntime\"];\n  if (Module[\"print\"]) out = Module[\"print\"];\n  if (Module[\"printErr\"]) err = Module[\"printErr\"];\n  if (Module[\"dynamicLibraries\"]) dynamicLibraries = Module[\"dynamicLibraries\"];\n  if (Module[\"wasmBinary\"]) wasmBinary = Module[\"wasmBinary\"];\n  // End ATMODULES hooks\n  if (Module[\"arguments\"]) arguments_ = Module[\"arguments\"];\n  if (Module[\"thisProgram\"]) thisProgram = Module[\"thisProgram\"];\n}\n\n// Begin runtime exports\nModule[\"setValue\"] = setValue;\n\nModule[\"getValue\"] = getValue;\n\nModule[\"UTF8ToString\"] = UTF8ToString;\n\nModule[\"stringToUTF8\"] = stringToUTF8;\n\nModule[\"lengthBytesUTF8\"] = lengthBytesUTF8;\n\nModule[\"AsciiToString\"] = AsciiToString;\n\nModule[\"stringToUTF16\"] = stringToUTF16;\n\nModule[\"loadWebAssemblyModule\"] = loadWebAssemblyModule;\n\nModule[\"LE_HEAP_STORE_I64\"] = LE_HEAP_STORE_I64;\n\n// End runtime exports\n// Begin JS library exports\n// End JS library exports\n// end include: postlibrary.js\nvar ASM_CONSTS = {};\n\n// Imports from the Wasm binary.\nvar _malloc, _calloc, _realloc, _free, _memcmp, _ts_language_symbol_count, _ts_language_state_count, _ts_language_version, _ts_language_abi_version, _ts_language_metadata, _ts_language_name, _ts_language_field_count, _ts_language_next_state, _ts_language_symbol_name, _ts_language_symbol_for_name, _strncmp, _ts_language_symbol_type, _ts_language_field_name_for_id, _ts_lookahead_iterator_new, _ts_lookahead_iterator_delete, _ts_lookahead_iterator_reset_state, _ts_lookahead_iterator_reset, _ts_lookahead_iterator_next, _ts_lookahead_iterator_current_symbol, _ts_parser_delete, _ts_parser_reset, _ts_parser_set_language, _ts_parser_timeout_micros, _ts_parser_set_timeout_micros, _ts_parser_set_included_ranges, _ts_query_new, _ts_query_delete, _iswspace, _iswalnum, _ts_query_pattern_count, _ts_query_capture_count, _ts_query_string_count, _ts_query_capture_name_for_id, _ts_query_capture_quantifier_for_id, _ts_query_string_value_for_id, _ts_query_predicates_for_pattern, _ts_query_start_byte_for_pattern, _ts_query_end_byte_for_pattern, _ts_query_is_pattern_rooted, _ts_query_is_pattern_non_local, _ts_query_is_pattern_guaranteed_at_step, _ts_query_disable_capture, _ts_query_disable_pattern, _ts_tree_copy, _ts_tree_delete, _ts_init, _ts_parser_new_wasm, _ts_parser_enable_logger_wasm, _ts_parser_parse_wasm, _ts_parser_included_ranges_wasm, _ts_language_type_is_named_wasm, _ts_language_type_is_visible_wasm, _ts_language_supertypes_wasm, _ts_language_subtypes_wasm, _ts_tree_root_node_wasm, _ts_tree_root_node_with_offset_wasm, _ts_tree_edit_wasm, _ts_tree_included_ranges_wasm, _ts_tree_get_changed_ranges_wasm, _ts_tree_cursor_new_wasm, _ts_tree_cursor_copy_wasm, _ts_tree_cursor_delete_wasm, _ts_tree_cursor_reset_wasm, _ts_tree_cursor_reset_to_wasm, _ts_tree_cursor_goto_first_child_wasm, _ts_tree_cursor_goto_last_child_wasm, _ts_tree_cursor_goto_first_child_for_index_wasm, _ts_tree_cursor_goto_first_child_for_position_wasm, _ts_tree_cursor_goto_next_sibling_wasm, _ts_tree_cursor_goto_previous_sibling_wasm, _ts_tree_cursor_goto_descendant_wasm, _ts_tree_cursor_goto_parent_wasm, _ts_tree_cursor_current_node_type_id_wasm, _ts_tree_cursor_current_node_state_id_wasm, _ts_tree_cursor_current_node_is_named_wasm, _ts_tree_cursor_current_node_is_missing_wasm, _ts_tree_cursor_current_node_id_wasm, _ts_tree_cursor_start_position_wasm, _ts_tree_cursor_end_position_wasm, _ts_tree_cursor_start_index_wasm, _ts_tree_cursor_end_index_wasm, _ts_tree_cursor_current_field_id_wasm, _ts_tree_cursor_current_depth_wasm, _ts_tree_cursor_current_descendant_index_wasm, _ts_tree_cursor_current_node_wasm, _ts_node_symbol_wasm, _ts_node_field_name_for_child_wasm, _ts_node_field_name_for_named_child_wasm, _ts_node_children_by_field_id_wasm, _ts_node_first_child_for_byte_wasm, _ts_node_first_named_child_for_byte_wasm, _ts_node_grammar_symbol_wasm, _ts_node_child_count_wasm, _ts_node_named_child_count_wasm, _ts_node_child_wasm, _ts_node_named_child_wasm, _ts_node_child_by_field_id_wasm, _ts_node_next_sibling_wasm, _ts_node_prev_sibling_wasm, _ts_node_next_named_sibling_wasm, _ts_node_prev_named_sibling_wasm, _ts_node_descendant_count_wasm, _ts_node_parent_wasm, _ts_node_child_with_descendant_wasm, _ts_node_descendant_for_index_wasm, _ts_node_named_descendant_for_index_wasm, _ts_node_descendant_for_position_wasm, _ts_node_named_descendant_for_position_wasm, _ts_node_start_point_wasm, _ts_node_end_point_wasm, _ts_node_start_index_wasm, _ts_node_end_index_wasm, _ts_node_to_string_wasm, _ts_node_children_wasm, _ts_node_named_children_wasm, _ts_node_descendants_of_type_wasm, _ts_node_is_named_wasm, _ts_node_has_changes_wasm, _ts_node_has_error_wasm, _ts_node_is_error_wasm, _ts_node_is_missing_wasm, _ts_node_is_extra_wasm, _ts_node_parse_state_wasm, _ts_node_next_parse_state_wasm, _ts_query_matches_wasm, _ts_query_captures_wasm, _memset, _memcpy, _memmove, _iswalpha, _iswblank, _iswdigit, _iswlower, _iswupper, _iswxdigit, _memchr, _strlen, _strcmp, _strncat, _strncpy, _towlower, _towupper, _setThrew, __emscripten_stack_restore, __emscripten_stack_alloc, _emscripten_stack_get_current, ___wasm_apply_data_relocs;\n\nfunction assignWasmExports(wasmExports) {\n  Module[\"_malloc\"] = _malloc = wasmExports[\"malloc\"];\n  Module[\"_calloc\"] = _calloc = wasmExports[\"calloc\"];\n  Module[\"_realloc\"] = _realloc = wasmExports[\"realloc\"];\n  Module[\"_free\"] = _free = wasmExports[\"free\"];\n  Module[\"_memcmp\"] = _memcmp = wasmExports[\"memcmp\"];\n  Module[\"_ts_language_symbol_count\"] = _ts_language_symbol_count = wasmExports[\"ts_language_symbol_count\"];\n  Module[\"_ts_language_state_count\"] = _ts_language_state_count = wasmExports[\"ts_language_state_count\"];\n  Module[\"_ts_language_version\"] = _ts_language_version = wasmExports[\"ts_language_version\"];\n  Module[\"_ts_language_abi_version\"] = _ts_language_abi_version = wasmExports[\"ts_language_abi_version\"];\n  Module[\"_ts_language_metadata\"] = _ts_language_metadata = wasmExports[\"ts_language_metadata\"];\n  Module[\"_ts_language_name\"] = _ts_language_name = wasmExports[\"ts_language_name\"];\n  Module[\"_ts_language_field_count\"] = _ts_language_field_count = wasmExports[\"ts_language_field_count\"];\n  Module[\"_ts_language_next_state\"] = _ts_language_next_state = wasmExports[\"ts_language_next_state\"];\n  Module[\"_ts_language_symbol_name\"] = _ts_language_symbol_name = wasmExports[\"ts_language_symbol_name\"];\n  Module[\"_ts_language_symbol_for_name\"] = _ts_language_symbol_for_name = wasmExports[\"ts_language_symbol_for_name\"];\n  Module[\"_strncmp\"] = _strncmp = wasmExports[\"strncmp\"];\n  Module[\"_ts_language_symbol_type\"] = _ts_language_symbol_type = wasmExports[\"ts_language_symbol_type\"];\n  Module[\"_ts_language_field_name_for_id\"] = _ts_language_field_name_for_id = wasmExports[\"ts_language_field_name_for_id\"];\n  Module[\"_ts_lookahead_iterator_new\"] = _ts_lookahead_iterator_new = wasmExports[\"ts_lookahead_iterator_new\"];\n  Module[\"_ts_lookahead_iterator_delete\"] = _ts_lookahead_iterator_delete = wasmExports[\"ts_lookahead_iterator_delete\"];\n  Module[\"_ts_lookahead_iterator_reset_state\"] = _ts_lookahead_iterator_reset_state = wasmExports[\"ts_lookahead_iterator_reset_state\"];\n  Module[\"_ts_lookahead_iterator_reset\"] = _ts_lookahead_iterator_reset = wasmExports[\"ts_lookahead_iterator_reset\"];\n  Module[\"_ts_lookahead_iterator_next\"] = _ts_lookahead_iterator_next = wasmExports[\"ts_lookahead_iterator_next\"];\n  Module[\"_ts_lookahead_iterator_current_symbol\"] = _ts_lookahead_iterator_current_symbol = wasmExports[\"ts_lookahead_iterator_current_symbol\"];\n  Module[\"_ts_parser_delete\"] = _ts_parser_delete = wasmExports[\"ts_parser_delete\"];\n  Module[\"_ts_parser_reset\"] = _ts_parser_reset = wasmExports[\"ts_parser_reset\"];\n  Module[\"_ts_parser_set_language\"] = _ts_parser_set_language = wasmExports[\"ts_parser_set_language\"];\n  Module[\"_ts_parser_timeout_micros\"] = _ts_parser_timeout_micros = wasmExports[\"ts_parser_timeout_micros\"];\n  Module[\"_ts_parser_set_timeout_micros\"] = _ts_parser_set_timeout_micros = wasmExports[\"ts_parser_set_timeout_micros\"];\n  Module[\"_ts_parser_set_included_ranges\"] = _ts_parser_set_included_ranges = wasmExports[\"ts_parser_set_included_ranges\"];\n  Module[\"_ts_query_new\"] = _ts_query_new = wasmExports[\"ts_query_new\"];\n  Module[\"_ts_query_delete\"] = _ts_query_delete = wasmExports[\"ts_query_delete\"];\n  Module[\"_iswspace\"] = _iswspace = wasmExports[\"iswspace\"];\n  Module[\"_iswalnum\"] = _iswalnum = wasmExports[\"iswalnum\"];\n  Module[\"_ts_query_pattern_count\"] = _ts_query_pattern_count = wasmExports[\"ts_query_pattern_count\"];\n  Module[\"_ts_query_capture_count\"] = _ts_query_capture_count = wasmExports[\"ts_query_capture_count\"];\n  Module[\"_ts_query_string_count\"] = _ts_query_string_count = wasmExports[\"ts_query_string_count\"];\n  Module[\"_ts_query_capture_name_for_id\"] = _ts_query_capture_name_for_id = wasmExports[\"ts_query_capture_name_for_id\"];\n  Module[\"_ts_query_capture_quantifier_for_id\"] = _ts_query_capture_quantifier_for_id = wasmExports[\"ts_query_capture_quantifier_for_id\"];\n  Module[\"_ts_query_string_value_for_id\"] = _ts_query_string_value_for_id = wasmExports[\"ts_query_string_value_for_id\"];\n  Module[\"_ts_query_predicates_for_pattern\"] = _ts_query_predicates_for_pattern = wasmExports[\"ts_query_predicates_for_pattern\"];\n  Module[\"_ts_query_start_byte_for_pattern\"] = _ts_query_start_byte_for_pattern = wasmExports[\"ts_query_start_byte_for_pattern\"];\n  Module[\"_ts_query_end_byte_for_pattern\"] = _ts_query_end_byte_for_pattern = wasmExports[\"ts_query_end_byte_for_pattern\"];\n  Module[\"_ts_query_is_pattern_rooted\"] = _ts_query_is_pattern_rooted = wasmExports[\"ts_query_is_pattern_rooted\"];\n  Module[\"_ts_query_is_pattern_non_local\"] = _ts_query_is_pattern_non_local = wasmExports[\"ts_query_is_pattern_non_local\"];\n  Module[\"_ts_query_is_pattern_guaranteed_at_step\"] = _ts_query_is_pattern_guaranteed_at_step = wasmExports[\"ts_query_is_pattern_guaranteed_at_step\"];\n  Module[\"_ts_query_disable_capture\"] = _ts_query_disable_capture = wasmExports[\"ts_query_disable_capture\"];\n  Module[\"_ts_query_disable_pattern\"] = _ts_query_disable_pattern = wasmExports[\"ts_query_disable_pattern\"];\n  Module[\"_ts_tree_copy\"] = _ts_tree_copy = wasmExports[\"ts_tree_copy\"];\n  Module[\"_ts_tree_delete\"] = _ts_tree_delete = wasmExports[\"ts_tree_delete\"];\n  Module[\"_ts_init\"] = _ts_init = wasmExports[\"ts_init\"];\n  Module[\"_ts_parser_new_wasm\"] = _ts_parser_new_wasm = wasmExports[\"ts_parser_new_wasm\"];\n  Module[\"_ts_parser_enable_logger_wasm\"] = _ts_parser_enable_logger_wasm = wasmExports[\"ts_parser_enable_logger_wasm\"];\n  Module[\"_ts_parser_parse_wasm\"] = _ts_parser_parse_wasm = wasmExports[\"ts_parser_parse_wasm\"];\n  Module[\"_ts_parser_included_ranges_wasm\"] = _ts_parser_included_ranges_wasm = wasmExports[\"ts_parser_included_ranges_wasm\"];\n  Module[\"_ts_language_type_is_named_wasm\"] = _ts_language_type_is_named_wasm = wasmExports[\"ts_language_type_is_named_wasm\"];\n  Module[\"_ts_language_type_is_visible_wasm\"] = _ts_language_type_is_visible_wasm = wasmExports[\"ts_language_type_is_visible_wasm\"];\n  Module[\"_ts_language_supertypes_wasm\"] = _ts_language_supertypes_wasm = wasmExports[\"ts_language_supertypes_wasm\"];\n  Module[\"_ts_language_subtypes_wasm\"] = _ts_language_subtypes_wasm = wasmExports[\"ts_language_subtypes_wasm\"];\n  Module[\"_ts_tree_root_node_wasm\"] = _ts_tree_root_node_wasm = wasmExports[\"ts_tree_root_node_wasm\"];\n  Module[\"_ts_tree_root_node_with_offset_wasm\"] = _ts_tree_root_node_with_offset_wasm = wasmExports[\"ts_tree_root_node_with_offset_wasm\"];\n  Module[\"_ts_tree_edit_wasm\"] = _ts_tree_edit_wasm = wasmExports[\"ts_tree_edit_wasm\"];\n  Module[\"_ts_tree_included_ranges_wasm\"] = _ts_tree_included_ranges_wasm = wasmExports[\"ts_tree_included_ranges_wasm\"];\n  Module[\"_ts_tree_get_changed_ranges_wasm\"] = _ts_tree_get_changed_ranges_wasm = wasmExports[\"ts_tree_get_changed_ranges_wasm\"];\n  Module[\"_ts_tree_cursor_new_wasm\"] = _ts_tree_cursor_new_wasm = wasmExports[\"ts_tree_cursor_new_wasm\"];\n  Module[\"_ts_tree_cursor_copy_wasm\"] = _ts_tree_cursor_copy_wasm = wasmExports[\"ts_tree_cursor_copy_wasm\"];\n  Module[\"_ts_tree_cursor_delete_wasm\"] = _ts_tree_cursor_delete_wasm = wasmExports[\"ts_tree_cursor_delete_wasm\"];\n  Module[\"_ts_tree_cursor_reset_wasm\"] = _ts_tree_cursor_reset_wasm = wasmExports[\"ts_tree_cursor_reset_wasm\"];\n  Module[\"_ts_tree_cursor_reset_to_wasm\"] = _ts_tree_cursor_reset_to_wasm = wasmExports[\"ts_tree_cursor_reset_to_wasm\"];\n  Module[\"_ts_tree_cursor_goto_first_child_wasm\"] = _ts_tree_cursor_goto_first_child_wasm = wasmExports[\"ts_tree_cursor_goto_first_child_wasm\"];\n  Module[\"_ts_tree_cursor_goto_last_child_wasm\"] = _ts_tree_cursor_goto_last_child_wasm = wasmExports[\"ts_tree_cursor_goto_last_child_wasm\"];\n  Module[\"_ts_tree_cursor_goto_first_child_for_index_wasm\"] = _ts_tree_cursor_goto_first_child_for_index_wasm = wasmExports[\"ts_tree_cursor_goto_first_child_for_index_wasm\"];\n  Module[\"_ts_tree_cursor_goto_first_child_for_position_wasm\"] = _ts_tree_cursor_goto_first_child_for_position_wasm = wasmExports[\"ts_tree_cursor_goto_first_child_for_position_wasm\"];\n  Module[\"_ts_tree_cursor_goto_next_sibling_wasm\"] = _ts_tree_cursor_goto_next_sibling_wasm = wasmExports[\"ts_tree_cursor_goto_next_sibling_wasm\"];\n  Module[\"_ts_tree_cursor_goto_previous_sibling_wasm\"] = _ts_tree_cursor_goto_previous_sibling_wasm = wasmExports[\"ts_tree_cursor_goto_previous_sibling_wasm\"];\n  Module[\"_ts_tree_cursor_goto_descendant_wasm\"] = _ts_tree_cursor_goto_descendant_wasm = wasmExports[\"ts_tree_cursor_goto_descendant_wasm\"];\n  Module[\"_ts_tree_cursor_goto_parent_wasm\"] = _ts_tree_cursor_goto_parent_wasm = wasmExports[\"ts_tree_cursor_goto_parent_wasm\"];\n  Module[\"_ts_tree_cursor_current_node_type_id_wasm\"] = _ts_tree_cursor_current_node_type_id_wasm = wasmExports[\"ts_tree_cursor_current_node_type_id_wasm\"];\n  Module[\"_ts_tree_cursor_current_node_state_id_wasm\"] = _ts_tree_cursor_current_node_state_id_wasm = wasmExports[\"ts_tree_cursor_current_node_state_id_wasm\"];\n  Module[\"_ts_tree_cursor_current_node_is_named_wasm\"] = _ts_tree_cursor_current_node_is_named_wasm = wasmExports[\"ts_tree_cursor_current_node_is_named_wasm\"];\n  Module[\"_ts_tree_cursor_current_node_is_missing_wasm\"] = _ts_tree_cursor_current_node_is_missing_wasm = wasmExports[\"ts_tree_cursor_current_node_is_missing_wasm\"];\n  Module[\"_ts_tree_cursor_current_node_id_wasm\"] = _ts_tree_cursor_current_node_id_wasm = wasmExports[\"ts_tree_cursor_current_node_id_wasm\"];\n  Module[\"_ts_tree_cursor_start_position_wasm\"] = _ts_tree_cursor_start_position_wasm = wasmExports[\"ts_tree_cursor_start_position_wasm\"];\n  Module[\"_ts_tree_cursor_end_position_wasm\"] = _ts_tree_cursor_end_position_wasm = wasmExports[\"ts_tree_cursor_end_position_wasm\"];\n  Module[\"_ts_tree_cursor_start_index_wasm\"] = _ts_tree_cursor_start_index_wasm = wasmExports[\"ts_tree_cursor_start_index_wasm\"];\n  Module[\"_ts_tree_cursor_end_index_wasm\"] = _ts_tree_cursor_end_index_wasm = wasmExports[\"ts_tree_cursor_end_index_wasm\"];\n  Module[\"_ts_tree_cursor_current_field_id_wasm\"] = _ts_tree_cursor_current_field_id_wasm = wasmExports[\"ts_tree_cursor_current_field_id_wasm\"];\n  Module[\"_ts_tree_cursor_current_depth_wasm\"] = _ts_tree_cursor_current_depth_wasm = wasmExports[\"ts_tree_cursor_current_depth_wasm\"];\n  Module[\"_ts_tree_cursor_current_descendant_index_wasm\"] = _ts_tree_cursor_current_descendant_index_wasm = wasmExports[\"ts_tree_cursor_current_descendant_index_wasm\"];\n  Module[\"_ts_tree_cursor_current_node_wasm\"] = _ts_tree_cursor_current_node_wasm = wasmExports[\"ts_tree_cursor_current_node_wasm\"];\n  Module[\"_ts_node_symbol_wasm\"] = _ts_node_symbol_wasm = wasmExports[\"ts_node_symbol_wasm\"];\n  Module[\"_ts_node_field_name_for_child_wasm\"] = _ts_node_field_name_for_child_wasm = wasmExports[\"ts_node_field_name_for_child_wasm\"];\n  Module[\"_ts_node_field_name_for_named_child_wasm\"] = _ts_node_field_name_for_named_child_wasm = wasmExports[\"ts_node_field_name_for_named_child_wasm\"];\n  Module[\"_ts_node_children_by_field_id_wasm\"] = _ts_node_children_by_field_id_wasm = wasmExports[\"ts_node_children_by_field_id_wasm\"];\n  Module[\"_ts_node_first_child_for_byte_wasm\"] = _ts_node_first_child_for_byte_wasm = wasmExports[\"ts_node_first_child_for_byte_wasm\"];\n  Module[\"_ts_node_first_named_child_for_byte_wasm\"] = _ts_node_first_named_child_for_byte_wasm = wasmExports[\"ts_node_first_named_child_for_byte_wasm\"];\n  Module[\"_ts_node_grammar_symbol_wasm\"] = _ts_node_grammar_symbol_wasm = wasmExports[\"ts_node_grammar_symbol_wasm\"];\n  Module[\"_ts_node_child_count_wasm\"] = _ts_node_child_count_wasm = wasmExports[\"ts_node_child_count_wasm\"];\n  Module[\"_ts_node_named_child_count_wasm\"] = _ts_node_named_child_count_wasm = wasmExports[\"ts_node_named_child_count_wasm\"];\n  Module[\"_ts_node_child_wasm\"] = _ts_node_child_wasm = wasmExports[\"ts_node_child_wasm\"];\n  Module[\"_ts_node_named_child_wasm\"] = _ts_node_named_child_wasm = wasmExports[\"ts_node_named_child_wasm\"];\n  Module[\"_ts_node_child_by_field_id_wasm\"] = _ts_node_child_by_field_id_wasm = wasmExports[\"ts_node_child_by_field_id_wasm\"];\n  Module[\"_ts_node_next_sibling_wasm\"] = _ts_node_next_sibling_wasm = wasmExports[\"ts_node_next_sibling_wasm\"];\n  Module[\"_ts_node_prev_sibling_wasm\"] = _ts_node_prev_sibling_wasm = wasmExports[\"ts_node_prev_sibling_wasm\"];\n  Module[\"_ts_node_next_named_sibling_wasm\"] = _ts_node_next_named_sibling_wasm = wasmExports[\"ts_node_next_named_sibling_wasm\"];\n  Module[\"_ts_node_prev_named_sibling_wasm\"] = _ts_node_prev_named_sibling_wasm = wasmExports[\"ts_node_prev_named_sibling_wasm\"];\n  Module[\"_ts_node_descendant_count_wasm\"] = _ts_node_descendant_count_wasm = wasmExports[\"ts_node_descendant_count_wasm\"];\n  Module[\"_ts_node_parent_wasm\"] = _ts_node_parent_wasm = wasmExports[\"ts_node_parent_wasm\"];\n  Module[\"_ts_node_child_with_descendant_wasm\"] = _ts_node_child_with_descendant_wasm = wasmExports[\"ts_node_child_with_descendant_wasm\"];\n  Module[\"_ts_node_descendant_for_index_wasm\"] = _ts_node_descendant_for_index_wasm = wasmExports[\"ts_node_descendant_for_index_wasm\"];\n  Module[\"_ts_node_named_descendant_for_index_wasm\"] = _ts_node_named_descendant_for_index_wasm = wasmExports[\"ts_node_named_descendant_for_index_wasm\"];\n  Module[\"_ts_node_descendant_for_position_wasm\"] = _ts_node_descendant_for_position_wasm = wasmExports[\"ts_node_descendant_for_position_wasm\"];\n  Module[\"_ts_node_named_descendant_for_position_wasm\"] = _ts_node_named_descendant_for_position_wasm = wasmExports[\"ts_node_named_descendant_for_position_wasm\"];\n  Module[\"_ts_node_start_point_wasm\"] = _ts_node_start_point_wasm = wasmExports[\"ts_node_start_point_wasm\"];\n  Module[\"_ts_node_end_point_wasm\"] = _ts_node_end_point_wasm = wasmExports[\"ts_node_end_point_wasm\"];\n  Module[\"_ts_node_start_index_wasm\"] = _ts_node_start_index_wasm = wasmExports[\"ts_node_start_index_wasm\"];\n  Module[\"_ts_node_end_index_wasm\"] = _ts_node_end_index_wasm = wasmExports[\"ts_node_end_index_wasm\"];\n  Module[\"_ts_node_to_string_wasm\"] = _ts_node_to_string_wasm = wasmExports[\"ts_node_to_string_wasm\"];\n  Module[\"_ts_node_children_wasm\"] = _ts_node_children_wasm = wasmExports[\"ts_node_children_wasm\"];\n  Module[\"_ts_node_named_children_wasm\"] = _ts_node_named_children_wasm = wasmExports[\"ts_node_named_children_wasm\"];\n  Module[\"_ts_node_descendants_of_type_wasm\"] = _ts_node_descendants_of_type_wasm = wasmExports[\"ts_node_descendants_of_type_wasm\"];\n  Module[\"_ts_node_is_named_wasm\"] = _ts_node_is_named_wasm = wasmExports[\"ts_node_is_named_wasm\"];\n  Module[\"_ts_node_has_changes_wasm\"] = _ts_node_has_changes_wasm = wasmExports[\"ts_node_has_changes_wasm\"];\n  Module[\"_ts_node_has_error_wasm\"] = _ts_node_has_error_wasm = wasmExports[\"ts_node_has_error_wasm\"];\n  Module[\"_ts_node_is_error_wasm\"] = _ts_node_is_error_wasm = wasmExports[\"ts_node_is_error_wasm\"];\n  Module[\"_ts_node_is_missing_wasm\"] = _ts_node_is_missing_wasm = wasmExports[\"ts_node_is_missing_wasm\"];\n  Module[\"_ts_node_is_extra_wasm\"] = _ts_node_is_extra_wasm = wasmExports[\"ts_node_is_extra_wasm\"];\n  Module[\"_ts_node_parse_state_wasm\"] = _ts_node_parse_state_wasm = wasmExports[\"ts_node_parse_state_wasm\"];\n  Module[\"_ts_node_next_parse_state_wasm\"] = _ts_node_next_parse_state_wasm = wasmExports[\"ts_node_next_parse_state_wasm\"];\n  Module[\"_ts_query_matches_wasm\"] = _ts_query_matches_wasm = wasmExports[\"ts_query_matches_wasm\"];\n  Module[\"_ts_query_captures_wasm\"] = _ts_query_captures_wasm = wasmExports[\"ts_query_captures_wasm\"];\n  Module[\"_memset\"] = _memset = wasmExports[\"memset\"];\n  Module[\"_memcpy\"] = _memcpy = wasmExports[\"memcpy\"];\n  Module[\"_memmove\"] = _memmove = wasmExports[\"memmove\"];\n  Module[\"_iswalpha\"] = _iswalpha = wasmExports[\"iswalpha\"];\n  Module[\"_iswblank\"] = _iswblank = wasmExports[\"iswblank\"];\n  Module[\"_iswdigit\"] = _iswdigit = wasmExports[\"iswdigit\"];\n  Module[\"_iswlower\"] = _iswlower = wasmExports[\"iswlower\"];\n  Module[\"_iswupper\"] = _iswupper = wasmExports[\"iswupper\"];\n  Module[\"_iswxdigit\"] = _iswxdigit = wasmExports[\"iswxdigit\"];\n  Module[\"_memchr\"] = _memchr = wasmExports[\"memchr\"];\n  Module[\"_strlen\"] = _strlen = wasmExports[\"strlen\"];\n  Module[\"_strcmp\"] = _strcmp = wasmExports[\"strcmp\"];\n  Module[\"_strncat\"] = _strncat = wasmExports[\"strncat\"];\n  Module[\"_strncpy\"] = _strncpy = wasmExports[\"strncpy\"];\n  Module[\"_towlower\"] = _towlower = wasmExports[\"towlower\"];\n  Module[\"_towupper\"] = _towupper = wasmExports[\"towupper\"];\n  _setThrew = wasmExports[\"setThrew\"];\n  __emscripten_stack_restore = wasmExports[\"_emscripten_stack_restore\"];\n  __emscripten_stack_alloc = wasmExports[\"_emscripten_stack_alloc\"];\n  _emscripten_stack_get_current = wasmExports[\"emscripten_stack_get_current\"];\n  ___wasm_apply_data_relocs = wasmExports[\"__wasm_apply_data_relocs\"];\n}\n\nvar wasmImports = {\n  /** @export */ __heap_base: ___heap_base,\n  /** @export */ __indirect_function_table: wasmTable,\n  /** @export */ __memory_base: ___memory_base,\n  /** @export */ __stack_high: ___stack_high,\n  /** @export */ __stack_low: ___stack_low,\n  /** @export */ __stack_pointer: ___stack_pointer,\n  /** @export */ __table_base: ___table_base,\n  /** @export */ _abort_js: __abort_js,\n  /** @export */ clock_time_get: _clock_time_get,\n  /** @export */ emscripten_resize_heap: _emscripten_resize_heap,\n  /** @export */ fd_close: _fd_close,\n  /** @export */ fd_seek: _fd_seek,\n  /** @export */ fd_write: _fd_write,\n  /** @export */ memory: wasmMemory,\n  /** @export */ tree_sitter_log_callback: _tree_sitter_log_callback,\n  /** @export */ tree_sitter_parse_callback: _tree_sitter_parse_callback,\n  /** @export */ tree_sitter_progress_callback: _tree_sitter_progress_callback,\n  /** @export */ tree_sitter_query_progress_callback: _tree_sitter_query_progress_callback\n};\n\nvar wasmExports = await createWasm();\n\n// include: postamble.js\n// === Auto-generated postamble setup entry stuff ===\nfunction callMain(args = []) {\n  var entryFunction = resolveGlobalSymbol(\"main\").sym;\n  // Main modules can't tell if they have main() at compile time, since it may\n  // arrive from a dynamic library.\n  if (!entryFunction) return;\n  args.unshift(thisProgram);\n  var argc = args.length;\n  var argv = stackAlloc((argc + 1) * 4);\n  var argv_ptr = argv;\n  args.forEach(arg => {\n    LE_HEAP_STORE_U32(((argv_ptr) >> 2) * 4, stringToUTF8OnStack(arg));\n    argv_ptr += 4;\n  });\n  LE_HEAP_STORE_U32(((argv_ptr) >> 2) * 4, 0);\n  try {\n    var ret = entryFunction(argc, argv);\n    // if we're not running an evented main loop, it's time to exit\n    exitJS(ret, /* implicit = */ true);\n    return ret;\n  } catch (e) {\n    return handleException(e);\n  }\n}\n\nfunction run(args = arguments_) {\n  if (runDependencies > 0) {\n    dependenciesFulfilled = run;\n    return;\n  }\n  preRun();\n  // a preRun added a dependency, run will be called later\n  if (runDependencies > 0) {\n    dependenciesFulfilled = run;\n    return;\n  }\n  function doRun() {\n    // run may have just been called through dependencies being fulfilled just in this very frame,\n    // or while the async setStatus time below was happening\n    Module[\"calledRun\"] = true;\n    if (ABORT) return;\n    initRuntime();\n    preMain();\n    readyPromiseResolve?.(Module);\n    Module[\"onRuntimeInitialized\"]?.();\n    var noInitialRun = Module[\"noInitialRun\"] || false;\n    if (!noInitialRun) callMain(args);\n    postRun();\n  }\n  if (Module[\"setStatus\"]) {\n    Module[\"setStatus\"](\"Running...\");\n    setTimeout(() => {\n      setTimeout(() => Module[\"setStatus\"](\"\"), 1);\n      doRun();\n    }, 1);\n  } else {\n    doRun();\n  }\n}\n\nfunction preInit() {\n  if (Module[\"preInit\"]) {\n    if (typeof Module[\"preInit\"] == \"function\") Module[\"preInit\"] = [ Module[\"preInit\"] ];\n    while (Module[\"preInit\"].length > 0) {\n      Module[\"preInit\"].shift()();\n    }\n  }\n}\n\npreInit();\n\nrun();\n\n// end include: postamble.js\n// include: postamble_modularize.js\n// In MODULARIZE mode we wrap the generated code in a factory function\n// and return either the Module itself, or a promise of the module.\n// We assign to the `moduleRtn` global here and configure closure to see\n// this as and extern so it won't get minified.\nif (runtimeInitialized) {\n  moduleRtn = Module;\n} else {\n  // Set up the promise that indicates the Module is initialized\n  moduleRtn = new Promise((resolve, reject) => {\n    readyPromiseResolve = resolve;\n    readyPromiseReject = reject;\n  });\n}\n\n\n  return moduleRtn;\n}\n\n// Export using a UMD style export, or ES6 exports if selected\nexport default Module;\n\n", "import createModule, { type MainModule } from '../lib/web-tree-sitter';\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { type Parser } from './parser';\n\nexport let Module: MainModule | null = null;\n\n/**\n * @internal\n *\n * Initialize the Tree-sitter Wasm module. This should only be called by the {@link Parser} class via {@link Parser.init}.\n */\nexport async function initializeBinding(moduleOptions?: Partial<EmscriptenModule>): Promise<MainModule> {\n  try {\n    return Module ??= await createModule(moduleOptions);\n  } catch (error) {\n    const errorStr = String(error);\n    \n    // Check for the specific \"magic word\" error that happens when WASM file is missing\n    if (errorStr.includes('expected magic word') && errorStr.includes('4e 6f 74 20')) {\n      // 4e 6f 74 20 = \"Not \" - indicates server returned HTML error page\n      const message = [\n        'Failed to load web-tree-sitter.wasm',\n        'The server returned an error page instead of the WebAssembly file.',\n        moduleOptions?.locateFile \n          ? 'Check that your locateFile() returns the correct path.'\n          : 'You may need to provide a locateFile() option to specify the .wasm path.'\n      ].join('\\n');\n      \n      throw new Error(message);\n    }\n    \n    // Re-throw with original error\n    throw error;\n  }\n}\n\n/**\n * @internal\n *\n * Checks if the Tree-sitter Wasm module has been initialized.\n */\nexport function checkModule(): boolean {\n  return !!Module;\n}\n", "import { C, INTERNAL, LogCallback, ParseCallback, Range, SIZE_OF_INT, SIZE_OF_RANGE, setModule } from './constants';\nimport { Language } from './language';\nimport { marshalRange, unmarshalRange } from './marshal';\nimport { checkModule, initializeBinding } from './bindings';\nimport { Tree } from './tree';\n\n/**\n * Options for parsing\n *\n * The `includedRanges` property is an array of {@link Range} objects that\n * represent the ranges of text that the parser should include when parsing.\n *\n * The `progressCallback` property is a function that is called periodically\n * during parsing to check whether parsing should be cancelled.\n *\n * See {@link Parser#parse} for more information.\n */\nexport interface ParseOptions {\n  /**\n   * An array of {@link Range} objects that\n   * represent the ranges of text that the parser should include when parsing.\n   *\n   * This sets the ranges of text that the parser should include when parsing.\n   * By default, the parser will always include entire documents. This\n   * function allows you to parse only a *portion* of a document but\n   * still return a syntax tree whose ranges match up with the document\n   * as a whole. You can also pass multiple disjoint ranges.\n   * If `ranges` is empty, then the entire document will be parsed.\n   * Otherwise, the given ranges must be ordered from earliest to latest\n   * in the document, and they must not overlap. That is, the following\n   * must hold for all `i` < `length - 1`:\n   * ```text\n   *     ranges[i].end_byte <= ranges[i + 1].start_byte\n   * ```\n   */\n  includedRanges?: Range[];\n\n  /**\n   * A function that is called periodically during parsing to check\n   * whether parsing should be cancelled. If the progress callback returns\n   * `true`, then parsing will be cancelled. You can also use this to instrument\n   * parsing and check where the parser is at in the document. The progress callback\n   * takes a single argument, which is a {@link ParseState} representing the current\n   * state of the parser.\n   */\n  progressCallback?: (state: ParseState) => void;\n}\n\n/**\n * A stateful object that is passed into the progress callback {@link ParseOptions#progressCallback}\n * to provide the current state of the parser.\n */\nexport interface ParseState {\n  /** The byte offset in the document that the parser is at. */\n  currentOffset: number;\n\n  /** Indicates whether the parser has encountered an error during parsing. */\n  hasError: boolean;\n}\n\n/**\n * @internal\n *\n * Global variable for transferring data across the FFI boundary\n */\nexport let TRANSFER_BUFFER: number;\n\n/**\n * The latest ABI version that is supported by the current version of the\n * library.\n *\n * When Languages are generated by the Tree-sitter CLI, they are\n * assigned an ABI version number that corresponds to the current CLI version.\n * The Tree-sitter library is generally backwards-compatible with languages\n * generated using older CLI versions, but is not forwards-compatible.\n */\nexport let LANGUAGE_VERSION: number;\n\n/**\n * The earliest ABI version that is supported by the current version of the\n * library.\n */\nexport let MIN_COMPATIBLE_VERSION: number;\n\n/**\n * A stateful object that is used to produce a {@link Tree} based on some\n * source code.\n */\nexport class Parser {\n  /** @internal */\n  private [0] = 0; // Internal handle for Wasm\n\n  /** @internal */\n  private [1] = 0; // Internal handle for Wasm\n\n  /** @internal */\n  private logCallback: LogCallback | null = null;\n\n  /** The parser's current language. */\n  language: Language | null = null;\n\n  /**\n   * This must always be called before creating a Parser.\n   *\n   * You can optionally pass in options to configure the Wasm module, the most common\n   * one being `locateFile` to help the module find the `.wasm` file.\n   */\n  static async init(moduleOptions?: Partial<EmscriptenModule>) {\n    setModule(await initializeBinding(moduleOptions));\n    TRANSFER_BUFFER = C._ts_init();\n    LANGUAGE_VERSION = C.getValue(TRANSFER_BUFFER, 'i32');\n    MIN_COMPATIBLE_VERSION = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32');\n  }\n\n  /**\n   * Create a new parser.\n   */\n  constructor() {\n    this.initialize();\n  }\n\n  /** @internal */\n  initialize() {\n    if (!checkModule()) {\n      throw new Error(\"cannot construct a Parser before calling `init()`\");\n    }\n    C._ts_parser_new_wasm();\n    this[0] = C.getValue(TRANSFER_BUFFER, 'i32');\n    this[1] = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32');\n  }\n\n  /** Delete the parser, freeing its resources. */\n  delete() {\n    C._ts_parser_delete(this[0]);\n    C._free(this[1]);\n    this[0] = 0;\n    this[1] = 0;\n  }\n\n  /**\n   * Set the language that the parser should use for parsing.\n   *\n   * If the language was not successfully assigned, an error will be thrown.\n   * This happens if the language was generated with an incompatible\n   * version of the Tree-sitter CLI. Check the language's version using\n   * {@link Language#version} and compare it to this library's\n   * {@link LANGUAGE_VERSION} and {@link MIN_COMPATIBLE_VERSION} constants.\n   */\n  setLanguage(language: Language | null): this {\n    let address: number;\n    if (!language) {\n      address = 0;\n      this.language = null;\n    } else if (language.constructor === Language) {\n      address = language[0];\n      const version = C._ts_language_version(address);\n      if (version < MIN_COMPATIBLE_VERSION || LANGUAGE_VERSION < version) {\n        throw new Error(\n          `Incompatible language version ${version}. ` +\n          `Compatibility range ${MIN_COMPATIBLE_VERSION} through ${LANGUAGE_VERSION}.`\n        );\n      }\n      this.language = language;\n    } else {\n      throw new Error('Argument must be a Language');\n    }\n\n    C._ts_parser_set_language(this[0], address);\n    return this;\n  }\n\n  /**\n   * Parse a slice of UTF8 text.\n   *\n   * @param {string | ParseCallback} callback - The UTF8-encoded text to parse or a callback function.\n   *\n   * @param {Tree | null} [oldTree] - A previous syntax tree parsed from the same document. If the text of the\n   *   document has changed since `oldTree` was created, then you must edit `oldTree` to match\n   *   the new text using {@link Tree#edit}.\n   *\n   * @param {ParseOptions} [options] - Options for parsing the text.\n   *  This can be used to set the included ranges, or a progress callback.\n   *\n   * @returns {Tree | null} A {@link Tree} if parsing succeeded, or `null` if:\n   *  - The parser has not yet had a language assigned with {@link Parser#setLanguage}.\n   *  - The progress callback returned true.\n   */\n  parse(\n    callback: string | ParseCallback,\n    oldTree?: Tree | null,\n    options?: ParseOptions,\n  ): Tree | null {\n    if (typeof callback === 'string') {\n      C.currentParseCallback = (index: number) => callback.slice(index);\n    } else if (typeof callback === 'function') {\n      C.currentParseCallback = callback;\n    } else {\n      throw new Error('Argument must be a string or a function');\n    }\n\n    if (options?.progressCallback) {\n      C.currentProgressCallback = options.progressCallback;\n    } else {\n      C.currentProgressCallback = null;\n    }\n\n    if (this.logCallback) {\n      C.currentLogCallback = this.logCallback;\n      C._ts_parser_enable_logger_wasm(this[0], 1);\n    } else {\n      C.currentLogCallback = null;\n      C._ts_parser_enable_logger_wasm(this[0], 0);\n    }\n\n    let rangeCount = 0;\n    let rangeAddress = 0;\n    if (options?.includedRanges) {\n      rangeCount = options.includedRanges.length;\n      rangeAddress = C._calloc(rangeCount, SIZE_OF_RANGE);\n      let address = rangeAddress;\n      for (let i = 0; i < rangeCount; i++) {\n        marshalRange(address, options.includedRanges[i]);\n        address += SIZE_OF_RANGE;\n      }\n    }\n\n    const treeAddress = C._ts_parser_parse_wasm(\n      this[0],\n      this[1],\n      oldTree ? oldTree[0] : 0,\n      rangeAddress,\n      rangeCount\n    );\n\n    if (!treeAddress) {\n      C.currentParseCallback = null;\n      C.currentLogCallback = null;\n      C.currentProgressCallback = null;\n      return null;\n    }\n\n    if (!this.language) {\n      throw new Error('Parser must have a language to parse');\n    }\n\n    const result = new Tree(INTERNAL, treeAddress, this.language, C.currentParseCallback);\n    C.currentParseCallback = null;\n    C.currentLogCallback = null;\n    C.currentProgressCallback = null;\n    return result;\n  }\n\n  /**\n   * Instruct the parser to start the next parse from the beginning.\n   *\n   * If the parser previously failed because of a timeout, cancellation,\n   * or callback, then by default, it will resume where it left off on the\n   * next call to {@link Parser#parse} or other parsing functions.\n   * If you don't want to resume, and instead intend to use this parser to\n   * parse some other document, you must call `reset` first.\n   */\n  reset(): void {\n    C._ts_parser_reset(this[0]);\n  }\n\n  /** Get the ranges of text that the parser will include when parsing. */\n  getIncludedRanges(): Range[] {\n    C._ts_parser_included_ranges_wasm(this[0]);\n    const count = C.getValue(TRANSFER_BUFFER, 'i32');\n    const buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32');\n    const result = new Array<Range>(count);\n\n    if (count > 0) {\n      let address = buffer;\n      for (let i = 0; i < count; i++) {\n        result[i] = unmarshalRange(address);\n        address += SIZE_OF_RANGE;\n      }\n      C._free(buffer);\n    }\n\n    return result;\n  }\n\n  /**\n   * @deprecated since version 0.25.0, prefer passing a progress callback to {@link Parser#parse}\n   *\n   * Get the duration in microseconds that parsing is allowed to take.\n   *\n   * This is set via {@link Parser#setTimeoutMicros}.\n   */\n  getTimeoutMicros(): bigint {\n    return C._ts_parser_timeout_micros(this[0]);\n  }\n\n  /**\n   * @deprecated since version 0.25.0, prefer passing a progress callback to {@link Parser#parse}\n   *\n   * Set the maximum duration in microseconds that parsing should be allowed\n   * to take before halting.\n   *\n   * If parsing takes longer than this, it will halt early, returning `null`.\n   * See {@link Parser#parse} for more information.\n   */\n  setTimeoutMicros(timeout: bigint): void {\n    C._ts_parser_set_timeout_micros(this[0], timeout);\n  }\n\n  /** Set the logging callback that a parser should use during parsing. */\n  setLogger(callback: LogCallback | boolean | null): this {\n    if (!callback) {\n      this.logCallback = null;\n    } else if (typeof callback !== 'function') {\n      throw new Error('Logger callback must be a function');\n    } else {\n      this.logCallback = callback;\n    }\n    return this;\n  }\n\n  /** Get the parser's current logger. */\n  getLogger(): LogCallback | null {\n    return this.logCallback;\n  }\n}\n"],
  "mappings": "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",
  "names": ["module", "i", "i", "start", "i", "info", "name", "i", "i", "name", "binary", "fs", "body", "Module", "binary", "instance", "module", "metadata", "result", "info", "count", "name", "flags", "handle", "func", "i", "err", "memoryBase", "args", "rtn", "libName", "localScope", "wasmExports", "Module", "i"]
}
